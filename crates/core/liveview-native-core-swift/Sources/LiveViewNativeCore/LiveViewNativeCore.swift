// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(LiveViewNativeCoreFFI)
    import LiveViewNativeCoreFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len: 0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_liveview_native_core_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_liveview_native_core_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        lock()
        defer { self.unlock() }
        return try f()
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_UNEXPECTED_ERROR: Int8 = 2
private let CALL_CANCELLED: Int8 = 3

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
    case CALL_SUCCESS:
        return

    case CALL_ERROR:
        if let errorHandler = errorHandler {
            throw try errorHandler(callStatus.errorBuf)
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.unexpectedRustCallError
        }

    case CALL_UNEXPECTED_ERROR:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    case CALL_CANCELLED:
        fatalError("Cancellation not supported yet")

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void
) {
    do {
        try writeReturn(makeCall())
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> Void,
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

    func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        map.count
    }
}

// Public interface members begin here.

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return try Data(readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimeInterval {
        let seconds: UInt64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        return Double(seconds) + (Double(nanoseconds) / 1.0e9)
    }

    public static func write(_ value: TimeInterval, into buf: inout [UInt8]) {
        if value.rounded(.down) > Double(Int64.max) {
            fatalError("Duration overflow, exceeds max bounds supported by Uniffi")
        }

        if value < 0 {
            fatalError("Invalid duration, must be non-negative")
        }

        let seconds = UInt64(value)
        let nanoseconds = UInt32((value - Double(seconds)) * 1.0e9)
        writeInt(&buf, seconds)
        writeInt(&buf, nanoseconds)
    }
}

public protocol ClientStatusesProtocol: AnyObject {
    func currentStatus() -> LiveViewClientStatus

    func nextStatus() async -> LiveViewClientStatus
}

open class ClientStatuses:
    ClientStatusesProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_liveview_native_core_fn_clone_clientstatuses(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_liveview_native_core_fn_free_clientstatuses(pointer, $0) }
    }

    open func currentStatus() -> LiveViewClientStatus {
        return try! FfiConverterTypeLiveViewClientStatus.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_clientstatuses_current_status(self.uniffiClonePointer(), $0)
        })
    }

    open func nextStatus() async -> LiveViewClientStatus {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_liveview_native_core_fn_method_clientstatuses_next_status(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_liveview_native_core_rust_future_poll_rust_buffer,
                completeFunc: ffi_liveview_native_core_rust_future_complete_rust_buffer,
                freeFunc: ffi_liveview_native_core_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypeLiveViewClientStatus.lift,
                errorHandler: nil
            )
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeClientStatuses: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ClientStatuses

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientStatuses {
        return ClientStatuses(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ClientStatuses) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientStatuses {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ClientStatuses, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeClientStatuses_lift(_ pointer: UnsafeMutableRawPointer) throws -> ClientStatuses {
    return try FfiConverterTypeClientStatuses.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeClientStatuses_lower(_ value: ClientStatuses) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClientStatuses.lower(value)
}

public protocol DocumentProtocol: AnyObject {
    func children(_ nodeRef: NodeRef) -> [NodeRef]

    func get(_ nodeRef: NodeRef) -> NodeData

    func getAttributes(_ nodeRef: NodeRef) -> [Attribute]

    func getNode(_ nodeRef: NodeRef) -> Node

    func getParent(_ nodeRef: NodeRef) -> NodeRef?

    func mergeFragmentJson(_ json: String) throws

    func nextUploadId() -> UInt64

    func render() -> String

    func root() -> NodeRef

    func setEventHandler(_ handler: DocumentChangeHandler)
}

open class Document:
    DocumentProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_liveview_native_core_fn_clone_document(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_liveview_native_core_fn_free_document(pointer, $0) }
    }

    public static func empty() -> Document {
        return try! FfiConverterTypeDocument.lift(try! rustCall {
            uniffi_liveview_native_core_fn_constructor_document_empty($0
            )
        })
    }

    public static func parse(_ input: String) throws -> Document {
        return try FfiConverterTypeDocument.lift(rustCallWithError(FfiConverterTypeParseError.lift) {
            uniffi_liveview_native_core_fn_constructor_document_parse(
                FfiConverterString.lower(input), $0
            )
        })
    }

    public static func parseFragmentJson(_ input: String) throws -> Document {
        return try FfiConverterTypeDocument.lift(rustCallWithError(FfiConverterTypeRenderError.lift) {
            uniffi_liveview_native_core_fn_constructor_document_parse_fragment_json(
                FfiConverterString.lower(input), $0
            )
        })
    }

    open func children(_ nodeRef: NodeRef) -> [NodeRef] {
        return try! FfiConverterSequenceTypeNodeRef.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_document_children(self.uniffiClonePointer(),
                                                                    FfiConverterTypeNodeRef.lower(nodeRef), $0)
        })
    }

    open func get(_ nodeRef: NodeRef) -> NodeData {
        return try! FfiConverterTypeNodeData.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_document_get(self.uniffiClonePointer(),
                                                               FfiConverterTypeNodeRef.lower(nodeRef), $0)
        })
    }

    open func getAttributes(_ nodeRef: NodeRef) -> [Attribute] {
        return try! FfiConverterSequenceTypeAttribute.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_document_get_attributes(self.uniffiClonePointer(),
                                                                          FfiConverterTypeNodeRef.lower(nodeRef), $0)
        })
    }

    open func getNode(_ nodeRef: NodeRef) -> Node {
        return try! FfiConverterTypeNode.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_document_get_node(self.uniffiClonePointer(),
                                                                    FfiConverterTypeNodeRef.lower(nodeRef), $0)
        })
    }

    open func getParent(_ nodeRef: NodeRef) -> NodeRef? {
        return try! FfiConverterOptionTypeNodeRef.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_document_get_parent(self.uniffiClonePointer(),
                                                                      FfiConverterTypeNodeRef.lower(nodeRef), $0)
        })
    }

    open func mergeFragmentJson(_ json: String) throws { try rustCallWithError(FfiConverterTypeRenderError.lift) {
        uniffi_liveview_native_core_fn_method_document_merge_fragment_json(self.uniffiClonePointer(),
                                                                           FfiConverterString.lower(json), $0)
    }
    }

    open func nextUploadId() -> UInt64 {
        return try! FfiConverterUInt64.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_document_next_upload_id(self.uniffiClonePointer(), $0)
        })
    }

    open func render() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_document_render(self.uniffiClonePointer(), $0)
        })
    }

    open func root() -> NodeRef {
        return try! FfiConverterTypeNodeRef.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_document_root(self.uniffiClonePointer(), $0)
        })
    }

    open func setEventHandler(_ handler: DocumentChangeHandler) { try! rustCall {
        uniffi_liveview_native_core_fn_method_document_set_event_handler(self.uniffiClonePointer(),
                                                                         FfiConverterCallbackInterfaceDocumentChangeHandler.lower(handler), $0)
    }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeDocument: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Document

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Document {
        return Document(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Document) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Document {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Document, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeDocument_lift(_ pointer: UnsafeMutableRawPointer) throws -> Document {
    return try FfiConverterTypeDocument.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeDocument_lower(_ value: Document) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDocument.lower(value)
}

public protocol LiveChannelProtocol: AnyObject {
    func channel() -> Channel

    func document() -> Document

    func getPhxUploadId(_ phxTargetName: String) throws -> String

    func joinPayload() -> Payload

    /**
     * Blocks indefinitely, processing changes to the document using the user provided callback
     * In `set_event_handler`
     */
    func mergeDiffs() async throws

    func setEventHandler(_ handler: DocumentChangeHandler)

    func shutdownParentSocket() async throws

    func uploadFile(_ file: LiveFile) async throws
}

open class LiveChannel:
    LiveChannelProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_liveview_native_core_fn_clone_livechannel(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_liveview_native_core_fn_free_livechannel(pointer, $0) }
    }

    open func channel() -> Channel {
        return try! FfiConverterTypeChannel_lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_livechannel_channel(self.uniffiClonePointer(), $0)
        })
    }

    open func document() -> Document {
        return try! FfiConverterTypeDocument.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_livechannel_document(self.uniffiClonePointer(), $0)
        })
    }

    open func getPhxUploadId(_ phxTargetName: String) throws -> String {
        return try FfiConverterString.lift(rustCallWithError(FfiConverterTypeLiveSocketError.lift) {
            uniffi_liveview_native_core_fn_method_livechannel_get_phx_upload_id(self.uniffiClonePointer(),
                                                                                FfiConverterString.lower(phxTargetName), $0)
        })
    }

    open func joinPayload() -> Payload {
        return try! FfiConverterTypePayload_lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_livechannel_join_payload(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Blocks indefinitely, processing changes to the document using the user provided callback
     * In `set_event_handler`
     */
    open func mergeDiffs() async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_liveview_native_core_fn_method_livechannel_merge_diffs(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_liveview_native_core_rust_future_poll_void,
                completeFunc: ffi_liveview_native_core_rust_future_complete_void,
                freeFunc: ffi_liveview_native_core_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeLiveSocketError.lift
            )
    }

    open func setEventHandler(_ handler: DocumentChangeHandler) { try! rustCall {
        uniffi_liveview_native_core_fn_method_livechannel_set_event_handler(self.uniffiClonePointer(),
                                                                            FfiConverterCallbackInterfaceDocumentChangeHandler.lower(handler), $0)
    }
    }

    open func shutdownParentSocket() async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_liveview_native_core_fn_method_livechannel_shutdown_parent_socket(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_liveview_native_core_rust_future_poll_void,
                completeFunc: ffi_liveview_native_core_rust_future_complete_void,
                freeFunc: ffi_liveview_native_core_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeLiveSocketError.lift
            )
    }

    open func uploadFile(_ file: LiveFile) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_liveview_native_core_fn_method_livechannel_upload_file(
                        self.uniffiClonePointer(),
                        FfiConverterTypeLiveFile.lower(file)
                    )
                },
                pollFunc: ffi_liveview_native_core_rust_future_poll_void,
                completeFunc: ffi_liveview_native_core_rust_future_complete_void,
                freeFunc: ffi_liveview_native_core_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeLiveSocketError.lift
            )
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLiveChannel: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LiveChannel

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LiveChannel {
        return LiveChannel(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LiveChannel) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiveChannel {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LiveChannel, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveChannel_lift(_ pointer: UnsafeMutableRawPointer) throws -> LiveChannel {
    return try FfiConverterTypeLiveChannel.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveChannel_lower(_ value: LiveChannel) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLiveChannel.lower(value)
}

public protocol LiveFileProtocol: AnyObject {}

open class LiveFile:
    LiveFileProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_liveview_native_core_fn_clone_livefile(self.pointer, $0) }
    }

    /**
     * constructs a new `LiveFile` representing a file ready for preflight and upload.
     *
     * * `contents` binary contents of the file
     * * `mime_type` Compliant mime type string of the data `image/png`, `tiff` etc.
     * * `name` Name of the field in the input, technically, the same as the `allow_upload` atom
     * * `relative_path` name of the file, as a relative path
     * * `phx_upload_id` upload id acquire by passing name to [LiveChannel::get_phx_upload_id]
     */
    public convenience init(_ contents: Data, _ mimeType: String, _ name: String, _ relativePath: String, _ phxUploadId: String) {
        let pointer =
            try! rustCall {
                uniffi_liveview_native_core_fn_constructor_livefile_new(
                    FfiConverterData.lower(contents),
                    FfiConverterString.lower(mimeType),
                    FfiConverterString.lower(name),
                    FfiConverterString.lower(relativePath),
                    FfiConverterString.lower(phxUploadId), $0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_liveview_native_core_fn_free_livefile(pointer, $0) }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLiveFile: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LiveFile

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LiveFile {
        return LiveFile(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LiveFile) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiveFile {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LiveFile, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveFile_lift(_ pointer: UnsafeMutableRawPointer) throws -> LiveFile {
    return try FfiConverterTypeLiveFile.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveFile_lower(_ value: LiveFile) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLiveFile.lower(value)
}

public protocol LiveSocketProtocol: AnyObject {
    /**
     * Navigates the socket to the previous entry in the stack.
     */
    func back(_ joinParams: [String: Json]?, _ info: Data?) async throws -> LiveChannel

    /**
     * Returns whether navigation backward in history is possible.
     */
    func canGoBack() -> Bool

    /**
     * Returns whether navigation forward in history is possible.
     */
    func canGoForward() -> Bool

    /**
     * Returns whether navigation to the specified history entry ID is possible.
     */
    func canTraverseTo(_ id: UInt64) -> Bool

    func cookies() -> [String]

    func csrfToken() -> String

    /**
     * Returns the current history entry, if one exists.
     */
    func current() -> NavHistoryEntry?

    func deadRender() -> Document

    /**
     * Navigates the socket to the next entry in the stack. Reuses the previous channel's connection parameters, closes it safely,
     * and emits a new [LiveChannel]
     */
    func forward(_ joinParams: [String: Json]?, _ info: Data?) async throws -> LiveChannel

    /**
     * Returns a list of all history entries in traversal sequence order.
     */
    func getEntries() -> [NavHistoryEntry]

    func hasLiveReload() -> Bool

    /**
     * Returns the headers of the final dead render response
     */
    func joinHeaders() -> [String: [String]]

    func joinLivereloadChannel() async throws -> LiveChannel

    func joinLiveviewChannel(_ joinParams: [String: Json]?, _ redirect: String?) async throws -> LiveChannel

    /**
     * Returns the url of the final dead render
     */
    func joinUrl() -> String

    /**
     * Navigates the socket to a new URL, reusing the previous channel's connection parameters, closing it safely,
     * and emitting a new [LiveChannel]
     */
    func navigate(_ url: String, _ joinParams: [String: Json]?, _ opts: NavOptions) async throws -> LiveChannel

    /**
     * Reload the current channel.
     */
    func reload(_ joinParams: [String: Json]?, _ info: Data?) async throws -> LiveChannel

    /**
     * Sets the handler for navigation events.
     */
    func setEventHandler(_ handler: NavEventHandler)

    func socket() -> Socket

    /**
     * Returns the socket status
     */
    func status() -> SocketStatus

    func styleUrls() -> [String]

    /**
     * Returns the connection timeout duration for each connection attempt
     */
    func timeout() -> TimeInterval

    /**
     * Navigates the socket to the specified entry in the stack, preserving the stack. Resuses the previous channel's connection parameters, closes it safely,
     * and emits a new [LiveChannel]
     */
    func traverseTo(_ id: UInt64, _ joinParams: [String: Json]?, _ info: Data?) async throws -> LiveChannel
}

open class LiveSocket:
    LiveSocketProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_liveview_native_core_fn_clone_livesocket(self.pointer, $0) }
    }

    public convenience init(_ url: String, _ format: String, _ options: ConnectOpts?, _ socketReconnectStrategy: SocketReconnectStrategy?) async throws {
        let pointer =
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_liveview_native_core_fn_constructor_livesocket_new(FfiConverterString.lower(url), FfiConverterString.lower(format), FfiConverterOptionTypeConnectOpts.lower(options), FfiConverterOptionCallbackInterfaceSocketReconnectStrategy.lower(socketReconnectStrategy))
                },
                pollFunc: ffi_liveview_native_core_rust_future_poll_pointer,
                completeFunc: ffi_liveview_native_core_rust_future_complete_pointer,
                freeFunc: ffi_liveview_native_core_rust_future_free_pointer,
                liftFunc: FfiConverterTypeLiveSocket.lift,
                errorHandler: FfiConverterTypeLiveSocketError.lift
            )

            .uniffiClonePointer()
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_liveview_native_core_fn_free_livesocket(pointer, $0) }
    }

    public static func connect(_ url: String, _ format: String, _ options: ConnectOpts?, _ socketReconnectStrategy: SocketReconnectStrategy?) async throws -> LiveSocket {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_liveview_native_core_fn_constructor_livesocket_connect(FfiConverterString.lower(url), FfiConverterString.lower(format), FfiConverterOptionTypeConnectOpts.lower(options), FfiConverterOptionCallbackInterfaceSocketReconnectStrategy.lower(socketReconnectStrategy))
                },
                pollFunc: ffi_liveview_native_core_rust_future_poll_pointer,
                completeFunc: ffi_liveview_native_core_rust_future_complete_pointer,
                freeFunc: ffi_liveview_native_core_rust_future_free_pointer,
                liftFunc: FfiConverterTypeLiveSocket.lift,
                errorHandler: FfiConverterTypeLiveSocketError.lift
            )
    }

    /**
     * Navigates the socket to the previous entry in the stack.
     */
    open func back(_ joinParams: [String: Json]?, _ info: Data?) async throws -> LiveChannel {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_liveview_native_core_fn_method_livesocket_back(
                        self.uniffiClonePointer(),
                        FfiConverterOptionDictionaryStringTypeJSON.lower(joinParams), FfiConverterOptionData.lower(info)
                    )
                },
                pollFunc: ffi_liveview_native_core_rust_future_poll_pointer,
                completeFunc: ffi_liveview_native_core_rust_future_complete_pointer,
                freeFunc: ffi_liveview_native_core_rust_future_free_pointer,
                liftFunc: FfiConverterTypeLiveChannel.lift,
                errorHandler: FfiConverterTypeLiveSocketError.lift
            )
    }

    /**
     * Returns whether navigation backward in history is possible.
     */
    open func canGoBack() -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_livesocket_can_go_back(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns whether navigation forward in history is possible.
     */
    open func canGoForward() -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_livesocket_can_go_forward(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns whether navigation to the specified history entry ID is possible.
     */
    open func canTraverseTo(_ id: UInt64) -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_livesocket_can_traverse_to(self.uniffiClonePointer(),
                                                                             FfiConverterUInt64.lower(id), $0)
        })
    }

    open func cookies() -> [String] {
        return try! FfiConverterSequenceString.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_livesocket_cookies(self.uniffiClonePointer(), $0)
        })
    }

    open func csrfToken() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_livesocket_csrf_token(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns the current history entry, if one exists.
     */
    open func current() -> NavHistoryEntry? {
        return try! FfiConverterOptionTypeNavHistoryEntry.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_livesocket_current(self.uniffiClonePointer(), $0)
        })
    }

    open func deadRender() -> Document {
        return try! FfiConverterTypeDocument.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_livesocket_dead_render(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Navigates the socket to the next entry in the stack. Reuses the previous channel's connection parameters, closes it safely,
     * and emits a new [LiveChannel]
     */
    open func forward(_ joinParams: [String: Json]?, _ info: Data?) async throws -> LiveChannel {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_liveview_native_core_fn_method_livesocket_forward(
                        self.uniffiClonePointer(),
                        FfiConverterOptionDictionaryStringTypeJSON.lower(joinParams), FfiConverterOptionData.lower(info)
                    )
                },
                pollFunc: ffi_liveview_native_core_rust_future_poll_pointer,
                completeFunc: ffi_liveview_native_core_rust_future_complete_pointer,
                freeFunc: ffi_liveview_native_core_rust_future_free_pointer,
                liftFunc: FfiConverterTypeLiveChannel.lift,
                errorHandler: FfiConverterTypeLiveSocketError.lift
            )
    }

    /**
     * Returns a list of all history entries in traversal sequence order.
     */
    open func getEntries() -> [NavHistoryEntry] {
        return try! FfiConverterSequenceTypeNavHistoryEntry.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_livesocket_get_entries(self.uniffiClonePointer(), $0)
        })
    }

    open func hasLiveReload() -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_livesocket_has_live_reload(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns the headers of the final dead render response
     */
    open func joinHeaders() -> [String: [String]] {
        return try! FfiConverterDictionaryStringSequenceString.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_livesocket_join_headers(self.uniffiClonePointer(), $0)
        })
    }

    open func joinLivereloadChannel() async throws -> LiveChannel {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_liveview_native_core_fn_method_livesocket_join_livereload_channel(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_liveview_native_core_rust_future_poll_pointer,
                completeFunc: ffi_liveview_native_core_rust_future_complete_pointer,
                freeFunc: ffi_liveview_native_core_rust_future_free_pointer,
                liftFunc: FfiConverterTypeLiveChannel.lift,
                errorHandler: FfiConverterTypeLiveSocketError.lift
            )
    }

    open func joinLiveviewChannel(_ joinParams: [String: Json]?, _ redirect: String?) async throws -> LiveChannel {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_liveview_native_core_fn_method_livesocket_join_liveview_channel(
                        self.uniffiClonePointer(),
                        FfiConverterOptionDictionaryStringTypeJSON.lower(joinParams), FfiConverterOptionString.lower(redirect)
                    )
                },
                pollFunc: ffi_liveview_native_core_rust_future_poll_pointer,
                completeFunc: ffi_liveview_native_core_rust_future_complete_pointer,
                freeFunc: ffi_liveview_native_core_rust_future_free_pointer,
                liftFunc: FfiConverterTypeLiveChannel.lift,
                errorHandler: FfiConverterTypeLiveSocketError.lift
            )
    }

    /**
     * Returns the url of the final dead render
     */
    open func joinUrl() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_livesocket_join_url(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Navigates the socket to a new URL, reusing the previous channel's connection parameters, closing it safely,
     * and emitting a new [LiveChannel]
     */
    open func navigate(_ url: String, _ joinParams: [String: Json]?, _ opts: NavOptions) async throws -> LiveChannel {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_liveview_native_core_fn_method_livesocket_navigate(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(url), FfiConverterOptionDictionaryStringTypeJSON.lower(joinParams), FfiConverterTypeNavOptions.lower(opts)
                    )
                },
                pollFunc: ffi_liveview_native_core_rust_future_poll_pointer,
                completeFunc: ffi_liveview_native_core_rust_future_complete_pointer,
                freeFunc: ffi_liveview_native_core_rust_future_free_pointer,
                liftFunc: FfiConverterTypeLiveChannel.lift,
                errorHandler: FfiConverterTypeLiveSocketError.lift
            )
    }

    /**
     * Reload the current channel.
     */
    open func reload(_ joinParams: [String: Json]?, _ info: Data?) async throws -> LiveChannel {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_liveview_native_core_fn_method_livesocket_reload(
                        self.uniffiClonePointer(),
                        FfiConverterOptionDictionaryStringTypeJSON.lower(joinParams), FfiConverterOptionData.lower(info)
                    )
                },
                pollFunc: ffi_liveview_native_core_rust_future_poll_pointer,
                completeFunc: ffi_liveview_native_core_rust_future_complete_pointer,
                freeFunc: ffi_liveview_native_core_rust_future_free_pointer,
                liftFunc: FfiConverterTypeLiveChannel.lift,
                errorHandler: FfiConverterTypeLiveSocketError.lift
            )
    }

    /**
     * Sets the handler for navigation events.
     */
    open func setEventHandler(_ handler: NavEventHandler) { try! rustCall {
        uniffi_liveview_native_core_fn_method_livesocket_set_event_handler(self.uniffiClonePointer(),
                                                                           FfiConverterCallbackInterfaceNavEventHandler.lower(handler), $0)
    }
    }

    open func socket() -> Socket {
        return try! FfiConverterTypeSocket_lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_livesocket_socket(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns the socket status
     */
    open func status() -> SocketStatus {
        return try! FfiConverterTypeSocketStatus_lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_livesocket_status(self.uniffiClonePointer(), $0)
        })
    }

    open func styleUrls() -> [String] {
        return try! FfiConverterSequenceString.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_livesocket_style_urls(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns the connection timeout duration for each connection attempt
     */
    open func timeout() -> TimeInterval {
        return try! FfiConverterDuration.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_livesocket_timeout(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Navigates the socket to the specified entry in the stack, preserving the stack. Resuses the previous channel's connection parameters, closes it safely,
     * and emits a new [LiveChannel]
     */
    open func traverseTo(_ id: UInt64, _ joinParams: [String: Json]?, _ info: Data?) async throws -> LiveChannel {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_liveview_native_core_fn_method_livesocket_traverse_to(
                        self.uniffiClonePointer(),
                        FfiConverterUInt64.lower(id), FfiConverterOptionDictionaryStringTypeJSON.lower(joinParams), FfiConverterOptionData.lower(info)
                    )
                },
                pollFunc: ffi_liveview_native_core_rust_future_poll_pointer,
                completeFunc: ffi_liveview_native_core_rust_future_complete_pointer,
                freeFunc: ffi_liveview_native_core_rust_future_free_pointer,
                liftFunc: FfiConverterTypeLiveChannel.lift,
                errorHandler: FfiConverterTypeLiveSocketError.lift
            )
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLiveSocket: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LiveSocket

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LiveSocket {
        return LiveSocket(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LiveSocket) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiveSocket {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LiveSocket, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveSocket_lift(_ pointer: UnsafeMutableRawPointer) throws -> LiveSocket {
    return try FfiConverterTypeLiveSocket.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveSocket_lower(_ value: LiveSocket) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLiveSocket.lower(value)
}

/**
 * The main entry for any LiveView native client.
 * It is initialized with a [LiveClientBuilder], using many
 * different callback objects to instrument a background event loop
 * which creates connections and responds to server events as needed.
 */
public protocol LiveViewClientProtocol: AnyObject {
    /**
     * Navigates back one step in the history stack.
     * This function fails if there are no items in history.
     */
    func back(_ opts: NavActionOptions) throws -> UInt64

    func call(_ eventName: String, _ payload: Payload) async throws -> Payload

    /**
     * returns true if the navigation stack can support going backwards.
     */
    func canGoBack() -> Bool

    /**
     * returns true if the navigation stack can support navigating forwards.
     */
    func canGoForward() -> Bool

    func canTraverseTo(_ id: UInt64) -> Bool

    /**
     * Sends an event to the server without waiting for a reply.
     */
    func cast(_ eventName: String, _ payload: Payload) async

    /**
     * Returns the csrf token found on the current dead render.
     */
    func csrfToken() throws -> String

    /**
     * Returns the current history entry, Should virtually never return a nullish
     * value unless a connection error has occurred and not been properly recovered from.
     */
    func current() -> NavHistoryEntry?

    /**
     * Returns the dead render fetched before establishing the main websocket connection.
     *
     * A dead render is an html page containing meta data needed to establish a
     * websocket connection and a live view channel on the websocket. It also
     * may contain a live reload channel -- a side channel for pushing events
     * related to asset changes made by a developer which force a total reload.
     */
    func deadRender() throws -> Document

    func disconnect() async throws

    /**
     * Returns a document which contains the current state of the live view
     * in a platform specific markup. This will change under your feet as diffs are
     * applied by the server. It also may change as the live view is reloaded, in order
     * to have a pointer to the most up to date document make sure to instrument the
     * network events callback object in the [LiveViewClientBuilder] object.
     */
    func document() throws -> Document

    /**
     * Navigates back one step in the history stack.
     * This function fails if there are no items ahead of this one in history.
     */
    func forward(_ opts: NavActionOptions) throws -> UInt64

    /**
     * Returns a list of all History entries currently tracked by the
     * navigation context. There are no guarantees about the position of the
     * current element in this list.
     */
    func getEntries() -> [NavHistoryEntry]

    /**
     * Returns an ID for a given upload target. Uploads in phoenix live view
     * need an ID to indicate to the server which upload is being targeted. The meta
     * data is contained in the document - this is a convenience function for fetching it.;
     */
    func getPhxUploadId(_ phxTargetName: String) throws -> String

    /**
     * Returns the payload returned upon joining the live view channel of
     * the current view.
     */
    func joinPayload() throws -> Payload

    /**
     * Returns the url which provided the current views dead render.
     */
    func joinUrl() throws -> String

    /**
     * Navigate to `url` with behavior and metadata specified in `opts`.
     */
    func navigate(_ url: String, _ opts: NavOptions) throws -> UInt64

    /**
     * Attempts to reconnect to a view by posting a form with fields `form`
     * reestablishing the liveview with `join_params` and using the headers provided
     * to fetch the dead render. automatically adds the content type header.
     */
    func postForm(_ url: String, _ form: [String: String], _ joinParams: [String: Json]?, _ headers: [String: String]?) async throws

    func reconnect(_ url: String, _ clientOpts: ClientConnectOpts) async throws

    /**
     * Dispose of the current channel and remount the view. Replaces the current view
     * event data with the bytes in `info`
     */
    func reload(_ opts: NavActionOptions) throws -> UInt64

    /**
     * Set the log level for the current process.
     */
    func setLogLevel(_ level: LogLevel)

    func shutdown()

    /**
     * Returns the current client status
     */
    func status() -> LiveViewClientStatus

    func statusStream() -> ClientStatuses

    /**
     * returns the urls for style objects referenced by the current live view.
     */
    func styleUrls() throws -> [String]

    /**
     * Navigates to the entry with `id`. Retaining the state of the current history stack.
     * This function fails if the entry has been removed.
     */
    func traverseTo(_ id: UInt64, _ opts: NavActionOptions) throws -> UInt64

    /**
     * Uploads the live files in `files`
     *
     * Note: currently the replies in the file upload work flow are
     * not responded to or respect in the main event loop, this means there will be
     * no progress updates as the file is uploaded.
     */
    func uploadFiles(_ files: [LiveFile]) async throws
}

/**
 * The main entry for any LiveView native client.
 * It is initialized with a [LiveClientBuilder], using many
 * different callback objects to instrument a background event loop
 * which creates connections and responds to server events as needed.
 */
open class LiveViewClient:
    LiveViewClientProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_liveview_native_core_fn_clone_liveviewclient(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_liveview_native_core_fn_free_liveviewclient(pointer, $0) }
    }

    /**
     * Navigates back one step in the history stack.
     * This function fails if there are no items in history.
     */
    open func back(_ opts: NavActionOptions) throws -> UInt64 {
        return try FfiConverterUInt64.lift(rustCallWithError(FfiConverterTypeLiveSocketError.lift) {
            uniffi_liveview_native_core_fn_method_liveviewclient_back(self.uniffiClonePointer(),
                                                                      FfiConverterTypeNavActionOptions.lower(opts), $0)
        })
    }

    open func call(_ eventName: String, _ payload: Payload) async throws -> Payload {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_liveview_native_core_fn_method_liveviewclient_call(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(eventName), FfiConverterTypePayload_lower(payload)
                    )
                },
                pollFunc: ffi_liveview_native_core_rust_future_poll_rust_buffer,
                completeFunc: ffi_liveview_native_core_rust_future_complete_rust_buffer,
                freeFunc: ffi_liveview_native_core_rust_future_free_rust_buffer,
                liftFunc: FfiConverterTypePayload_lift,
                errorHandler: FfiConverterTypeLiveSocketError.lift
            )
    }

    /**
     * returns true if the navigation stack can support going backwards.
     */
    open func canGoBack() -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_liveviewclient_can_go_back(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * returns true if the navigation stack can support navigating forwards.
     */
    open func canGoForward() -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_liveviewclient_can_go_forward(self.uniffiClonePointer(), $0)
        })
    }

    open func canTraverseTo(_ id: UInt64) -> Bool {
        return try! FfiConverterBool.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_liveviewclient_can_traverse_to(self.uniffiClonePointer(),
                                                                                 FfiConverterUInt64.lower(id), $0)
        })
    }

    /**
     * Sends an event to the server without waiting for a reply.
     */
    open func cast(_ eventName: String, _ payload: Payload) async {
        return
            try! await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_liveview_native_core_fn_method_liveviewclient_cast(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(eventName), FfiConverterTypePayload_lower(payload)
                    )
                },
                pollFunc: ffi_liveview_native_core_rust_future_poll_void,
                completeFunc: ffi_liveview_native_core_rust_future_complete_void,
                freeFunc: ffi_liveview_native_core_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: nil
            )
    }

    /**
     * Returns the csrf token found on the current dead render.
     */
    open func csrfToken() throws -> String {
        return try FfiConverterString.lift(rustCallWithError(FfiConverterTypeLiveSocketError.lift) {
            uniffi_liveview_native_core_fn_method_liveviewclient_csrf_token(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns the current history entry, Should virtually never return a nullish
     * value unless a connection error has occurred and not been properly recovered from.
     */
    open func current() -> NavHistoryEntry? {
        return try! FfiConverterOptionTypeNavHistoryEntry.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_liveviewclient_current(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns the dead render fetched before establishing the main websocket connection.
     *
     * A dead render is an html page containing meta data needed to establish a
     * websocket connection and a live view channel on the websocket. It also
     * may contain a live reload channel -- a side channel for pushing events
     * related to asset changes made by a developer which force a total reload.
     */
    open func deadRender() throws -> Document {
        return try FfiConverterTypeDocument.lift(rustCallWithError(FfiConverterTypeLiveSocketError.lift) {
            uniffi_liveview_native_core_fn_method_liveviewclient_dead_render(self.uniffiClonePointer(), $0)
        })
    }

    open func disconnect() async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_liveview_native_core_fn_method_liveviewclient_disconnect(
                        self.uniffiClonePointer()
                    )
                },
                pollFunc: ffi_liveview_native_core_rust_future_poll_void,
                completeFunc: ffi_liveview_native_core_rust_future_complete_void,
                freeFunc: ffi_liveview_native_core_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeLiveSocketError.lift
            )
    }

    /**
     * Returns a document which contains the current state of the live view
     * in a platform specific markup. This will change under your feet as diffs are
     * applied by the server. It also may change as the live view is reloaded, in order
     * to have a pointer to the most up to date document make sure to instrument the
     * network events callback object in the [LiveViewClientBuilder] object.
     */
    open func document() throws -> Document {
        return try FfiConverterTypeDocument.lift(rustCallWithError(FfiConverterTypeLiveSocketError.lift) {
            uniffi_liveview_native_core_fn_method_liveviewclient_document(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Navigates back one step in the history stack.
     * This function fails if there are no items ahead of this one in history.
     */
    open func forward(_ opts: NavActionOptions) throws -> UInt64 {
        return try FfiConverterUInt64.lift(rustCallWithError(FfiConverterTypeLiveSocketError.lift) {
            uniffi_liveview_native_core_fn_method_liveviewclient_forward(self.uniffiClonePointer(),
                                                                         FfiConverterTypeNavActionOptions.lower(opts), $0)
        })
    }

    /**
     * Returns a list of all History entries currently tracked by the
     * navigation context. There are no guarantees about the position of the
     * current element in this list.
     */
    open func getEntries() -> [NavHistoryEntry] {
        return try! FfiConverterSequenceTypeNavHistoryEntry.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_liveviewclient_get_entries(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns an ID for a given upload target. Uploads in phoenix live view
     * need an ID to indicate to the server which upload is being targeted. The meta
     * data is contained in the document - this is a convenience function for fetching it.;
     */
    open func getPhxUploadId(_ phxTargetName: String) throws -> String {
        return try FfiConverterString.lift(rustCallWithError(FfiConverterTypeLiveSocketError.lift) {
            uniffi_liveview_native_core_fn_method_liveviewclient_get_phx_upload_id(self.uniffiClonePointer(),
                                                                                   FfiConverterString.lower(phxTargetName), $0)
        })
    }

    /**
     * Returns the payload returned upon joining the live view channel of
     * the current view.
     */
    open func joinPayload() throws -> Payload {
        return try FfiConverterTypePayload_lift(rustCallWithError(FfiConverterTypeLiveSocketError.lift) {
            uniffi_liveview_native_core_fn_method_liveviewclient_join_payload(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns the url which provided the current views dead render.
     */
    open func joinUrl() throws -> String {
        return try FfiConverterString.lift(rustCallWithError(FfiConverterTypeLiveSocketError.lift) {
            uniffi_liveview_native_core_fn_method_liveviewclient_join_url(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Navigate to `url` with behavior and metadata specified in `opts`.
     */
    open func navigate(_ url: String, _ opts: NavOptions) throws -> UInt64 {
        return try FfiConverterUInt64.lift(rustCallWithError(FfiConverterTypeLiveSocketError.lift) {
            uniffi_liveview_native_core_fn_method_liveviewclient_navigate(self.uniffiClonePointer(),
                                                                          FfiConverterString.lower(url),
                                                                          FfiConverterTypeNavOptions.lower(opts), $0)
        })
    }

    /**
     * Attempts to reconnect to a view by posting a form with fields `form`
     * reestablishing the liveview with `join_params` and using the headers provided
     * to fetch the dead render. automatically adds the content type header.
     */
    open func postForm(_ url: String, _ form: [String: String], _ joinParams: [String: Json]?, _ headers: [String: String]?) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_liveview_native_core_fn_method_liveviewclient_post_form(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(url), FfiConverterDictionaryStringString.lower(form), FfiConverterOptionDictionaryStringTypeJSON.lower(joinParams), FfiConverterOptionDictionaryStringString.lower(headers)
                    )
                },
                pollFunc: ffi_liveview_native_core_rust_future_poll_void,
                completeFunc: ffi_liveview_native_core_rust_future_complete_void,
                freeFunc: ffi_liveview_native_core_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeLiveSocketError.lift
            )
    }

    open func reconnect(_ url: String, _ clientOpts: ClientConnectOpts) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_liveview_native_core_fn_method_liveviewclient_reconnect(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(url), FfiConverterTypeClientConnectOpts.lower(clientOpts)
                    )
                },
                pollFunc: ffi_liveview_native_core_rust_future_poll_void,
                completeFunc: ffi_liveview_native_core_rust_future_complete_void,
                freeFunc: ffi_liveview_native_core_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeLiveSocketError.lift
            )
    }

    /**
     * Dispose of the current channel and remount the view. Replaces the current view
     * event data with the bytes in `info`
     */
    open func reload(_ opts: NavActionOptions) throws -> UInt64 {
        return try FfiConverterUInt64.lift(rustCallWithError(FfiConverterTypeLiveSocketError.lift) {
            uniffi_liveview_native_core_fn_method_liveviewclient_reload(self.uniffiClonePointer(),
                                                                        FfiConverterTypeNavActionOptions.lower(opts), $0)
        })
    }

    /**
     * Set the log level for the current process.
     */
    open func setLogLevel(_ level: LogLevel) { try! rustCall {
        uniffi_liveview_native_core_fn_method_liveviewclient_set_log_level(self.uniffiClonePointer(),
                                                                           FfiConverterTypeLogLevel.lower(level), $0)
    }
    }

    open func shutdown() { try! rustCall {
        uniffi_liveview_native_core_fn_method_liveviewclient_shutdown(self.uniffiClonePointer(), $0)
    }
    }

    /**
     * Returns the current client status
     */
    open func status() -> LiveViewClientStatus {
        return try! FfiConverterTypeLiveViewClientStatus.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_liveviewclient_status(self.uniffiClonePointer(), $0)
        })
    }

    open func statusStream() -> ClientStatuses {
        return try! FfiConverterTypeClientStatuses.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_liveviewclient_status_stream(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * returns the urls for style objects referenced by the current live view.
     */
    open func styleUrls() throws -> [String] {
        return try FfiConverterSequenceString.lift(rustCallWithError(FfiConverterTypeLiveSocketError.lift) {
            uniffi_liveview_native_core_fn_method_liveviewclient_style_urls(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Navigates to the entry with `id`. Retaining the state of the current history stack.
     * This function fails if the entry has been removed.
     */
    open func traverseTo(_ id: UInt64, _ opts: NavActionOptions) throws -> UInt64 {
        return try FfiConverterUInt64.lift(rustCallWithError(FfiConverterTypeLiveSocketError.lift) {
            uniffi_liveview_native_core_fn_method_liveviewclient_traverse_to(self.uniffiClonePointer(),
                                                                             FfiConverterUInt64.lower(id),
                                                                             FfiConverterTypeNavActionOptions.lower(opts), $0)
        })
    }

    /**
     * Uploads the live files in `files`
     *
     * Note: currently the replies in the file upload work flow are
     * not responded to or respect in the main event loop, this means there will be
     * no progress updates as the file is uploaded.
     */
    open func uploadFiles(_ files: [LiveFile]) async throws {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_liveview_native_core_fn_method_liveviewclient_upload_files(
                        self.uniffiClonePointer(),
                        FfiConverterSequenceTypeLiveFile.lower(files)
                    )
                },
                pollFunc: ffi_liveview_native_core_rust_future_poll_void,
                completeFunc: ffi_liveview_native_core_rust_future_complete_void,
                freeFunc: ffi_liveview_native_core_rust_future_free_void,
                liftFunc: { $0 },
                errorHandler: FfiConverterTypeLiveSocketError.lift
            )
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLiveViewClient: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LiveViewClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LiveViewClient {
        return LiveViewClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LiveViewClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiveViewClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LiveViewClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveViewClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> LiveViewClient {
    return try FfiConverterTypeLiveViewClient.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveViewClient_lower(_ value: LiveViewClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLiveViewClient.lower(value)
}

/**
 * A configuration interface for building a [LiveViewClient].
 * Options on this object will used for all http and websocket connections
 * through out the current session.
 *
 * Additionally provides the [LiveViewClient] with callbacks and essential functionality,
 * without proper configuration your client may not function properly.
 * See [LiveViewClientBuilder::set_persistence_provider]
 */
public protocol LiveViewClientBuilderProtocol: AnyObject {
    /**
     * Attempt to establish a new, connected [LiveViewClient] with the param set above
     */
    func connect(_ url: String, _ opts: ClientConnectOpts) async throws -> LiveViewClient

    /**
     * Returns the current dead render timeout in milliseconds.
     */
    func deadRenderTimeout() -> UInt64

    /**
     * Returns the current platform format setting.
     */
    func format() -> Platform

    /**
     * Returns the current log level setting.
     */
    func logLevel() -> LogLevel

    /**
     * Set the time out for establishign the initial http connection in milliseconds.
     *
     * By default the timeout is 30 seconds.
     */
    func setDeadRenderTimeoutMs(_ timeout: UInt64)

    /**
     * Sets the '_format' arg set upon fetching the dead render and upon
     * establishing the websocket connection.
     *
     * On android this defaults to [Platform::Jetpack], on apple vendored
     * devices this defaults to [Platform::Swiftui], everywhere else it
     * defaults to "unknown", which will cause a connection failure.
     */
    func setFormat(_ format: Platform)

    /**
     * Provides the [LiveViewClient] with a way to store Cookies, and potentially other
     * user session data like settings.
     */
    func setLiveChannelEventHandler(_ handler: NetworkEventHandler)

    /**
     * Set the log filter level.
     *
     * By Default the log filter is set to [LogLevel::Info]
     */
    func setLogLevel(_ level: LogLevel)

    /**
     * This is an endpoint intended for client developers to instrument navigation and
     * store view state. By default it permits all navigation.
     */
    func setNavigationHandler(_ handler: NavEventHandler)

    /**
     * The [DocumentChangeHandler] here will be called whenever a diff event
     * applies a change to the document that is being observed. By default,
     * no events will be emitted
     */
    func setPatchHandler(_ handler: DocumentChangeHandler)

    /**
     * Provides the [LiveViewClient] with a way to store Cookies, and potentially other
     * user session data like settings.
     */
    func setPersistenceProvider(_ provider: SecurePersistentStore)

    func setSocketReconnectStrategy(_ handler: SocketReconnectStrategy)

    /**
     * Set the time out for awaiting responses from the websocket in milliseconds.
     *
     * By default the timeout is 5 seconds.
     */
    func setWebsocketTimeoutMs(_ timeout: UInt64)

    /**
     * Returns the current websocket timeout in milliseconds.
     */
    func websocketTimeout() -> UInt64
}

/**
 * A configuration interface for building a [LiveViewClient].
 * Options on this object will used for all http and websocket connections
 * through out the current session.
 *
 * Additionally provides the [LiveViewClient] with callbacks and essential functionality,
 * without proper configuration your client may not function properly.
 * See [LiveViewClientBuilder::set_persistence_provider]
 */
open class LiveViewClientBuilder:
    LiveViewClientBuilderProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_liveview_native_core_fn_clone_liveviewclientbuilder(self.pointer, $0) }
    }

    public convenience init() {
        let pointer =
            try! rustCall {
                uniffi_liveview_native_core_fn_constructor_liveviewclientbuilder_new($0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_liveview_native_core_fn_free_liveviewclientbuilder(pointer, $0) }
    }

    /**
     * Attempt to establish a new, connected [LiveViewClient] with the param set above
     */
    open func connect(_ url: String, _ opts: ClientConnectOpts) async throws -> LiveViewClient {
        return
            try await uniffiRustCallAsync(
                rustFutureFunc: {
                    uniffi_liveview_native_core_fn_method_liveviewclientbuilder_connect(
                        self.uniffiClonePointer(),
                        FfiConverterString.lower(url), FfiConverterTypeClientConnectOpts.lower(opts)
                    )
                },
                pollFunc: ffi_liveview_native_core_rust_future_poll_pointer,
                completeFunc: ffi_liveview_native_core_rust_future_complete_pointer,
                freeFunc: ffi_liveview_native_core_rust_future_free_pointer,
                liftFunc: FfiConverterTypeLiveViewClient.lift,
                errorHandler: FfiConverterTypeLiveSocketError.lift
            )
    }

    /**
     * Returns the current dead render timeout in milliseconds.
     */
    open func deadRenderTimeout() -> UInt64 {
        return try! FfiConverterUInt64.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_liveviewclientbuilder_dead_render_timeout(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns the current platform format setting.
     */
    open func format() -> Platform {
        return try! FfiConverterTypePlatform.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_liveviewclientbuilder_format(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Returns the current log level setting.
     */
    open func logLevel() -> LogLevel {
        return try! FfiConverterTypeLogLevel.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_liveviewclientbuilder_log_level(self.uniffiClonePointer(), $0)
        })
    }

    /**
     * Set the time out for establishign the initial http connection in milliseconds.
     *
     * By default the timeout is 30 seconds.
     */
    open func setDeadRenderTimeoutMs(_ timeout: UInt64) { try! rustCall {
        uniffi_liveview_native_core_fn_method_liveviewclientbuilder_set_dead_render_timeout_ms(self.uniffiClonePointer(),
                                                                                               FfiConverterUInt64.lower(timeout), $0)
    }
    }

    /**
     * Sets the '_format' arg set upon fetching the dead render and upon
     * establishing the websocket connection.
     *
     * On android this defaults to [Platform::Jetpack], on apple vendored
     * devices this defaults to [Platform::Swiftui], everywhere else it
     * defaults to "unknown", which will cause a connection failure.
     */
    open func setFormat(_ format: Platform) { try! rustCall {
        uniffi_liveview_native_core_fn_method_liveviewclientbuilder_set_format(self.uniffiClonePointer(),
                                                                               FfiConverterTypePlatform.lower(format), $0)
    }
    }

    /**
     * Provides the [LiveViewClient] with a way to store Cookies, and potentially other
     * user session data like settings.
     */
    open func setLiveChannelEventHandler(_ handler: NetworkEventHandler) { try! rustCall {
        uniffi_liveview_native_core_fn_method_liveviewclientbuilder_set_live_channel_event_handler(self.uniffiClonePointer(),
                                                                                                   FfiConverterCallbackInterfaceNetworkEventHandler.lower(handler), $0)
    }
    }

    /**
     * Set the log filter level.
     *
     * By Default the log filter is set to [LogLevel::Info]
     */
    open func setLogLevel(_ level: LogLevel) { try! rustCall {
        uniffi_liveview_native_core_fn_method_liveviewclientbuilder_set_log_level(self.uniffiClonePointer(),
                                                                                  FfiConverterTypeLogLevel.lower(level), $0)
    }
    }

    /**
     * This is an endpoint intended for client developers to instrument navigation and
     * store view state. By default it permits all navigation.
     */
    open func setNavigationHandler(_ handler: NavEventHandler) { try! rustCall {
        uniffi_liveview_native_core_fn_method_liveviewclientbuilder_set_navigation_handler(self.uniffiClonePointer(),
                                                                                           FfiConverterCallbackInterfaceNavEventHandler.lower(handler), $0)
    }
    }

    /**
     * The [DocumentChangeHandler] here will be called whenever a diff event
     * applies a change to the document that is being observed. By default,
     * no events will be emitted
     */
    open func setPatchHandler(_ handler: DocumentChangeHandler) { try! rustCall {
        uniffi_liveview_native_core_fn_method_liveviewclientbuilder_set_patch_handler(self.uniffiClonePointer(),
                                                                                      FfiConverterCallbackInterfaceDocumentChangeHandler.lower(handler), $0)
    }
    }

    /**
     * Provides the [LiveViewClient] with a way to store Cookies, and potentially other
     * user session data like settings.
     */
    open func setPersistenceProvider(_ provider: SecurePersistentStore) { try! rustCall {
        uniffi_liveview_native_core_fn_method_liveviewclientbuilder_set_persistence_provider(self.uniffiClonePointer(),
                                                                                             FfiConverterCallbackInterfaceSecurePersistentStore.lower(provider), $0)
    }
    }

    open func setSocketReconnectStrategy(_ handler: SocketReconnectStrategy) { try! rustCall {
        uniffi_liveview_native_core_fn_method_liveviewclientbuilder_set_socket_reconnect_strategy(self.uniffiClonePointer(),
                                                                                                  FfiConverterCallbackInterfaceSocketReconnectStrategy.lower(handler), $0)
    }
    }

    /**
     * Set the time out for awaiting responses from the websocket in milliseconds.
     *
     * By default the timeout is 5 seconds.
     */
    open func setWebsocketTimeoutMs(_ timeout: UInt64) { try! rustCall {
        uniffi_liveview_native_core_fn_method_liveviewclientbuilder_set_websocket_timeout_ms(self.uniffiClonePointer(),
                                                                                             FfiConverterUInt64.lower(timeout), $0)
    }
    }

    /**
     * Returns the current websocket timeout in milliseconds.
     */
    open func websocketTimeout() -> UInt64 {
        return try! FfiConverterUInt64.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_liveviewclientbuilder_websocket_timeout(self.uniffiClonePointer(), $0)
        })
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLiveViewClientBuilder: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LiveViewClientBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LiveViewClientBuilder {
        return LiveViewClientBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LiveViewClientBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiveViewClientBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LiveViewClientBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveViewClientBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> LiveViewClientBuilder {
    return try FfiConverterTypeLiveViewClientBuilder.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveViewClientBuilder_lower(_ value: LiveViewClientBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLiveViewClientBuilder.lower(value)
}

public protocol NodeProtocol: AnyObject {
    func attributes() -> [Attribute]

    func data() -> NodeData

    func display() -> String

    func document() -> Document

    func getAttribute(_ name: AttributeName) -> Attribute?

    func getChildren() -> [Node]

    func getDepthFirstChildren() -> [Node]

    func nodeId() -> NodeRef
}

open class Node:
    NodeProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_liveview_native_core_fn_clone_node(self.pointer, $0) }
    }

    public convenience init(_ document: Document, _ id: NodeRef, _ data: NodeData) {
        let pointer =
            try! rustCall {
                uniffi_liveview_native_core_fn_constructor_node_new(
                    FfiConverterTypeDocument.lower(document),
                    FfiConverterTypeNodeRef.lower(id),
                    FfiConverterTypeNodeData.lower(data), $0
                )
            }
        self.init(unsafeFromRawPointer: pointer)
    }

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_liveview_native_core_fn_free_node(pointer, $0) }
    }

    open func attributes() -> [Attribute] {
        return try! FfiConverterSequenceTypeAttribute.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_node_attributes(self.uniffiClonePointer(), $0)
        })
    }

    open func data() -> NodeData {
        return try! FfiConverterTypeNodeData.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_node_data(self.uniffiClonePointer(), $0)
        })
    }

    open func display() -> String {
        return try! FfiConverterString.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_node_display(self.uniffiClonePointer(), $0)
        })
    }

    open func document() -> Document {
        return try! FfiConverterTypeDocument.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_node_document(self.uniffiClonePointer(), $0)
        })
    }

    open func getAttribute(_ name: AttributeName) -> Attribute? {
        return try! FfiConverterOptionTypeAttribute.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_node_get_attribute(self.uniffiClonePointer(),
                                                                     FfiConverterTypeAttributeName.lower(name), $0)
        })
    }

    open func getChildren() -> [Node] {
        return try! FfiConverterSequenceTypeNode.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_node_get_children(self.uniffiClonePointer(), $0)
        })
    }

    open func getDepthFirstChildren() -> [Node] {
        return try! FfiConverterSequenceTypeNode.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_node_get_depth_first_children(self.uniffiClonePointer(), $0)
        })
    }

    open func nodeId() -> NodeRef {
        return try! FfiConverterTypeNodeRef.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_node_node_id(self.uniffiClonePointer(), $0)
        })
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeNode: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Node

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Node {
        return Node(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Node) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Node {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Node, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNode_lift(_ pointer: UnsafeMutableRawPointer) throws -> Node {
    return try FfiConverterTypeNode.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNode_lower(_ value: Node) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNode.lower(value)
}

public protocol NodeRefProtocol: AnyObject {
    func ref() -> Int32
}

open class NodeRef:
    NodeRefProtocol
{
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    public required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public init(noPointer _: NoPointer) {
        pointer = nil
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_liveview_native_core_fn_clone_noderef(self.pointer, $0) }
    }

    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_liveview_native_core_fn_free_noderef(pointer, $0) }
    }

    open func ref() -> Int32 {
        return try! FfiConverterInt32.lift(try! rustCall {
            uniffi_liveview_native_core_fn_method_noderef_ref(self.uniffiClonePointer(), $0)
        })
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeNodeRef: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NodeRef

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NodeRef {
        return NodeRef(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NodeRef) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeRef {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NodeRef, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeRef_lift(_ pointer: UnsafeMutableRawPointer) throws -> NodeRef {
    return try FfiConverterTypeNodeRef.lift(pointer)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeRef_lower(_ value: NodeRef) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNodeRef.lower(value)
}

public struct Attribute {
    public var name: AttributeName
    public var value: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: AttributeName, value: String?) {
        self.name = name
        self.value = value
    }
}

extension Attribute: Equatable, Hashable {
    public static func == (lhs: Attribute, rhs: Attribute) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(value)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeAttribute: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Attribute {
        return
            try Attribute(
                name: FfiConverterTypeAttributeName.read(from: &buf),
                value: FfiConverterOptionString.read(from: &buf)
            )
    }

    public static func write(_ value: Attribute, into buf: inout [UInt8]) {
        FfiConverterTypeAttributeName.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.value, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeAttribute_lift(_ buf: RustBuffer) throws -> Attribute {
    return try FfiConverterTypeAttribute.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeAttribute_lower(_ value: Attribute) -> RustBuffer {
    return FfiConverterTypeAttribute.lower(value)
}

/**
 * Represents the fully-qualified name of an attribute
 */
public struct AttributeName {
    /**
     * This is used by svg attributes, e.g. `xlink-href`
     */
    public var namespace: String?
    public var name: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * This is used by svg attributes, e.g. `xlink-href`
         */ namespace: String?, name: String
    ) {
        self.namespace = namespace
        self.name = name
    }
}

extension AttributeName: Equatable, Hashable {
    public static func == (lhs: AttributeName, rhs: AttributeName) -> Bool {
        if lhs.namespace != rhs.namespace {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(namespace)
        hasher.combine(name)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeAttributeName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttributeName {
        return
            try AttributeName(
                namespace: FfiConverterOptionString.read(from: &buf),
                name: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: AttributeName, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.namespace, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeName_lift(_ buf: RustBuffer) throws -> AttributeName {
    return try FfiConverterTypeAttributeName.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeAttributeName_lower(_ value: AttributeName) -> RustBuffer {
    return FfiConverterTypeAttributeName.lower(value)
}

public struct ClientConnectOpts {
    /**
     * Params passed upon joining the live socket
     */
    public var joinParams: [String: Json]?
    /**
     * Headers passed while fetching the dead render
     */
    public var headers: [String: String]?
    public var method: Method?
    public var requestBody: Data?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Params passed upon joining the live socket
         */ joinParams: [String: Json]? = nil,
        /**
            * Headers passed while fetching the dead render
            */ headers: [String: String]? = nil, method: Method? = nil, requestBody: Data? = nil
    ) {
        self.joinParams = joinParams
        self.headers = headers
        self.method = method
        self.requestBody = requestBody
    }
}

extension ClientConnectOpts: Equatable, Hashable {
    public static func == (lhs: ClientConnectOpts, rhs: ClientConnectOpts) -> Bool {
        if lhs.joinParams != rhs.joinParams {
            return false
        }
        if lhs.headers != rhs.headers {
            return false
        }
        if lhs.method != rhs.method {
            return false
        }
        if lhs.requestBody != rhs.requestBody {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(joinParams)
        hasher.combine(headers)
        hasher.combine(method)
        hasher.combine(requestBody)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeClientConnectOpts: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientConnectOpts {
        return
            try ClientConnectOpts(
                joinParams: FfiConverterOptionDictionaryStringTypeJSON.read(from: &buf),
                headers: FfiConverterOptionDictionaryStringString.read(from: &buf),
                method: FfiConverterOptionTypeMethod.read(from: &buf),
                requestBody: FfiConverterOptionData.read(from: &buf)
            )
    }

    public static func write(_ value: ClientConnectOpts, into buf: inout [UInt8]) {
        FfiConverterOptionDictionaryStringTypeJSON.write(value.joinParams, into: &buf)
        FfiConverterOptionDictionaryStringString.write(value.headers, into: &buf)
        FfiConverterOptionTypeMethod.write(value.method, into: &buf)
        FfiConverterOptionData.write(value.requestBody, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeClientConnectOpts_lift(_ buf: RustBuffer) throws -> ClientConnectOpts {
    return try FfiConverterTypeClientConnectOpts.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeClientConnectOpts_lower(_ value: ClientConnectOpts) -> RustBuffer {
    return FfiConverterTypeClientConnectOpts.lower(value)
}

public struct ConnectOpts {
    public var headers: [String: String]?
    public var body: Data?
    public var method: Method?
    public var timeoutMs: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(headers: [String: String]? = nil, body: Data? = nil, method: Method? = nil, timeoutMs: UInt64 = UInt64(30000)) {
        self.headers = headers
        self.body = body
        self.method = method
        self.timeoutMs = timeoutMs
    }
}

extension ConnectOpts: Equatable, Hashable {
    public static func == (lhs: ConnectOpts, rhs: ConnectOpts) -> Bool {
        if lhs.headers != rhs.headers {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        if lhs.method != rhs.method {
            return false
        }
        if lhs.timeoutMs != rhs.timeoutMs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(headers)
        hasher.combine(body)
        hasher.combine(method)
        hasher.combine(timeoutMs)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeConnectOpts: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConnectOpts {
        return
            try ConnectOpts(
                headers: FfiConverterOptionDictionaryStringString.read(from: &buf),
                body: FfiConverterOptionData.read(from: &buf),
                method: FfiConverterOptionTypeMethod.read(from: &buf),
                timeoutMs: FfiConverterUInt64.read(from: &buf)
            )
    }

    public static func write(_ value: ConnectOpts, into buf: inout [UInt8]) {
        FfiConverterOptionDictionaryStringString.write(value.headers, into: &buf)
        FfiConverterOptionData.write(value.body, into: &buf)
        FfiConverterOptionTypeMethod.write(value.method, into: &buf)
        FfiConverterUInt64.write(value.timeoutMs, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectOpts_lift(_ buf: RustBuffer) throws -> ConnectOpts {
    return try FfiConverterTypeConnectOpts.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectOpts_lower(_ value: ConnectOpts) -> RustBuffer {
    return FfiConverterTypeConnectOpts.lower(value)
}

public struct ConnectionError {
    public var errorText: String
    public var errorCode: UInt16
    public var livereloadChannel: LiveChannel?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(errorText: String, errorCode: UInt16, livereloadChannel: LiveChannel?) {
        self.errorText = errorText
        self.errorCode = errorCode
        self.livereloadChannel = livereloadChannel
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeConnectionError: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConnectionError {
        return
            try ConnectionError(
                errorText: FfiConverterString.read(from: &buf),
                errorCode: FfiConverterUInt16.read(from: &buf),
                livereloadChannel: FfiConverterOptionTypeLiveChannel.read(from: &buf)
            )
    }

    public static func write(_ value: ConnectionError, into buf: inout [UInt8]) {
        FfiConverterString.write(value.errorText, into: &buf)
        FfiConverterUInt16.write(value.errorCode, into: &buf)
        FfiConverterOptionTypeLiveChannel.write(value.livereloadChannel, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectionError_lift(_ buf: RustBuffer) throws -> ConnectionError {
    return try FfiConverterTypeConnectionError.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeConnectionError_lower(_ value: ConnectionError) -> RustBuffer {
    return FfiConverterTypeConnectionError.lower(value)
}

/**
 * An `Element` is a typed node in a document, with the ability to carry attributes and contain other nodes.
 */
public struct Element {
    public var name: ElementName
    public var attributes: [Attribute]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: ElementName, attributes: [Attribute]) {
        self.name = name
        self.attributes = attributes
    }
}

extension Element: Equatable, Hashable {
    public static func == (lhs: Element, rhs: Element) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.attributes != rhs.attributes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(attributes)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeElement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Element {
        return
            try Element(
                name: FfiConverterTypeElementName.read(from: &buf),
                attributes: FfiConverterSequenceTypeAttribute.read(from: &buf)
            )
    }

    public static func write(_ value: Element, into buf: inout [UInt8]) {
        FfiConverterTypeElementName.write(value.name, into: &buf)
        FfiConverterSequenceTypeAttribute.write(value.attributes, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeElement_lift(_ buf: RustBuffer) throws -> Element {
    return try FfiConverterTypeElement.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeElement_lower(_ value: Element) -> RustBuffer {
    return FfiConverterTypeElement.lower(value)
}

/**
 * Represents the fully-qualified name of an element
 */
public struct ElementName {
    public var namespace: String?
    public var name: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(namespace: String?, name: String) {
        self.namespace = namespace
        self.name = name
    }
}

extension ElementName: Equatable, Hashable {
    public static func == (lhs: ElementName, rhs: ElementName) -> Bool {
        if lhs.namespace != rhs.namespace {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(namespace)
        hasher.combine(name)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeElementName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ElementName {
        return
            try ElementName(
                namespace: FfiConverterOptionString.read(from: &buf),
                name: FfiConverterString.read(from: &buf)
            )
    }

    public static func write(_ value: ElementName, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.namespace, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeElementName_lift(_ buf: RustBuffer) throws -> ElementName {
    return try FfiConverterTypeElementName.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeElementName_lower(_ value: ElementName) -> RustBuffer {
    return FfiConverterTypeElementName.lower(value)
}

public struct NavActionOptions {
    /**
     * Additional params to be passed upon joining the liveview channel.
     */
    public var joinParams: [String: Json]?
    /**
     * Ephemeral extra information to be pushed to the even handler.
     */
    public var extraEventInfo: Data?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Additional params to be passed upon joining the liveview channel.
         */ joinParams: [String: Json]? = nil,
        /**
            * Ephemeral extra information to be pushed to the even handler.
            */ extraEventInfo: Data? = nil
    ) {
        self.joinParams = joinParams
        self.extraEventInfo = extraEventInfo
    }
}

extension NavActionOptions: Equatable, Hashable {
    public static func == (lhs: NavActionOptions, rhs: NavActionOptions) -> Bool {
        if lhs.joinParams != rhs.joinParams {
            return false
        }
        if lhs.extraEventInfo != rhs.extraEventInfo {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(joinParams)
        hasher.combine(extraEventInfo)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeNavActionOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NavActionOptions {
        return
            try NavActionOptions(
                joinParams: FfiConverterOptionDictionaryStringTypeJSON.read(from: &buf),
                extraEventInfo: FfiConverterOptionData.read(from: &buf)
            )
    }

    public static func write(_ value: NavActionOptions, into buf: inout [UInt8]) {
        FfiConverterOptionDictionaryStringTypeJSON.write(value.joinParams, into: &buf)
        FfiConverterOptionData.write(value.extraEventInfo, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNavActionOptions_lift(_ buf: RustBuffer) throws -> NavActionOptions {
    return try FfiConverterTypeNavActionOptions.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNavActionOptions_lower(_ value: NavActionOptions) -> RustBuffer {
    return FfiConverterTypeNavActionOptions.lower(value)
}

/**
 * An event emitted when the user navigates between views.
 */
public struct NavEvent {
    /**
     * The type of event being emitted.
     */
    public var event: NavEventType
    /**
     * True if from and to point to the same path.
     */
    public var sameDocument: Bool
    /**
     * The previous location of the page, if there was one.
     */
    public var from: NavHistoryEntry?
    /**
     * Destination URL.
     */
    public var to: NavHistoryEntry
    /**
     * Additional user provided metadata handed to the event handler.
     */
    public var info: Data?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The type of event being emitted.
         */ event: NavEventType,
        /**
            * True if from and to point to the same path.
            */ sameDocument: Bool,
        /**
            * The previous location of the page, if there was one.
            */ from: NavHistoryEntry?,
        /**
            * Destination URL.
            */ to: NavHistoryEntry,
        /**
            * Additional user provided metadata handed to the event handler.
            */ info: Data?
    ) {
        self.event = event
        self.sameDocument = sameDocument
        self.from = from
        self.to = to
        self.info = info
    }
}

extension NavEvent: Equatable, Hashable {
    public static func == (lhs: NavEvent, rhs: NavEvent) -> Bool {
        if lhs.event != rhs.event {
            return false
        }
        if lhs.sameDocument != rhs.sameDocument {
            return false
        }
        if lhs.from != rhs.from {
            return false
        }
        if lhs.to != rhs.to {
            return false
        }
        if lhs.info != rhs.info {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(event)
        hasher.combine(sameDocument)
        hasher.combine(from)
        hasher.combine(to)
        hasher.combine(info)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeNavEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NavEvent {
        return
            try NavEvent(
                event: FfiConverterTypeNavEventType.read(from: &buf),
                sameDocument: FfiConverterBool.read(from: &buf),
                from: FfiConverterOptionTypeNavHistoryEntry.read(from: &buf),
                to: FfiConverterTypeNavHistoryEntry.read(from: &buf),
                info: FfiConverterOptionData.read(from: &buf)
            )
    }

    public static func write(_ value: NavEvent, into buf: inout [UInt8]) {
        FfiConverterTypeNavEventType.write(value.event, into: &buf)
        FfiConverterBool.write(value.sameDocument, into: &buf)
        FfiConverterOptionTypeNavHistoryEntry.write(value.from, into: &buf)
        FfiConverterTypeNavHistoryEntry.write(value.to, into: &buf)
        FfiConverterOptionData.write(value.info, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNavEvent_lift(_ buf: RustBuffer) throws -> NavEvent {
    return try FfiConverterTypeNavEvent.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNavEvent_lower(_ value: NavEvent) -> RustBuffer {
    return FfiConverterTypeNavEvent.lower(value)
}

public struct NavHistoryEntry {
    /**
     * The target url.
     */
    public var url: String
    /**
     * Unique id for this piece of nav entry state.
     */
    public var id: UInt64
    /**
     * state passed in by the user, to be passed in to the navigation event callback.
     */
    public var state: Data?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The target url.
         */ url: String,
        /**
            * Unique id for this piece of nav entry state.
            */ id: UInt64,
        /**
            * state passed in by the user, to be passed in to the navigation event callback.
            */ state: Data?
    ) {
        self.url = url
        self.id = id
        self.state = state
    }
}

extension NavHistoryEntry: Equatable, Hashable {
    public static func == (lhs: NavHistoryEntry, rhs: NavHistoryEntry) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.id != rhs.id {
            return false
        }
        if lhs.state != rhs.state {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(id)
        hasher.combine(state)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeNavHistoryEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NavHistoryEntry {
        return
            try NavHistoryEntry(
                url: FfiConverterString.read(from: &buf),
                id: FfiConverterUInt64.read(from: &buf),
                state: FfiConverterOptionData.read(from: &buf)
            )
    }

    public static func write(_ value: NavHistoryEntry, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterUInt64.write(value.id, into: &buf)
        FfiConverterOptionData.write(value.state, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNavHistoryEntry_lift(_ buf: RustBuffer) throws -> NavHistoryEntry {
    return try FfiConverterTypeNavHistoryEntry.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNavHistoryEntry_lower(_ value: NavHistoryEntry) -> RustBuffer {
    return FfiConverterTypeNavHistoryEntry.lower(value)
}

/**
 * Options for calls to [NavCtx::navigate]
 */
public struct NavOptions {
    /**
     * Additional params to be passed upon joining the liveview channel.
     */
    public var joinParams: [String: Json]?
    /**
     * see [NavAction], defaults to [NavAction::Push].
     */
    public var action: NavAction?
    /**
     * Ephemeral extra information to be pushed to the even handler.
     */
    public var extraEventInfo: Data?
    /**
     * Persistent state, intended to be deserialized for user specific purposes when
     * revisiting a given view.
     */
    public var state: Data?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Additional params to be passed upon joining the liveview channel.
         */ joinParams: [String: Json]? = nil,
        /**
            * see [NavAction], defaults to [NavAction::Push].
            */ action: NavAction? = nil,
        /**
            * Ephemeral extra information to be pushed to the even handler.
            */ extraEventInfo: Data? = nil,
        /**
            * Persistent state, intended to be deserialized for user specific purposes when
            * revisiting a given view.
            */ state: Data? = nil
    ) {
        self.joinParams = joinParams
        self.action = action
        self.extraEventInfo = extraEventInfo
        self.state = state
    }
}

extension NavOptions: Equatable, Hashable {
    public static func == (lhs: NavOptions, rhs: NavOptions) -> Bool {
        if lhs.joinParams != rhs.joinParams {
            return false
        }
        if lhs.action != rhs.action {
            return false
        }
        if lhs.extraEventInfo != rhs.extraEventInfo {
            return false
        }
        if lhs.state != rhs.state {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(joinParams)
        hasher.combine(action)
        hasher.combine(extraEventInfo)
        hasher.combine(state)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeNavOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NavOptions {
        return
            try NavOptions(
                joinParams: FfiConverterOptionDictionaryStringTypeJSON.read(from: &buf),
                action: FfiConverterOptionTypeNavAction.read(from: &buf),
                extraEventInfo: FfiConverterOptionData.read(from: &buf),
                state: FfiConverterOptionData.read(from: &buf)
            )
    }

    public static func write(_ value: NavOptions, into buf: inout [UInt8]) {
        FfiConverterOptionDictionaryStringTypeJSON.write(value.joinParams, into: &buf)
        FfiConverterOptionTypeNavAction.write(value.action, into: &buf)
        FfiConverterOptionData.write(value.extraEventInfo, into: &buf)
        FfiConverterOptionData.write(value.state, into: &buf)
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNavOptions_lift(_ buf: RustBuffer) throws -> NavOptions {
    return try FfiConverterTypeNavOptions.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNavOptions_lower(_ value: NavOptions) -> RustBuffer {
    return FfiConverterTypeNavOptions.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ChangeType {
    case change
    case add
    case remove
    case replace
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeChangeType: FfiConverterRustBuffer {
    typealias SwiftType = ChangeType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChangeType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .change

        case 2: return .add

        case 3: return .remove

        case 4: return .replace

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ChangeType, into buf: inout [UInt8]) {
        switch value {
        case .change:
            writeInt(&buf, Int32(1))

        case .add:
            writeInt(&buf, Int32(2))

        case .remove:
            writeInt(&buf, Int32(3))

        case .replace:
            writeInt(&buf, Int32(4))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeChangeType_lift(_ buf: RustBuffer) throws -> ChangeType {
    return try FfiConverterTypeChangeType.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeChangeType_lower(_ value: ChangeType) -> RustBuffer {
    return FfiConverterTypeChangeType.lower(value)
}

extension ChangeType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ControlFlow {
    case exitOk
    case exitErr(String
    )
    case continueListening
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeControlFlow: FfiConverterRustBuffer {
    typealias SwiftType = ControlFlow

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ControlFlow {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .exitOk

        case 2: return try .exitErr(FfiConverterString.read(from: &buf)
            )

        case 3: return .continueListening

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ControlFlow, into buf: inout [UInt8]) {
        switch value {
        case .exitOk:
            writeInt(&buf, Int32(1))

        case let .exitErr(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)

        case .continueListening:
            writeInt(&buf, Int32(3))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeControlFlow_lift(_ buf: RustBuffer) throws -> ControlFlow {
    return try FfiConverterTypeControlFlow.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeControlFlow_lower(_ value: ControlFlow) -> RustBuffer {
    return FfiConverterTypeControlFlow.lower(value)
}

extension ControlFlow: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum EventType {
    case changed
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeEventType: FfiConverterRustBuffer {
    typealias SwiftType = EventType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .changed

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EventType, into buf: inout [UInt8]) {
        switch value {
        case .changed:
            writeInt(&buf, Int32(1))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeEventType_lift(_ buf: RustBuffer) throws -> EventType {
    return try FfiConverterTypeEventType.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeEventType_lower(_ value: EventType) -> RustBuffer {
    return FfiConverterTypeEventType.lower(value)
}

extension EventType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * User emitted response from [NavEventHandler::handle_event].
 * Determines whether or not the default navigation action is taken.
 */

public enum HandlerResponse {
    /**
     * Return this to proceed as normal.
     */
    case `default`
    /**
     * Return this to cancel the navigation before it occurs.
     */
    case preventDefault
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeHandlerResponse: FfiConverterRustBuffer {
    typealias SwiftType = HandlerResponse

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HandlerResponse {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .default

        case 2: return .preventDefault

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HandlerResponse, into buf: inout [UInt8]) {
        switch value {
        case .default:
            writeInt(&buf, Int32(1))

        case .preventDefault:
            writeInt(&buf, Int32(2))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeHandlerResponse_lift(_ buf: RustBuffer) throws -> HandlerResponse {
    return try FfiConverterTypeHandlerResponse.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeHandlerResponse_lower(_ value: HandlerResponse) -> RustBuffer {
    return FfiConverterTypeHandlerResponse.lower(value)
}

extension HandlerResponse: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LiveChannelStatus {
    /**
     * [Channel] is waiting for the [Socket](crate::Socket) to
     * [Socket::connect](crate::Socket::connect) or automatically reconnect.
     */
    case waitingForSocketToConnect
    /**
     * [Socket::status](crate::Socket::status) is
     * [SocketStatus::Connected](crate::SocketStatus::Connected) and [Channel] is waiting for
     * [Channel::join] to be called.
     */
    case waitingToJoin
    /**
     * [Channel::join] was called and awaiting response from server.
     */
    case joining
    /**
     * [Channel::join] was called previously, but the [Socket](crate::Socket) was disconnected and
     * reconnected.
     */
    case waitingToRejoin
    /**
     * [Channel::join] was called and the server responded that the [Channel::topic] was joined
     * using [Channel::payload].
     */
    case joined
    /**
     * [Channel::leave] was called and awaiting response from server.
     */
    case leaving
    /**
     * [Channel::leave] was called and the server responded that the [Channel::topic] was left.
     */
    case left
    /**
     * [Channel::shutdown] was called, but the async task hasn't exited yet.
     */
    case shuttingDown
    /**
     * The async task has exited.
     */
    case shutDown
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLiveChannelStatus: FfiConverterRustBuffer {
    typealias SwiftType = LiveChannelStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiveChannelStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .waitingForSocketToConnect

        case 2: return .waitingToJoin

        case 3: return .joining

        case 4: return .waitingToRejoin

        case 5: return .joined

        case 6: return .leaving

        case 7: return .left

        case 8: return .shuttingDown

        case 9: return .shutDown

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LiveChannelStatus, into buf: inout [UInt8]) {
        switch value {
        case .waitingForSocketToConnect:
            writeInt(&buf, Int32(1))

        case .waitingToJoin:
            writeInt(&buf, Int32(2))

        case .joining:
            writeInt(&buf, Int32(3))

        case .waitingToRejoin:
            writeInt(&buf, Int32(4))

        case .joined:
            writeInt(&buf, Int32(5))

        case .leaving:
            writeInt(&buf, Int32(6))

        case .left:
            writeInt(&buf, Int32(7))

        case .shuttingDown:
            writeInt(&buf, Int32(8))

        case .shutDown:
            writeInt(&buf, Int32(9))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveChannelStatus_lift(_ buf: RustBuffer) throws -> LiveChannelStatus {
    return try FfiConverterTypeLiveChannelStatus.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveChannelStatus_lower(_ value: LiveChannelStatus) -> RustBuffer {
    return FfiConverterTypeLiveChannelStatus.lower(value)
}

extension LiveChannelStatus: Equatable, Hashable {}

public enum LiveSocketError {
    case NavigationError(error: String
    )
    case ClientNotConnected
    case JoinPanic
    case Call(error: String
    )
    case Cast(error: String
    )
    case WouldLock
    case FormData(error: String
    )
    case LockPoisoned
    case DisconnectionError
    case NavigationImpossible
    case PayloadNotJson
    case MimeType(error: String
    )
    case InvalidHeader(error: String
    )
    case InvalidMethod(error: String
    )
    case JoinRejection(error: Payload
    )
    case Phoenix(error: String
    )
    case Request(error: String
    )
    case Parse(error: ParseError
    )
    case JsonDeserialization(error: String
    )
    case ChannelStatusUserError(error: String
    )
    case CsrfTokenMissing
    case PhoenixIdMissing
    case ConnectionError(ConnectionError
    )
    case PhoenixSessionMissing
    case PhoenixStaticMissing
    case PhoenixMainMissing
    case NoHostInUrl
    case NoUploadToken
    case NoLiveReloadUrl
    case SchemeNotSupported(scheme: String
    )
    case Upload(error: UploadError
    )
    case NoDocumentInJoinPayload
    case DocumentMerge(error: MergeError
    )
    case DocumentRender(error: RenderError
    )
    case NoInputRefInDocument
    case Serde(error: String
    )
    case Events(error: String
    )
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLiveSocketError: FfiConverterRustBuffer {
    typealias SwiftType = LiveSocketError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiveSocketError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .NavigationError(
                error: FfiConverterString.read(from: &buf)
            )
        case 2: return .ClientNotConnected
        case 3: return .JoinPanic
        case 4: return try .Call(
                error: FfiConverterString.read(from: &buf)
            )
        case 5: return try .Cast(
                error: FfiConverterString.read(from: &buf)
            )
        case 6: return .WouldLock
        case 7: return try .FormData(
                error: FfiConverterString.read(from: &buf)
            )
        case 8: return .LockPoisoned
        case 9: return .DisconnectionError
        case 10: return .NavigationImpossible
        case 11: return .PayloadNotJson
        case 12: return try .MimeType(
                error: FfiConverterString.read(from: &buf)
            )
        case 13: return try .InvalidHeader(
                error: FfiConverterString.read(from: &buf)
            )
        case 14: return try .InvalidMethod(
                error: FfiConverterString.read(from: &buf)
            )
        case 15: return try .JoinRejection(
                error: FfiConverterTypePayload.read(from: &buf)
            )
        case 16: return try .Phoenix(
                error: FfiConverterString.read(from: &buf)
            )
        case 17: return try .Request(
                error: FfiConverterString.read(from: &buf)
            )
        case 18: return try .Parse(
                error: FfiConverterTypeParseError.read(from: &buf)
            )
        case 19: return try .JsonDeserialization(
                error: FfiConverterString.read(from: &buf)
            )
        case 20: return try .ChannelStatusUserError(
                error: FfiConverterString.read(from: &buf)
            )
        case 21: return .CsrfTokenMissing
        case 22: return .PhoenixIdMissing
        case 23: return try .ConnectionError(
                FfiConverterTypeConnectionError.read(from: &buf)
            )
        case 24: return .PhoenixSessionMissing
        case 25: return .PhoenixStaticMissing
        case 26: return .PhoenixMainMissing
        case 27: return .NoHostInUrl
        case 28: return .NoUploadToken
        case 29: return .NoLiveReloadUrl
        case 30: return try .SchemeNotSupported(
                scheme: FfiConverterString.read(from: &buf)
            )
        case 31: return try .Upload(
                error: FfiConverterTypeUploadError.read(from: &buf)
            )
        case 32: return .NoDocumentInJoinPayload
        case 33: return try .DocumentMerge(
                error: FfiConverterTypeMergeError.read(from: &buf)
            )
        case 34: return try .DocumentRender(
                error: FfiConverterTypeRenderError.read(from: &buf)
            )
        case 35: return .NoInputRefInDocument
        case 36: return try .Serde(
                error: FfiConverterString.read(from: &buf)
            )
        case 37: return try .Events(
                error: FfiConverterString.read(from: &buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LiveSocketError, into buf: inout [UInt8]) {
        switch value {
        case let .NavigationError(error):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(error, into: &buf)

        case .ClientNotConnected:
            writeInt(&buf, Int32(2))

        case .JoinPanic:
            writeInt(&buf, Int32(3))

        case let .Call(error):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(error, into: &buf)

        case let .Cast(error):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(error, into: &buf)

        case .WouldLock:
            writeInt(&buf, Int32(6))

        case let .FormData(error):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(error, into: &buf)

        case .LockPoisoned:
            writeInt(&buf, Int32(8))

        case .DisconnectionError:
            writeInt(&buf, Int32(9))

        case .NavigationImpossible:
            writeInt(&buf, Int32(10))

        case .PayloadNotJson:
            writeInt(&buf, Int32(11))

        case let .MimeType(error):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(error, into: &buf)

        case let .InvalidHeader(error):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(error, into: &buf)

        case let .InvalidMethod(error):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(error, into: &buf)

        case let .JoinRejection(error):
            writeInt(&buf, Int32(15))
            FfiConverterTypePayload.write(error, into: &buf)

        case let .Phoenix(error):
            writeInt(&buf, Int32(16))
            FfiConverterString.write(error, into: &buf)

        case let .Request(error):
            writeInt(&buf, Int32(17))
            FfiConverterString.write(error, into: &buf)

        case let .Parse(error):
            writeInt(&buf, Int32(18))
            FfiConverterTypeParseError.write(error, into: &buf)

        case let .JsonDeserialization(error):
            writeInt(&buf, Int32(19))
            FfiConverterString.write(error, into: &buf)

        case let .ChannelStatusUserError(error):
            writeInt(&buf, Int32(20))
            FfiConverterString.write(error, into: &buf)

        case .CsrfTokenMissing:
            writeInt(&buf, Int32(21))

        case .PhoenixIdMissing:
            writeInt(&buf, Int32(22))

        case let .ConnectionError(v1):
            writeInt(&buf, Int32(23))
            FfiConverterTypeConnectionError.write(v1, into: &buf)

        case .PhoenixSessionMissing:
            writeInt(&buf, Int32(24))

        case .PhoenixStaticMissing:
            writeInt(&buf, Int32(25))

        case .PhoenixMainMissing:
            writeInt(&buf, Int32(26))

        case .NoHostInUrl:
            writeInt(&buf, Int32(27))

        case .NoUploadToken:
            writeInt(&buf, Int32(28))

        case .NoLiveReloadUrl:
            writeInt(&buf, Int32(29))

        case let .SchemeNotSupported(scheme):
            writeInt(&buf, Int32(30))
            FfiConverterString.write(scheme, into: &buf)

        case let .Upload(error):
            writeInt(&buf, Int32(31))
            FfiConverterTypeUploadError.write(error, into: &buf)

        case .NoDocumentInJoinPayload:
            writeInt(&buf, Int32(32))

        case let .DocumentMerge(error):
            writeInt(&buf, Int32(33))
            FfiConverterTypeMergeError.write(error, into: &buf)

        case let .DocumentRender(error):
            writeInt(&buf, Int32(34))
            FfiConverterTypeRenderError.write(error, into: &buf)

        case .NoInputRefInDocument:
            writeInt(&buf, Int32(35))

        case let .Serde(error):
            writeInt(&buf, Int32(36))
            FfiConverterString.write(error, into: &buf)

        case let .Events(error):
            writeInt(&buf, Int32(37))
            FfiConverterString.write(error, into: &buf)
        }
    }
}

extension LiveSocketError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LiveViewClientStatus {
    case disconnected
    case connecting
    case reconnecting
    case connected(channelStatus: MainChannelStatus
    )
    case error(error: LiveSocketError
    )
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLiveViewClientStatus: FfiConverterRustBuffer {
    typealias SwiftType = LiveViewClientStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiveViewClientStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .disconnected

        case 2: return .connecting

        case 3: return .reconnecting

        case 4: return try .connected(channelStatus: FfiConverterTypeMainChannelStatus.read(from: &buf)
            )

        case 5: return try .error(error: FfiConverterTypeLiveSocketError.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LiveViewClientStatus, into buf: inout [UInt8]) {
        switch value {
        case .disconnected:
            writeInt(&buf, Int32(1))

        case .connecting:
            writeInt(&buf, Int32(2))

        case .reconnecting:
            writeInt(&buf, Int32(3))

        case let .connected(channelStatus):
            writeInt(&buf, Int32(4))
            FfiConverterTypeMainChannelStatus.write(channelStatus, into: &buf)

        case let .error(error):
            writeInt(&buf, Int32(5))
            FfiConverterTypeLiveSocketError.write(error, into: &buf)
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveViewClientStatus_lift(_ buf: RustBuffer) throws -> LiveViewClientStatus {
    return try FfiConverterTypeLiveViewClientStatus.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveViewClientStatus_lower(_ value: LiveViewClientStatus) -> RustBuffer {
    return FfiConverterTypeLiveViewClientStatus.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LogLevel {
    case trace
    case debug
    case info
    case warn
    case error
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = LogLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .trace

        case 2: return .debug

        case 3: return .info

        case 4: return .warn

        case 5: return .error

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogLevel, into buf: inout [UInt8]) {
        switch value {
        case .trace:
            writeInt(&buf, Int32(1))

        case .debug:
            writeInt(&buf, Int32(2))

        case .info:
            writeInt(&buf, Int32(3))

        case .warn:
            writeInt(&buf, Int32(4))

        case .error:
            writeInt(&buf, Int32(5))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLogLevel_lift(_ buf: RustBuffer) throws -> LogLevel {
    return try FfiConverterTypeLogLevel.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeLogLevel_lower(_ value: LogLevel) -> RustBuffer {
    return FfiConverterTypeLogLevel.lower(value)
}

extension LogLevel: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MainChannelStatus {
    case connected(document: Document
    )
    case reconnecting
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeMainChannelStatus: FfiConverterRustBuffer {
    typealias SwiftType = MainChannelStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MainChannelStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .connected(document: FfiConverterTypeDocument.read(from: &buf)
            )

        case 2: return .reconnecting

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MainChannelStatus, into buf: inout [UInt8]) {
        switch value {
        case let .connected(document):
            writeInt(&buf, Int32(1))
            FfiConverterTypeDocument.write(document, into: &buf)

        case .reconnecting:
            writeInt(&buf, Int32(2))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeMainChannelStatus_lift(_ buf: RustBuffer) throws -> MainChannelStatus {
    return try FfiConverterTypeMainChannelStatus.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeMainChannelStatus_lower(_ value: MainChannelStatus) -> RustBuffer {
    return FfiConverterTypeMainChannelStatus.lower(value)
}

public enum MergeError {
    case UnresolvedComponent
    case MissingComponent(Int32
    )
    case FragmentTypeMismatch
    case CreateComponentFromUpdate
    case CreateChildFromUpdateFragment
    case AddChildToExisting
    case StreamIdMismatch
    case Stream(error: StreamConversionError
    )
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeMergeError: FfiConverterRustBuffer {
    typealias SwiftType = MergeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MergeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .UnresolvedComponent
        case 2: return try .MissingComponent(
                FfiConverterInt32.read(from: &buf)
            )
        case 3: return .FragmentTypeMismatch
        case 4: return .CreateComponentFromUpdate
        case 5: return .CreateChildFromUpdateFragment
        case 6: return .AddChildToExisting
        case 7: return .StreamIdMismatch
        case 8: return try .Stream(
                error: FfiConverterTypeStreamConversionError.read(from: &buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MergeError, into buf: inout [UInt8]) {
        switch value {
        case .UnresolvedComponent:
            writeInt(&buf, Int32(1))

        case let .MissingComponent(v1):
            writeInt(&buf, Int32(2))
            FfiConverterInt32.write(v1, into: &buf)

        case .FragmentTypeMismatch:
            writeInt(&buf, Int32(3))

        case .CreateComponentFromUpdate:
            writeInt(&buf, Int32(4))

        case .CreateChildFromUpdateFragment:
            writeInt(&buf, Int32(5))

        case .AddChildToExisting:
            writeInt(&buf, Int32(6))

        case .StreamIdMismatch:
            writeInt(&buf, Int32(7))

        case let .Stream(error):
            writeInt(&buf, Int32(8))
            FfiConverterTypeStreamConversionError.write(error, into: &buf)
        }
    }
}

extension MergeError: Equatable, Hashable {}

extension MergeError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Method: UInt8 {
    case get = 0
    case options = 1
    case post = 2
    case put = 3
    case delete = 4
    case head = 5
    case trace = 6
    case connect = 7
    case patch = 8
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeMethod: FfiConverterRustBuffer {
    typealias SwiftType = Method

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Method {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .get

        case 2: return .options

        case 3: return .post

        case 4: return .put

        case 5: return .delete

        case 6: return .head

        case 7: return .trace

        case 8: return .connect

        case 9: return .patch

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Method, into buf: inout [UInt8]) {
        switch value {
        case .get:
            writeInt(&buf, Int32(1))

        case .options:
            writeInt(&buf, Int32(2))

        case .post:
            writeInt(&buf, Int32(3))

        case .put:
            writeInt(&buf, Int32(4))

        case .delete:
            writeInt(&buf, Int32(5))

        case .head:
            writeInt(&buf, Int32(6))

        case .trace:
            writeInt(&buf, Int32(7))

        case .connect:
            writeInt(&buf, Int32(8))

        case .patch:
            writeInt(&buf, Int32(9))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeMethod_lift(_ buf: RustBuffer) throws -> Method {
    return try FfiConverterTypeMethod.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeMethod_lower(_ value: Method) -> RustBuffer {
    return FfiConverterTypeMethod.lower(value)
}

extension Method: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An action taken with respect to the history stack
 * when [NavCtx::navigate] is executed. defaults to
 * Push behavior.
 */

public enum NavAction {
    /**
     * Push the navigation event onto the history stack.
     */
    case push
    /**
     * Replace the current top of the history stack with this navigation event.
     */
    case replace
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeNavAction: FfiConverterRustBuffer {
    typealias SwiftType = NavAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NavAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .push

        case 2: return .replace

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NavAction, into buf: inout [UInt8]) {
        switch value {
        case .push:
            writeInt(&buf, Int32(1))

        case .replace:
            writeInt(&buf, Int32(2))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNavAction_lift(_ buf: RustBuffer) throws -> NavAction {
    return try FfiConverterTypeNavAction.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNavAction_lower(_ value: NavAction) -> RustBuffer {
    return FfiConverterTypeNavAction.lower(value)
}

extension NavAction: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NavEventType {
    /**
     * Changing the url of the object on the top of the stack
     */
    case patch
    /**
     * Pushing a new event onto the history stack
     */
    case push
    /**
     * Replacing the most recent event on the history stack
     */
    case replace
    /**
     * Reloading the view in place
     */
    case reload
    /**
     * Skipping multiple items on the history stack, leaving them in tact.
     */
    case traverse
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeNavEventType: FfiConverterRustBuffer {
    typealias SwiftType = NavEventType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NavEventType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .patch

        case 2: return .push

        case 3: return .replace

        case 4: return .reload

        case 5: return .traverse

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NavEventType, into buf: inout [UInt8]) {
        switch value {
        case .patch:
            writeInt(&buf, Int32(1))

        case .push:
            writeInt(&buf, Int32(2))

        case .replace:
            writeInt(&buf, Int32(3))

        case .reload:
            writeInt(&buf, Int32(4))

        case .traverse:
            writeInt(&buf, Int32(5))
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNavEventType_lift(_ buf: RustBuffer) throws -> NavEventType {
    return try FfiConverterTypeNavEventType.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNavEventType_lower(_ value: NavEventType) -> RustBuffer {
    return FfiConverterTypeNavEventType.lower(value)
}

extension NavEventType: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * This enum represents the valid node types of a `Document` tree
 */

public enum NodeData {
    /**
     * A marker node that indicates the root of a document
     *
     * A document may only have a single root, and it has no attributes
     */
    case root
    /**
     * A typed node that can carry attributes and may contain other nodes
     */
    case nodeElement(element: Element
    )
    /**
     * A leaf node is an untyped node, typically text, and does not have any attributes or children
     */
    case leaf(value: String
    )
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeNodeData: FfiConverterRustBuffer {
    typealias SwiftType = NodeData

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeData {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .root

        case 2: return try .nodeElement(element: FfiConverterTypeElement.read(from: &buf)
            )

        case 3: return try .leaf(value: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NodeData, into buf: inout [UInt8]) {
        switch value {
        case .root:
            writeInt(&buf, Int32(1))

        case let .nodeElement(element):
            writeInt(&buf, Int32(2))
            FfiConverterTypeElement.write(element, into: &buf)

        case let .leaf(value):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(value, into: &buf)
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeData_lift(_ buf: RustBuffer) throws -> NodeData {
    return try FfiConverterTypeNodeData.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypeNodeData_lower(_ value: NodeData) -> RustBuffer {
    return FfiConverterTypeNodeData.lower(value)
}

extension NodeData: Equatable, Hashable {}

/**
 * Represents the possible types of failure that can occur while parsing a `Document`
 */
public enum ParseError {
    case Reader(message: String)

    case Tokenizer(message: String)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeParseError: FfiConverterRustBuffer {
    typealias SwiftType = ParseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .Reader(
                message: FfiConverterString.read(from: &buf)
            )

        case 2: return try .Tokenizer(
                message: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ParseError, into buf: inout [UInt8]) {
        switch value {
        case .Reader(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(1))
        case .Tokenizer(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(2))
        }
    }
}

extension ParseError: Equatable, Hashable {}

extension ParseError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents one of our supported platforms.
 */

public enum Platform {
    case swiftui
    case jetpack
    case other(String
    )
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypePlatform: FfiConverterRustBuffer {
    typealias SwiftType = Platform

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Platform {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .swiftui

        case 2: return .jetpack

        case 3: return try .other(FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Platform, into buf: inout [UInt8]) {
        switch value {
        case .swiftui:
            writeInt(&buf, Int32(1))

        case .jetpack:
            writeInt(&buf, Int32(2))

        case let .other(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePlatform_lift(_ buf: RustBuffer) throws -> Platform {
    return try FfiConverterTypePlatform.lift(buf)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public func FfiConverterTypePlatform_lower(_ value: Platform) -> RustBuffer {
    return FfiConverterTypePlatform.lower(value)
}

extension Platform: Equatable, Hashable {}

public enum RenderError {
    case NoComponents(message: String)

    case NoTemplates(message: String)

    case TemplateNotFound(message: String)

    case ComponentNotFound(message: String)

    case MergeError(message: String)

    case ChildNotFoundForTemplate(message: String)

    case ChildNotFoundForStatic(message: String)

    case CousinNotFound(message: String)

    case SerdeError(message: String)

    case ParseError(message: String)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeRenderError: FfiConverterRustBuffer {
    typealias SwiftType = RenderError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RenderError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .NoComponents(
                message: FfiConverterString.read(from: &buf)
            )

        case 2: return try .NoTemplates(
                message: FfiConverterString.read(from: &buf)
            )

        case 3: return try .TemplateNotFound(
                message: FfiConverterString.read(from: &buf)
            )

        case 4: return try .ComponentNotFound(
                message: FfiConverterString.read(from: &buf)
            )

        case 5: return try .MergeError(
                message: FfiConverterString.read(from: &buf)
            )

        case 6: return try .ChildNotFoundForTemplate(
                message: FfiConverterString.read(from: &buf)
            )

        case 7: return try .ChildNotFoundForStatic(
                message: FfiConverterString.read(from: &buf)
            )

        case 8: return try .CousinNotFound(
                message: FfiConverterString.read(from: &buf)
            )

        case 9: return try .SerdeError(
                message: FfiConverterString.read(from: &buf)
            )

        case 10: return try .ParseError(
                message: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RenderError, into buf: inout [UInt8]) {
        switch value {
        case .NoComponents(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(1))
        case .NoTemplates(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(2))
        case .TemplateNotFound(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(3))
        case .ComponentNotFound(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(4))
        case .MergeError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(5))
        case .ChildNotFoundForTemplate(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(6))
        case .ChildNotFoundForStatic(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(7))
        case .CousinNotFound(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(8))
        case .SerdeError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(9))
        case .ParseError(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(10))
        }
    }
}

extension RenderError: Equatable, Hashable {}

extension RenderError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

public enum StreamConversionError {
    case NoStreamId(message: String)
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeStreamConversionError: FfiConverterRustBuffer {
    typealias SwiftType = StreamConversionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StreamConversionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .NoStreamId(
                message: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StreamConversionError, into buf: inout [UInt8]) {
        switch value {
        case .NoStreamId(_ /* message is ignored*/ ):
            writeInt(&buf, Int32(1))
        }
    }
}

extension StreamConversionError: Equatable, Hashable {}

extension StreamConversionError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

public enum UploadError {
    case FileTooLarge
    case FileNotAccepted
    case Other(error: String
    )
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
public struct FfiConverterTypeUploadError: FfiConverterRustBuffer {
    typealias SwiftType = UploadError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UploadError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .FileTooLarge
        case 2: return .FileNotAccepted
        case 3: return try .Other(
                error: FfiConverterString.read(from: &buf)
            )
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UploadError, into buf: inout [UInt8]) {
        switch value {
        case .FileTooLarge:
            writeInt(&buf, Int32(1))

        case .FileNotAccepted:
            writeInt(&buf, Int32(2))

        case let .Other(error):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(error, into: &buf)
        }
    }
}

extension UploadError: Equatable, Hashable {}

extension UploadError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

/**
 * Implements the change handling logic for inbound virtual dom
 * changes. Your logic for handling document patches should go here.
 */
public protocol DocumentChangeHandler: AnyObject {
    /**
     * This callback should implement your dom manipulation logic
     * after receiving patches from LVN.
     */
    func handleDocumentChange(_ changeType: ChangeType, _ nodeRef: NodeRef, _ nodeData: NodeData, _ parent: NodeRef?)
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceDocumentChangeHandler {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceDocumentChangeHandler = .init(
        handleDocumentChange: { (
            uniffiHandle: UInt64,
            changeType: RustBuffer,
            nodeRef: UnsafeMutableRawPointer,
            nodeData: RustBuffer,
            parent: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceDocumentChangeHandler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.handleDocumentChange(
                    FfiConverterTypeChangeType.lift(changeType),
                    FfiConverterTypeNodeRef.lift(nodeRef),
                    FfiConverterTypeNodeData.lift(nodeData),
                    FfiConverterOptionTypeNodeRef.lift(parent)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterCallbackInterfaceDocumentChangeHandler.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface DocumentChangeHandler: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitDocumentChangeHandler() {
    uniffi_liveview_native_core_fn_init_callback_vtable_documentchangehandler(&UniffiCallbackInterfaceDocumentChangeHandler.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private enum FfiConverterCallbackInterfaceDocumentChangeHandler {
    fileprivate static var handleMap = UniffiHandleMap<DocumentChangeHandler>()
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceDocumentChangeHandler: FfiConverter {
    typealias SwiftType = DocumentChangeHandler
    typealias FfiType = UInt64

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

public protocol NavEventHandler: AnyObject {
    /**
     * This callback instruments events that occur when your user navigates to a
     * new view. You can add serialized metadata to these events as a byte buffer
     * through the [NavOptions] object.
     */
    func handleEvent(_ event: NavEvent) -> HandlerResponse
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceNavEventHandler {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceNavEventHandler = .init(
        handleEvent: { (
            uniffiHandle: UInt64,
            event: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> HandlerResponse in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceNavEventHandler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.handleEvent(
                    FfiConverterTypeNavEvent.lift(event)
                )
            }

            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeHandlerResponse.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterCallbackInterfaceNavEventHandler.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface NavEventHandler: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitNavEventHandler() {
    uniffi_liveview_native_core_fn_init_callback_vtable_naveventhandler(&UniffiCallbackInterfaceNavEventHandler.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private enum FfiConverterCallbackInterfaceNavEventHandler {
    fileprivate static var handleMap = UniffiHandleMap<NavEventHandler>()
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceNavEventHandler: FfiConverter {
    typealias SwiftType = NavEventHandler
    typealias FfiType = UInt64

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

/**
 * Implement this if you need to instrument all replies and status
 * changes on the current live channel.
 */
public protocol NetworkEventHandler: AnyObject {
    /**
     * Whenever a server sent event or reply to a user
     * message is receiver the event payload is passed to this
     * callback. by default the client handles diff events and will
     * handle assets_change, live_patch, live_reload, etc, in the future
     */
    func onEvent(_ event: EventPayload)

    /**
     * Called when the view is reloaded, provides the new document.
     * This means that the previous livechannel has been dropped and
     * a new livechannel has been established
     *
     * The socket may be the same as the previous view if the navigation
     * API was used within the same livesession, if this is the case
     * `socket_is_new` will be false
     *
     * If the socket was reconnected for any reason `socket_is_new` will be true.
     */
    func onStatusChange(_ status: LiveViewClientStatus)
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceNetworkEventHandler {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceNetworkEventHandler = .init(
        onEvent: { (
            uniffiHandle: UInt64,
            event: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceNetworkEventHandler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.onEvent(
                    FfiConverterTypeEventPayload_lift(event)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onStatusChange: { (
            uniffiHandle: UInt64,
            status: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceNetworkEventHandler.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.onStatusChange(
                    FfiConverterTypeLiveViewClientStatus.lift(status)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterCallbackInterfaceNetworkEventHandler.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface NetworkEventHandler: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitNetworkEventHandler() {
    uniffi_liveview_native_core_fn_init_callback_vtable_networkeventhandler(&UniffiCallbackInterfaceNetworkEventHandler.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private enum FfiConverterCallbackInterfaceNetworkEventHandler {
    fileprivate static var handleMap = UniffiHandleMap<NetworkEventHandler>()
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceNetworkEventHandler: FfiConverter {
    typealias SwiftType = NetworkEventHandler
    typealias FfiType = UInt64

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

/**
 * Provides secure persistent storage for session data like cookies.
 * Implementations should handle platform-specific storage (e.g. NSUserDefaults on iOS)
 * and ensure data is stored securely as some of it may be session tokens.
 */
public protocol SecurePersistentStore: AnyObject {
    /**
     * Removes the entry for the given key
     */
    func removeEntry(_ key: String)

    /**
     * Gets the value for the given key, or None if not found
     */
    func get(_ key: String) -> Data?

    /**
     * Sets the value for the given key
     */
    func set(_ key: String, _ value: Data)
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceSecurePersistentStore {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceSecurePersistentStore = .init(
        removeEntry: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSecurePersistentStore.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.removeEntry(
                    FfiConverterString.lift(key)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        get: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Data? in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSecurePersistentStore.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.get(
                    FfiConverterString.lift(key)
                )
            }

            let writeReturn = { uniffiOutReturn.pointee = FfiConverterOptionData.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        set: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            value: RustBuffer,
            _: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSecurePersistentStore.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.set(
                    FfiConverterString.lift(key),
                    FfiConverterData.lift(value)
                )
            }

            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterCallbackInterfaceSecurePersistentStore.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface SecurePersistentStore: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitSecurePersistentStore() {
    uniffi_liveview_native_core_fn_init_callback_vtable_securepersistentstore(&UniffiCallbackInterfaceSecurePersistentStore.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private enum FfiConverterCallbackInterfaceSecurePersistentStore {
    fileprivate static var handleMap = UniffiHandleMap<SecurePersistentStore>()
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceSecurePersistentStore: FfiConverter {
    typealias SwiftType = SecurePersistentStore
    typealias FfiType = UInt64

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

public protocol SocketReconnectStrategy: AnyObject {
    func sleepDuration(_ attempt: UInt64) -> TimeInterval
}

// Put the implementation in a struct so we don't pollute the top-level namespace
private enum UniffiCallbackInterfaceSocketReconnectStrategy {
    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    static var vtable: UniffiVTableCallbackInterfaceSocketReconnectStrategy = .init(
        sleepDuration: { (
            uniffiHandle: UInt64,
            attempt: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> TimeInterval in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSocketReconnectStrategy.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.sleepDuration(
                    FfiConverterUInt64.lift(attempt)
                )
            }

            let writeReturn = { uniffiOutReturn.pointee = FfiConverterDuration.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) in
            let result = try? FfiConverterCallbackInterfaceSocketReconnectStrategy.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface SocketReconnectStrategy: handle missing in uniffiFree")
            }
        }
    )
}

private func uniffiCallbackInitSocketReconnectStrategy() {
    uniffi_liveview_native_core_fn_init_callback_vtable_socketreconnectstrategy(&UniffiCallbackInterfaceSocketReconnectStrategy.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private enum FfiConverterCallbackInterfaceSocketReconnectStrategy {
    fileprivate static var handleMap = UniffiHandleMap<SocketReconnectStrategy>()
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceSocketReconnectStrategy: FfiConverter {
    typealias SwiftType = SocketReconnectStrategy
    typealias FfiType = UInt64

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

    #if swift(>=5.8)
        @_documentation(visibility: private)
    #endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionData: FfiConverterRustBuffer {
    typealias SwiftType = Data?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeLiveChannel: FfiConverterRustBuffer {
    typealias SwiftType = LiveChannel?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLiveChannel.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLiveChannel.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeNodeRef: FfiConverterRustBuffer {
    typealias SwiftType = NodeRef?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNodeRef.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNodeRef.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeAttribute: FfiConverterRustBuffer {
    typealias SwiftType = Attribute?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAttribute.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAttribute.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeConnectOpts: FfiConverterRustBuffer {
    typealias SwiftType = ConnectOpts?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeConnectOpts.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeConnectOpts.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeNavHistoryEntry: FfiConverterRustBuffer {
    typealias SwiftType = NavHistoryEntry?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNavHistoryEntry.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNavHistoryEntry.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeMethod: FfiConverterRustBuffer {
    typealias SwiftType = Method?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMethod.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMethod.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionTypeNavAction: FfiConverterRustBuffer {
    typealias SwiftType = NavAction?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNavAction.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNavAction.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionCallbackInterfaceSocketReconnectStrategy: FfiConverterRustBuffer {
    typealias SwiftType = SocketReconnectStrategy?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceSocketReconnectStrategy.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceSocketReconnectStrategy.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionDictionaryStringString: FfiConverterRustBuffer {
    typealias SwiftType = [String: String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterOptionDictionaryStringTypeJSON: FfiConverterRustBuffer {
    typealias SwiftType = [String: Json]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringTypeJSON.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringTypeJSON.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeLiveFile: FfiConverterRustBuffer {
    typealias SwiftType = [LiveFile]

    public static func write(_ value: [LiveFile], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLiveFile.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LiveFile] {
        let len: Int32 = try readInt(&buf)
        var seq = [LiveFile]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeLiveFile.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeNode: FfiConverterRustBuffer {
    typealias SwiftType = [Node]

    public static func write(_ value: [Node], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNode.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Node] {
        let len: Int32 = try readInt(&buf)
        var seq = [Node]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeNode.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeNodeRef: FfiConverterRustBuffer {
    typealias SwiftType = [NodeRef]

    public static func write(_ value: [NodeRef], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNodeRef.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NodeRef] {
        let len: Int32 = try readInt(&buf)
        var seq = [NodeRef]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeNodeRef.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeAttribute: FfiConverterRustBuffer {
    typealias SwiftType = [Attribute]

    public static func write(_ value: [Attribute], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAttribute.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Attribute] {
        let len: Int32 = try readInt(&buf)
        var seq = [Attribute]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAttribute.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterSequenceTypeNavHistoryEntry: FfiConverterRustBuffer {
    typealias SwiftType = [NavHistoryEntry]

    public static func write(_ value: [NavHistoryEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNavHistoryEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NavHistoryEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [NavHistoryEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeNavHistoryEntry.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterDictionaryStringSequenceString: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String]]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
private struct FfiConverterDictionaryStringTypeJSON: FfiConverterRustBuffer {
    public static func write(_ value: [String: Json], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeJSON.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Json] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Json]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeJSON.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

private let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

private func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> Void,
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> Void,
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
private func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}

/**
 * Stores a cookie for the duration of the application run.
 */
public func storeSessionCookie(_ cookie: String, _ url: String) throws { try rustCallWithError(FfiConverterTypeLiveSocketError.lift) {
    uniffi_liveview_native_core_fn_func_store_session_cookie(
        FfiConverterString.lower(cookie),
        FfiConverterString.lower(url), $0
    )
}
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}

// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_liveview_native_core_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if uniffi_liveview_native_core_checksum_func_store_session_cookie() != 31872 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_clientstatuses_current_status() != 20936 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_clientstatuses_next_status() != 29156 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_document_children() != 59121 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_document_get() != 61396 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_document_get_attributes() != 42016 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_document_get_node() != 62413 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_document_get_parent() != 49974 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_document_merge_fragment_json() != 40898 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_document_next_upload_id() != 52006 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_document_render() != 31975 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_document_root() != 55719 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_document_set_event_handler() != 18356 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livechannel_channel() != 14836 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livechannel_document() != 32827 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livechannel_get_phx_upload_id() != 54169 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livechannel_join_payload() != 65526 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livechannel_merge_diffs() != 47482 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livechannel_set_event_handler() != 41602 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livechannel_shutdown_parent_socket() != 12972 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livechannel_upload_file() != 60235 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livesocket_back() != 24754 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livesocket_can_go_back() != 20232 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livesocket_can_go_forward() != 26425 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livesocket_can_traverse_to() != 28194 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livesocket_cookies() != 22419 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livesocket_csrf_token() != 59377 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livesocket_current() != 56296 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livesocket_dead_render() != 35094 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livesocket_forward() != 33179 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livesocket_get_entries() != 26817 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livesocket_has_live_reload() != 3400 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livesocket_join_headers() != 52668 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livesocket_join_livereload_channel() != 34308 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livesocket_join_liveview_channel() != 15340 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livesocket_join_url() != 59997 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livesocket_navigate() != 30092 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livesocket_reload() != 49988 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livesocket_set_event_handler() != 47419 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livesocket_socket() != 14037 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livesocket_status() != 36253 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livesocket_style_urls() != 29200 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livesocket_timeout() != 63761 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_livesocket_traverse_to() != 61827 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_back() != 6816 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_call() != 16003 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_can_go_back() != 31726 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_can_go_forward() != 61443 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_can_traverse_to() != 28628 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_cast() != 62796 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_csrf_token() != 51828 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_current() != 38696 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_dead_render() != 7229 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_disconnect() != 32012 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_document() != 11087 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_forward() != 10776 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_get_entries() != 469 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_get_phx_upload_id() != 11628 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_join_payload() != 38878 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_join_url() != 3922 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_navigate() != 34419 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_post_form() != 33746 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_reconnect() != 28063 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_reload() != 33050 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_set_log_level() != 39975 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_shutdown() != 61713 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_status() != 1276 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_status_stream() != 64126 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_style_urls() != 17620 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_traverse_to() != 35176 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclient_upload_files() != 52769 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclientbuilder_connect() != 5883 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclientbuilder_dead_render_timeout() != 30412 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclientbuilder_format() != 13472 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclientbuilder_log_level() != 16690 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclientbuilder_set_dead_render_timeout_ms() != 34402 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclientbuilder_set_format() != 37361 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclientbuilder_set_live_channel_event_handler() != 28972 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclientbuilder_set_log_level() != 23626 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclientbuilder_set_navigation_handler() != 33390 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclientbuilder_set_patch_handler() != 14999 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclientbuilder_set_persistence_provider() != 57708 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclientbuilder_set_socket_reconnect_strategy() != 43087 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclientbuilder_set_websocket_timeout_ms() != 59603 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_liveviewclientbuilder_websocket_timeout() != 23857 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_node_attributes() != 60381 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_node_data() != 10189 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_node_display() != 36109 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_node_document() != 33196 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_node_get_attribute() != 29873 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_node_get_children() != 25833 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_node_get_depth_first_children() != 59594 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_node_node_id() != 8756 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_noderef_ref() != 32879 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_constructor_document_empty() != 49805 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_constructor_document_parse() != 495 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_constructor_document_parse_fragment_json() != 46839 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_constructor_livefile_new() != 43235 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_constructor_livesocket_connect() != 34491 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_constructor_livesocket_new() != 22915 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_constructor_liveviewclientbuilder_new() != 38076 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_constructor_node_new() != 23337 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_documentchangehandler_handle_document_change() != 35760 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_naveventhandler_handle_event() != 8593 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_networkeventhandler_on_event() != 7769 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_networkeventhandler_on_status_change() != 22780 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_securepersistentstore_remove_entry() != 59590 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_securepersistentstore_get() != 258 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_securepersistentstore_set() != 6297 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_liveview_native_core_checksum_method_socketreconnectstrategy_sleep_duration() != 63770 {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitDocumentChangeHandler()
    uniffiCallbackInitNavEventHandler()
    uniffiCallbackInitNetworkEventHandler()
    uniffiCallbackInitSecurePersistentStore()
    uniffiCallbackInitSocketReconnectStrategy()
    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all
