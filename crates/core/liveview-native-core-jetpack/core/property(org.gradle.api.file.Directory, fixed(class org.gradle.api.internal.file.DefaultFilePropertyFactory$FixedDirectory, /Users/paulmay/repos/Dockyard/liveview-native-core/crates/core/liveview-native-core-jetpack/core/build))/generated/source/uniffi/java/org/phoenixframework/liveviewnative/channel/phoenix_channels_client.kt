// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

@file:Suppress("NAME_SHADOWING")

package org.phoenixframework.liveviewnative.channel

// Common helper code.
//
// Ideally this would live in a separate .kt file where it can be unittested etc
// in isolation, and perhaps even published as a re-useable package.
//
// However, it's important that the details of how this helper code works (e.g. the
// way that different builtin types are passed across the FFI) exactly match what's
// expected by the Rust code on the other side of the interface. In practice right
// now that means coming from the exact some version of `uniffi` that was used to
// compile the Rust component. The easiest way to ensure this is to bundle the Kotlin
// helpers directly inline like we're doing here.

import com.sun.jna.Callback
import com.sun.jna.Library
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.Structure
import com.sun.jna.ptr.*
import kotlinx.coroutines.CancellableContinuation
import kotlinx.coroutines.suspendCancellableCoroutine
import java.net.URI
import java.net.URL
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.CharBuffer
import java.nio.charset.CodingErrorAction
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicLong
import kotlin.coroutines.resume

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

/**
 * @suppress
 */
@Structure.FieldOrder("capacity", "len", "data")
open class RustBuffer : Structure() {
    // Note: `capacity` and `len` are actually `ULong` values, but JVM only supports signed values.
    // When dealing with these fields, make sure to call `toULong()`.
    @JvmField var capacity: Long = 0

    @JvmField var len: Long = 0

    @JvmField var data: Pointer? = null

    class ByValue :
        RustBuffer(),
        Structure.ByValue

    class ByReference :
        RustBuffer(),
        Structure.ByReference

    internal fun setValue(other: RustBuffer) {
        capacity = other.capacity
        len = other.len
        data = other.data
    }

    companion object {
        internal fun alloc(size: ULong = 0UL) =
            uniffiRustCall { status ->
                // Note: need to convert the size to a `Long` value to make this work with JVM.
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rustbuffer_alloc(size.toLong(), status)
            }.also {
                if (it.data == null) {
                    throw RuntimeException("RustBuffer.alloc() returned null data pointer (size=$size)")
                }
            }

        internal fun create(
            capacity: ULong,
            len: ULong,
            data: Pointer?,
        ): RustBuffer.ByValue {
            var buf = RustBuffer.ByValue()
            buf.capacity = capacity.toLong()
            buf.len = len.toLong()
            buf.data = data
            return buf
        }

        internal fun free(buf: RustBuffer.ByValue) =
            uniffiRustCall { status ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rustbuffer_free(buf, status)
            }
    }

    @Suppress("TooGenericExceptionThrown")
    fun asByteBuffer() =
        this.data?.getByteBuffer(0, this.len.toLong())?.also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
}

/**
 * The equivalent of the `*mut RustBuffer` type.
 * Required for callbacks taking in an out pointer.
 *
 * Size is the sum of all values in the struct.
 *
 * @suppress
 */
class RustBufferByReference : ByReference(16) {
    /**
     * Set the pointed-to `RustBuffer` to the given value.
     */
    fun setValue(value: RustBuffer.ByValue) {
        // NOTE: The offsets are as they are in the C-like struct.
        val pointer = getPointer()
        pointer.setLong(0, value.capacity)
        pointer.setLong(8, value.len)
        pointer.setPointer(16, value.data)
    }

    /**
     * Get a `RustBuffer.ByValue` from this reference.
     */
    fun getValue(): RustBuffer.ByValue {
        val pointer = getPointer()
        val value = RustBuffer.ByValue()
        value.writeField("capacity", pointer.getLong(0))
        value.writeField("len", pointer.getLong(8))
        value.writeField("data", pointer.getLong(16))

        return value
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to in the JVM, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

@Structure.FieldOrder("len", "data")
internal open class ForeignBytes : Structure() {
    @JvmField var len: Int = 0

    @JvmField var data: Pointer? = null

    class ByValue :
        ForeignBytes(),
        Structure.ByValue
}

/**
 * The FfiConverter interface handles converter types to and from the FFI
 *
 * All implementing objects should be public to support external types.  When a
 * type is external we need to import it's FfiConverter.
 *
 * @suppress
 */
public interface FfiConverter<KotlinType, FfiType> {
    // Convert an FFI type to a Kotlin type
    fun lift(value: FfiType): KotlinType

    // Convert an Kotlin type to an FFI type
    fun lower(value: KotlinType): FfiType

    // Read a Kotlin type from a `ByteBuffer`
    fun read(buf: ByteBuffer): KotlinType

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    fun allocationSize(value: KotlinType): ULong

    // Write a Kotlin type to a `ByteBuffer`
    fun write(
        value: KotlinType,
        buf: ByteBuffer,
    )

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    fun lowerIntoRustBuffer(value: KotlinType): RustBuffer.ByValue {
        val rbuf = RustBuffer.alloc(allocationSize(value))
        try {
            val bbuf =
                rbuf.data!!.getByteBuffer(0, rbuf.capacity).also {
                    it.order(ByteOrder.BIG_ENDIAN)
                }
            write(value, bbuf)
            rbuf.writeField("len", bbuf.position().toLong())
            return rbuf
        } catch (e: Throwable) {
            RustBuffer.free(rbuf)
            throw e
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    fun liftFromRustBuffer(rbuf: RustBuffer.ByValue): KotlinType {
        val byteBuf = rbuf.asByteBuffer()!!
        try {
            val item = read(byteBuf)
            if (byteBuf.hasRemaining()) {
                throw RuntimeException("junk remaining in buffer after lifting, something is very wrong!!")
            }
            return item
        } finally {
            RustBuffer.free(rbuf)
        }
    }
}

/**
 * FfiConverter that uses `RustBuffer` as the FfiType
 *
 * @suppress
 */
public interface FfiConverterRustBuffer<KotlinType> : FfiConverter<KotlinType, RustBuffer.ByValue> {
    override fun lift(value: RustBuffer.ByValue) = liftFromRustBuffer(value)

    override fun lower(value: KotlinType) = lowerIntoRustBuffer(value)
}
// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.

internal const val UNIFFI_CALL_SUCCESS = 0.toByte()
internal const val UNIFFI_CALL_ERROR = 1.toByte()
internal const val UNIFFI_CALL_UNEXPECTED_ERROR = 2.toByte()

@Structure.FieldOrder("code", "error_buf")
internal open class UniffiRustCallStatus : Structure() {
    @JvmField var code: Byte = 0

    @JvmField var error_buf: RustBuffer.ByValue = RustBuffer.ByValue()

    class ByValue :
        UniffiRustCallStatus(),
        Structure.ByValue

    fun isSuccess(): Boolean = code == UNIFFI_CALL_SUCCESS

    fun isError(): Boolean = code == UNIFFI_CALL_ERROR

    fun isPanic(): Boolean = code == UNIFFI_CALL_UNEXPECTED_ERROR

    companion object {
        fun create(
            code: Byte,
            errorBuf: RustBuffer.ByValue,
        ): UniffiRustCallStatus.ByValue {
            val callStatus = UniffiRustCallStatus.ByValue()
            callStatus.code = code
            callStatus.error_buf = errorBuf
            return callStatus
        }
    }
}

class InternalException(
    message: String,
) : kotlin.Exception(message)

/**
 * Each top-level error class has a companion object that can lift the error from the call status's rust buffer
 *
 * @suppress
 */
interface UniffiRustCallStatusErrorHandler<E> {
    fun lift(error_buf: RustBuffer.ByValue): E
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself

// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
private inline fun <U, E : kotlin.Exception> uniffiRustCallWithError(
    errorHandler: UniffiRustCallStatusErrorHandler<E>,
    callback: (UniffiRustCallStatus) -> U,
): U {
    var status = UniffiRustCallStatus()
    val return_value = callback(status)
    uniffiCheckCallStatus(errorHandler, status)
    return return_value
}

// Check UniffiRustCallStatus and throw an error if the call wasn't successful
private fun <E : kotlin.Exception> uniffiCheckCallStatus(
    errorHandler: UniffiRustCallStatusErrorHandler<E>,
    status: UniffiRustCallStatus,
) {
    if (status.isSuccess()) {
        return
    } else if (status.isError()) {
        throw errorHandler.lift(status.error_buf)
    } else if (status.isPanic()) {
        // when the rust code sees a panic, it tries to construct a rustbuffer
        // with the message.  but if that code panics, then it just sends back
        // an empty buffer.
        if (status.error_buf.len > 0) {
            throw InternalException(FfiConverterString.lift(status.error_buf))
        } else {
            throw InternalException("Rust panic")
        }
    } else {
        throw InternalException("Unknown rust call status: $status.code")
    }
}

/**
 * UniffiRustCallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
 *
 * @suppress
 */
object UniffiNullRustCallStatusErrorHandler : UniffiRustCallStatusErrorHandler<InternalException> {
    override fun lift(error_buf: RustBuffer.ByValue): InternalException {
        RustBuffer.free(error_buf)
        return InternalException("Unexpected CALL_ERROR")
    }
}

// Call a rust function that returns a plain value
private inline fun <U> uniffiRustCall(callback: (UniffiRustCallStatus) -> U): U =
    uniffiRustCallWithError(UniffiNullRustCallStatusErrorHandler, callback)

internal inline fun <T> uniffiTraitInterfaceCall(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
) {
    try {
        writeReturn(makeCall())
    } catch (e: kotlin.Exception) {
        callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
        callStatus.error_buf = FfiConverterString.lower(e.toString())
    }
}

internal inline fun <T, reified E : Throwable> uniffiTraitInterfaceCallWithError(
    callStatus: UniffiRustCallStatus,
    makeCall: () -> T,
    writeReturn: (T) -> Unit,
    lowerError: (E) -> RustBuffer.ByValue,
) {
    try {
        writeReturn(makeCall())
    } catch (e: kotlin.Exception) {
        if (e is E) {
            callStatus.code = UNIFFI_CALL_ERROR
            callStatus.error_buf = lowerError(e)
        } else {
            callStatus.code = UNIFFI_CALL_UNEXPECTED_ERROR
            callStatus.error_buf = FfiConverterString.lower(e.toString())
        }
    }
}

// Map handles to objects
//
// This is used pass an opaque 64-bit handle representing a foreign object to the Rust code.
internal class UniffiHandleMap<T : Any> {
    private val map = ConcurrentHashMap<Long, T>()
    private val counter =
        java.util.concurrent.atomic
            .AtomicLong(0)

    val size: Int
        get() = map.size

    // Insert a new object into the handle map and get a handle for it
    fun insert(obj: T): Long {
        val handle = counter.getAndAdd(1)
        map.put(handle, obj)
        return handle
    }

    // Get an object from the handle map
    fun get(handle: Long): T = map.get(handle) ?: throw InternalException("UniffiHandleMap.get: Invalid handle")

    // Remove an entry from the handlemap and get the Kotlin object back
    fun remove(handle: Long): T = map.remove(handle) ?: throw InternalException("UniffiHandleMap: Invalid handle")
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.
@Synchronized
private fun findLibraryName(componentName: String): String {
    val libOverride = System.getProperty("uniffi.component.$componentName.libraryOverride")
    if (libOverride != null) {
        return libOverride
    }
    return "liveview_native_core"
}

private inline fun <reified Lib : Library> loadIndirect(componentName: String): Lib =
    Native.load<Lib>(findLibraryName(componentName), Lib::class.java)

// Define FFI callback types
internal interface UniffiRustFutureContinuationCallback : com.sun.jna.Callback {
    fun callback(
        `data`: Long,
        `pollResult`: Byte,
    )
}

internal interface UniffiForeignFutureFree : com.sun.jna.Callback {
    fun callback(`handle`: Long)
}

internal interface UniffiCallbackInterfaceFree : com.sun.jna.Callback {
    fun callback(`handle`: Long)
}

@Structure.FieldOrder("handle", "free")
internal open class UniffiForeignFuture(
    @JvmField internal var `handle`: Long = 0.toLong(),
    @JvmField internal var `free`: UniffiForeignFutureFree? = null,
) : Structure() {
    class UniffiByValue(
        `handle`: Long = 0.toLong(),
        `free`: UniffiForeignFutureFree? = null,
    ) : UniffiForeignFuture(`handle`, `free`),
        Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFuture) {
        `handle` = other.`handle`
        `free` = other.`free`
    }
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructU8(`returnValue`, `callStatus`),
        Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructU8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }
}

internal interface UniffiForeignFutureCompleteU8 : com.sun.jna.Callback {
    fun callback(
        `callbackData`: Long,
        `result`: UniffiForeignFutureStructU8.UniffiByValue,
    )
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI8(
    @JvmField internal var `returnValue`: Byte = 0.toByte(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Byte = 0.toByte(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructI8(`returnValue`, `callStatus`),
        Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructI8) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }
}

internal interface UniffiForeignFutureCompleteI8 : com.sun.jna.Callback {
    fun callback(
        `callbackData`: Long,
        `result`: UniffiForeignFutureStructI8.UniffiByValue,
    )
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructU16(`returnValue`, `callStatus`),
        Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructU16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }
}

internal interface UniffiForeignFutureCompleteU16 : com.sun.jna.Callback {
    fun callback(
        `callbackData`: Long,
        `result`: UniffiForeignFutureStructU16.UniffiByValue,
    )
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI16(
    @JvmField internal var `returnValue`: Short = 0.toShort(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Short = 0.toShort(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructI16(`returnValue`, `callStatus`),
        Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructI16) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }
}

internal interface UniffiForeignFutureCompleteI16 : com.sun.jna.Callback {
    fun callback(
        `callbackData`: Long,
        `result`: UniffiForeignFutureStructI16.UniffiByValue,
    )
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructU32(`returnValue`, `callStatus`),
        Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructU32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }
}

internal interface UniffiForeignFutureCompleteU32 : com.sun.jna.Callback {
    fun callback(
        `callbackData`: Long,
        `result`: UniffiForeignFutureStructU32.UniffiByValue,
    )
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI32(
    @JvmField internal var `returnValue`: Int = 0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Int = 0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructI32(`returnValue`, `callStatus`),
        Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructI32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }
}

internal interface UniffiForeignFutureCompleteI32 : com.sun.jna.Callback {
    fun callback(
        `callbackData`: Long,
        `result`: UniffiForeignFutureStructI32.UniffiByValue,
    )
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructU64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructU64(`returnValue`, `callStatus`),
        Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructU64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }
}

internal interface UniffiForeignFutureCompleteU64 : com.sun.jna.Callback {
    fun callback(
        `callbackData`: Long,
        `result`: UniffiForeignFutureStructU64.UniffiByValue,
    )
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructI64(
    @JvmField internal var `returnValue`: Long = 0.toLong(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Long = 0.toLong(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructI64(`returnValue`, `callStatus`),
        Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructI64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }
}

internal interface UniffiForeignFutureCompleteI64 : com.sun.jna.Callback {
    fun callback(
        `callbackData`: Long,
        `result`: UniffiForeignFutureStructI64.UniffiByValue,
    )
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructF32(
    @JvmField internal var `returnValue`: Float = 0.0f,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Float = 0.0f,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructF32(`returnValue`, `callStatus`),
        Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructF32) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }
}

internal interface UniffiForeignFutureCompleteF32 : com.sun.jna.Callback {
    fun callback(
        `callbackData`: Long,
        `result`: UniffiForeignFutureStructF32.UniffiByValue,
    )
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructF64(
    @JvmField internal var `returnValue`: Double = 0.0,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Double = 0.0,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructF64(`returnValue`, `callStatus`),
        Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructF64) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }
}

internal interface UniffiForeignFutureCompleteF64 : com.sun.jna.Callback {
    fun callback(
        `callbackData`: Long,
        `result`: UniffiForeignFutureStructF64.UniffiByValue,
    )
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructPointer(
    @JvmField internal var `returnValue`: Pointer = Pointer.NULL,
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: Pointer = Pointer.NULL,
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructPointer(`returnValue`, `callStatus`),
        Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructPointer) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }
}

internal interface UniffiForeignFutureCompletePointer : com.sun.jna.Callback {
    fun callback(
        `callbackData`: Long,
        `result`: UniffiForeignFutureStructPointer.UniffiByValue,
    )
}

@Structure.FieldOrder("returnValue", "callStatus")
internal open class UniffiForeignFutureStructRustBuffer(
    @JvmField internal var `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `returnValue`: RustBuffer.ByValue = RustBuffer.ByValue(),
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructRustBuffer(`returnValue`, `callStatus`),
        Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructRustBuffer) {
        `returnValue` = other.`returnValue`
        `callStatus` = other.`callStatus`
    }
}

internal interface UniffiForeignFutureCompleteRustBuffer : com.sun.jna.Callback {
    fun callback(
        `callbackData`: Long,
        `result`: UniffiForeignFutureStructRustBuffer.UniffiByValue,
    )
}

@Structure.FieldOrder("callStatus")
internal open class UniffiForeignFutureStructVoid(
    @JvmField internal var `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
) : Structure() {
    class UniffiByValue(
        `callStatus`: UniffiRustCallStatus.ByValue = UniffiRustCallStatus.ByValue(),
    ) : UniffiForeignFutureStructVoid(`callStatus`),
        Structure.ByValue

    internal fun uniffiSetValue(other: UniffiForeignFutureStructVoid) {
        `callStatus` = other.`callStatus`
    }
}

internal interface UniffiForeignFutureCompleteVoid : com.sun.jna.Callback {
    fun callback(
        `callbackData`: Long,
        `result`: UniffiForeignFutureStructVoid.UniffiByValue,
    )
}

// A JNA Library to expose the extern-C FFI definitions.
// This is an implementation detail which will be called internally by the public API.

internal interface UniffiLib : Library {
    companion object {
        internal val INSTANCE: UniffiLib by lazy {
            loadIndirect<UniffiLib>(componentName = "phoenix_channels_client")
                .also { lib: UniffiLib ->
                    uniffiCheckContractApiVersion(lib)
                    uniffiCheckApiChecksums(lib)
                }
        }

        // The Cleaner for the whole library
        internal val CLEANER: UniffiCleaner by lazy {
            UniffiCleaner.create()
        }
    }

    fun uniffi_phoenix_channels_client_fn_clone_channel(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_phoenix_channels_client_fn_free_channel(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun uniffi_phoenix_channels_client_fn_method_channel_call(
        `ptr`: Pointer,
        `event`: RustBuffer.ByValue,
        `payload`: RustBuffer.ByValue,
        `timeout`: RustBuffer.ByValue,
    ): Long

    fun uniffi_phoenix_channels_client_fn_method_channel_cast(
        `ptr`: Pointer,
        `event`: RustBuffer.ByValue,
        `payload`: RustBuffer.ByValue,
    ): Long

    fun uniffi_phoenix_channels_client_fn_method_channel_events(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_phoenix_channels_client_fn_method_channel_join(
        `ptr`: Pointer,
        `timeout`: RustBuffer.ByValue,
    ): Long

    fun uniffi_phoenix_channels_client_fn_method_channel_leave(`ptr`: Pointer): Long

    fun uniffi_phoenix_channels_client_fn_method_channel_listener_shutdown(`ptr`: Pointer): Long

    fun uniffi_phoenix_channels_client_fn_method_channel_payload(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun uniffi_phoenix_channels_client_fn_method_channel_presences(`ptr`: Pointer): Long

    fun uniffi_phoenix_channels_client_fn_method_channel_shutdown(`ptr`: Pointer): Long

    fun uniffi_phoenix_channels_client_fn_method_channel_status(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun uniffi_phoenix_channels_client_fn_method_channel_statuses(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_phoenix_channels_client_fn_method_channel_topic(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_phoenix_channels_client_fn_clone_channelstatuses(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_phoenix_channels_client_fn_free_channelstatuses(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun uniffi_phoenix_channels_client_fn_method_channelstatuses_status(`ptr`: Pointer): Long

    fun uniffi_phoenix_channels_client_fn_clone_events(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_phoenix_channels_client_fn_free_events(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun uniffi_phoenix_channels_client_fn_method_events_event(`ptr`: Pointer): Long

    fun uniffi_phoenix_channels_client_fn_clone_presences(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_phoenix_channels_client_fn_free_presences(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun uniffi_phoenix_channels_client_fn_method_presences_channel(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_phoenix_channels_client_fn_method_presences_joins(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_phoenix_channels_client_fn_method_presences_leaves(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_phoenix_channels_client_fn_method_presences_list(`ptr`: Pointer): Long

    fun uniffi_phoenix_channels_client_fn_method_presences_shutdown(`ptr`: Pointer): Long

    fun uniffi_phoenix_channels_client_fn_method_presences_syncs(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_phoenix_channels_client_fn_clone_presencesjoins(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_phoenix_channels_client_fn_free_presencesjoins(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun uniffi_phoenix_channels_client_fn_method_presencesjoins_join(`ptr`: Pointer): Long

    fun uniffi_phoenix_channels_client_fn_clone_presencesleaves(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_phoenix_channels_client_fn_free_presencesleaves(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun uniffi_phoenix_channels_client_fn_method_presencesleaves_leave(`ptr`: Pointer): Long

    fun uniffi_phoenix_channels_client_fn_clone_presencessyncs(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_phoenix_channels_client_fn_free_presencessyncs(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun uniffi_phoenix_channels_client_fn_method_presencessyncs_sync(`ptr`: Pointer): Long

    fun uniffi_phoenix_channels_client_fn_clone_socket(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_phoenix_channels_client_fn_free_socket(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun uniffi_phoenix_channels_client_fn_constructor_socket_spawn(
        `url`: RustBuffer.ByValue,
        `cookies`: RustBuffer.ByValue,
    ): Long

    fun uniffi_phoenix_channels_client_fn_method_socket_channel(
        `ptr`: Pointer,
        `topic`: Pointer,
        `payload`: RustBuffer.ByValue,
    ): Long

    fun uniffi_phoenix_channels_client_fn_method_socket_connect(
        `ptr`: Pointer,
        `timeout`: RustBuffer.ByValue,
    ): Long

    fun uniffi_phoenix_channels_client_fn_method_socket_disconnect(`ptr`: Pointer): Long

    fun uniffi_phoenix_channels_client_fn_method_socket_shutdown(`ptr`: Pointer): Long

    fun uniffi_phoenix_channels_client_fn_method_socket_status(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun uniffi_phoenix_channels_client_fn_method_socket_statuses(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_phoenix_channels_client_fn_method_socket_url(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun uniffi_phoenix_channels_client_fn_clone_socketstatuses(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_phoenix_channels_client_fn_free_socketstatuses(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun uniffi_phoenix_channels_client_fn_clone_topic(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun uniffi_phoenix_channels_client_fn_free_topic(
        `ptr`: Pointer,
        uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun uniffi_phoenix_channels_client_fn_constructor_topic_from_string(
        `topic`: RustBuffer.ByValue,
        uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun ffi_phoenix_channels_client_rustbuffer_alloc(
        `size`: Long,
        uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_phoenix_channels_client_rustbuffer_from_bytes(
        `bytes`: ForeignBytes.ByValue,
        uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_phoenix_channels_client_rustbuffer_free(
        `buf`: RustBuffer.ByValue,
        uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun ffi_phoenix_channels_client_rustbuffer_reserve(
        `buf`: RustBuffer.ByValue,
        `additional`: Long,
        uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_phoenix_channels_client_rust_future_poll_u8(
        `handle`: Long,
        `callback`: UniffiRustFutureContinuationCallback,
        `callbackData`: Long,
    ): Unit

    fun ffi_phoenix_channels_client_rust_future_cancel_u8(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_free_u8(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_complete_u8(
        `handle`: Long,
        uniffi_out_err: UniffiRustCallStatus,
    ): Byte

    fun ffi_phoenix_channels_client_rust_future_poll_i8(
        `handle`: Long,
        `callback`: UniffiRustFutureContinuationCallback,
        `callbackData`: Long,
    ): Unit

    fun ffi_phoenix_channels_client_rust_future_cancel_i8(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_free_i8(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_complete_i8(
        `handle`: Long,
        uniffi_out_err: UniffiRustCallStatus,
    ): Byte

    fun ffi_phoenix_channels_client_rust_future_poll_u16(
        `handle`: Long,
        `callback`: UniffiRustFutureContinuationCallback,
        `callbackData`: Long,
    ): Unit

    fun ffi_phoenix_channels_client_rust_future_cancel_u16(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_free_u16(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_complete_u16(
        `handle`: Long,
        uniffi_out_err: UniffiRustCallStatus,
    ): Short

    fun ffi_phoenix_channels_client_rust_future_poll_i16(
        `handle`: Long,
        `callback`: UniffiRustFutureContinuationCallback,
        `callbackData`: Long,
    ): Unit

    fun ffi_phoenix_channels_client_rust_future_cancel_i16(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_free_i16(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_complete_i16(
        `handle`: Long,
        uniffi_out_err: UniffiRustCallStatus,
    ): Short

    fun ffi_phoenix_channels_client_rust_future_poll_u32(
        `handle`: Long,
        `callback`: UniffiRustFutureContinuationCallback,
        `callbackData`: Long,
    ): Unit

    fun ffi_phoenix_channels_client_rust_future_cancel_u32(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_free_u32(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_complete_u32(
        `handle`: Long,
        uniffi_out_err: UniffiRustCallStatus,
    ): Int

    fun ffi_phoenix_channels_client_rust_future_poll_i32(
        `handle`: Long,
        `callback`: UniffiRustFutureContinuationCallback,
        `callbackData`: Long,
    ): Unit

    fun ffi_phoenix_channels_client_rust_future_cancel_i32(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_free_i32(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_complete_i32(
        `handle`: Long,
        uniffi_out_err: UniffiRustCallStatus,
    ): Int

    fun ffi_phoenix_channels_client_rust_future_poll_u64(
        `handle`: Long,
        `callback`: UniffiRustFutureContinuationCallback,
        `callbackData`: Long,
    ): Unit

    fun ffi_phoenix_channels_client_rust_future_cancel_u64(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_free_u64(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_complete_u64(
        `handle`: Long,
        uniffi_out_err: UniffiRustCallStatus,
    ): Long

    fun ffi_phoenix_channels_client_rust_future_poll_i64(
        `handle`: Long,
        `callback`: UniffiRustFutureContinuationCallback,
        `callbackData`: Long,
    ): Unit

    fun ffi_phoenix_channels_client_rust_future_cancel_i64(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_free_i64(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_complete_i64(
        `handle`: Long,
        uniffi_out_err: UniffiRustCallStatus,
    ): Long

    fun ffi_phoenix_channels_client_rust_future_poll_f32(
        `handle`: Long,
        `callback`: UniffiRustFutureContinuationCallback,
        `callbackData`: Long,
    ): Unit

    fun ffi_phoenix_channels_client_rust_future_cancel_f32(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_free_f32(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_complete_f32(
        `handle`: Long,
        uniffi_out_err: UniffiRustCallStatus,
    ): Float

    fun ffi_phoenix_channels_client_rust_future_poll_f64(
        `handle`: Long,
        `callback`: UniffiRustFutureContinuationCallback,
        `callbackData`: Long,
    ): Unit

    fun ffi_phoenix_channels_client_rust_future_cancel_f64(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_free_f64(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_complete_f64(
        `handle`: Long,
        uniffi_out_err: UniffiRustCallStatus,
    ): Double

    fun ffi_phoenix_channels_client_rust_future_poll_pointer(
        `handle`: Long,
        `callback`: UniffiRustFutureContinuationCallback,
        `callbackData`: Long,
    ): Unit

    fun ffi_phoenix_channels_client_rust_future_cancel_pointer(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_free_pointer(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_complete_pointer(
        `handle`: Long,
        uniffi_out_err: UniffiRustCallStatus,
    ): Pointer

    fun ffi_phoenix_channels_client_rust_future_poll_rust_buffer(
        `handle`: Long,
        `callback`: UniffiRustFutureContinuationCallback,
        `callbackData`: Long,
    ): Unit

    fun ffi_phoenix_channels_client_rust_future_cancel_rust_buffer(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_free_rust_buffer(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_complete_rust_buffer(
        `handle`: Long,
        uniffi_out_err: UniffiRustCallStatus,
    ): RustBuffer.ByValue

    fun ffi_phoenix_channels_client_rust_future_poll_void(
        `handle`: Long,
        `callback`: UniffiRustFutureContinuationCallback,
        `callbackData`: Long,
    ): Unit

    fun ffi_phoenix_channels_client_rust_future_cancel_void(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_free_void(`handle`: Long): Unit

    fun ffi_phoenix_channels_client_rust_future_complete_void(
        `handle`: Long,
        uniffi_out_err: UniffiRustCallStatus,
    ): Unit

    fun uniffi_phoenix_channels_client_checksum_method_channel_call(): Short

    fun uniffi_phoenix_channels_client_checksum_method_channel_cast(): Short

    fun uniffi_phoenix_channels_client_checksum_method_channel_events(): Short

    fun uniffi_phoenix_channels_client_checksum_method_channel_join(): Short

    fun uniffi_phoenix_channels_client_checksum_method_channel_leave(): Short

    fun uniffi_phoenix_channels_client_checksum_method_channel_listener_shutdown(): Short

    fun uniffi_phoenix_channels_client_checksum_method_channel_payload(): Short

    fun uniffi_phoenix_channels_client_checksum_method_channel_presences(): Short

    fun uniffi_phoenix_channels_client_checksum_method_channel_shutdown(): Short

    fun uniffi_phoenix_channels_client_checksum_method_channel_status(): Short

    fun uniffi_phoenix_channels_client_checksum_method_channel_statuses(): Short

    fun uniffi_phoenix_channels_client_checksum_method_channel_topic(): Short

    fun uniffi_phoenix_channels_client_checksum_method_channelstatuses_status(): Short

    fun uniffi_phoenix_channels_client_checksum_method_events_event(): Short

    fun uniffi_phoenix_channels_client_checksum_method_presences_channel(): Short

    fun uniffi_phoenix_channels_client_checksum_method_presences_joins(): Short

    fun uniffi_phoenix_channels_client_checksum_method_presences_leaves(): Short

    fun uniffi_phoenix_channels_client_checksum_method_presences_list(): Short

    fun uniffi_phoenix_channels_client_checksum_method_presences_shutdown(): Short

    fun uniffi_phoenix_channels_client_checksum_method_presences_syncs(): Short

    fun uniffi_phoenix_channels_client_checksum_method_presencesjoins_join(): Short

    fun uniffi_phoenix_channels_client_checksum_method_presencesleaves_leave(): Short

    fun uniffi_phoenix_channels_client_checksum_method_presencessyncs_sync(): Short

    fun uniffi_phoenix_channels_client_checksum_method_socket_channel(): Short

    fun uniffi_phoenix_channels_client_checksum_method_socket_connect(): Short

    fun uniffi_phoenix_channels_client_checksum_method_socket_disconnect(): Short

    fun uniffi_phoenix_channels_client_checksum_method_socket_shutdown(): Short

    fun uniffi_phoenix_channels_client_checksum_method_socket_status(): Short

    fun uniffi_phoenix_channels_client_checksum_method_socket_statuses(): Short

    fun uniffi_phoenix_channels_client_checksum_method_socket_url(): Short

    fun uniffi_phoenix_channels_client_checksum_constructor_socket_spawn(): Short

    fun uniffi_phoenix_channels_client_checksum_constructor_topic_from_string(): Short

    fun ffi_phoenix_channels_client_uniffi_contract_version(): Int
}

private fun uniffiCheckContractApiVersion(lib: UniffiLib) {
    // Get the bindings contract version from our ComponentInterface
    val bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    val scaffolding_contract_version = lib.ffi_phoenix_channels_client_uniffi_contract_version()
    if (bindings_contract_version != scaffolding_contract_version) {
        throw RuntimeException("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    }
}

@Suppress("UNUSED_PARAMETER")
private fun uniffiCheckApiChecksums(lib: UniffiLib) {
    if (lib.uniffi_phoenix_channels_client_checksum_method_channel_call() != 57788.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_channel_cast() != 701.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_channel_events() != 27101.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_channel_join() != 57628.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_channel_leave() != 43457.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_channel_listener_shutdown() != 3972.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_channel_payload() != 14057.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_channel_presences() != 32127.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_channel_shutdown() != 21366.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_channel_status() != 39920.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_channel_statuses() != 46216.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_channel_topic() != 32568.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_channelstatuses_status() != 37032.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_events_event() != 3693.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_presences_channel() != 12954.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_presences_joins() != 25837.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_presences_leaves() != 53888.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_presences_list() != 36383.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_presences_shutdown() != 60592.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_presences_syncs() != 26961.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_presencesjoins_join() != 63374.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_presencesleaves_leave() != 9261.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_presencessyncs_sync() != 6612.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_socket_channel() != 57669.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_socket_connect() != 2761.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_socket_disconnect() != 6328.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_socket_shutdown() != 1005.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_socket_status() != 52082.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_socket_statuses() != 29743.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_method_socket_url() != 48469.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_constructor_socket_spawn() != 42102.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_phoenix_channels_client_checksum_constructor_topic_from_string() != 28533.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// Async support
// Async return type handlers

internal const val UNIFFI_RUST_FUTURE_POLL_READY = 0.toByte()
internal const val UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1.toByte()

internal val uniffiContinuationHandleMap = UniffiHandleMap<CancellableContinuation<Byte>>()

// FFI type for Rust future continuations
internal object uniffiRustFutureContinuationCallbackImpl : UniffiRustFutureContinuationCallback {
    override fun callback(
        data: Long,
        pollResult: Byte,
    ) {
        uniffiContinuationHandleMap.remove(data).resume(pollResult)
    }
}

internal suspend fun <T, F, E : kotlin.Exception> uniffiRustCallAsync(
    rustFuture: Long,
    pollFunc: (Long, UniffiRustFutureContinuationCallback, Long) -> Unit,
    completeFunc: (Long, UniffiRustCallStatus) -> F,
    freeFunc: (Long) -> Unit,
    liftFunc: (F) -> T,
    errorHandler: UniffiRustCallStatusErrorHandler<E>,
): T {
    try {
        do {
            val pollResult =
                suspendCancellableCoroutine<Byte> { continuation ->
                    pollFunc(
                        rustFuture,
                        uniffiRustFutureContinuationCallbackImpl,
                        uniffiContinuationHandleMap.insert(continuation),
                    )
                }
        } while (pollResult != UNIFFI_RUST_FUTURE_POLL_READY)

        return liftFunc(
            uniffiRustCallWithError(errorHandler, { status -> completeFunc(rustFuture, status) }),
        )
    } finally {
        freeFunc(rustFuture)
    }
}

// Public interface members begin here.

// Interface implemented by anything that can contain an object reference.
//
// Such types expose a `destroy()` method that must be called to cleanly
// dispose of the contained objects. Failure to call this method may result
// in memory leaks.
//
// The easiest way to ensure this method is called is to use the `.use`
// helper method to execute a block and destroy the object at the end.
interface Disposable {
    fun destroy()

    companion object {
        fun destroy(vararg args: Any?) {
            args
                .filterIsInstance<Disposable>()
                .forEach(Disposable::destroy)
        }
    }
}

/**
 * @suppress
 */
inline fun <T : Disposable?, R> T.use(block: (T) -> R) =
    try {
        block(this)
    } finally {
        try {
            // N.B. our implementation is on the nullable type `Disposable?`.
            this?.destroy()
        } catch (e: Throwable) {
            // swallow
        }
    }

/**
 * Used to instantiate an interface without an actual pointer, for fakes in tests, mostly.
 *
 * @suppress
 * */
object NoPointer

/**
 * @suppress
 */
public object FfiConverterUByte : FfiConverter<UByte, Byte> {
    override fun lift(value: Byte): UByte = value.toUByte()

    override fun read(buf: ByteBuffer): UByte = lift(buf.get())

    override fun lower(value: UByte): Byte = value.toByte()

    override fun allocationSize(value: UByte) = 1UL

    override fun write(
        value: UByte,
        buf: ByteBuffer,
    ) {
        buf.put(value.toByte())
    }
}

/**
 * @suppress
 */
public object FfiConverterUShort : FfiConverter<UShort, Short> {
    override fun lift(value: Short): UShort = value.toUShort()

    override fun read(buf: ByteBuffer): UShort = lift(buf.getShort())

    override fun lower(value: UShort): Short = value.toShort()

    override fun allocationSize(value: UShort) = 2UL

    override fun write(
        value: UShort,
        buf: ByteBuffer,
    ) {
        buf.putShort(value.toShort())
    }
}

/**
 * @suppress
 */
public object FfiConverterULong : FfiConverter<ULong, Long> {
    override fun lift(value: Long): ULong = value.toULong()

    override fun read(buf: ByteBuffer): ULong = lift(buf.getLong())

    override fun lower(value: ULong): Long = value.toLong()

    override fun allocationSize(value: ULong) = 8UL

    override fun write(
        value: ULong,
        buf: ByteBuffer,
    ) {
        buf.putLong(value.toLong())
    }
}

/**
 * @suppress
 */
public object FfiConverterLong : FfiConverter<Long, Long> {
    override fun lift(value: Long): Long = value

    override fun read(buf: ByteBuffer): Long = buf.getLong()

    override fun lower(value: Long): Long = value

    override fun allocationSize(value: Long) = 8UL

    override fun write(
        value: Long,
        buf: ByteBuffer,
    ) {
        buf.putLong(value)
    }
}

/**
 * @suppress
 */
public object FfiConverterDouble : FfiConverter<Double, Double> {
    override fun lift(value: Double): Double = value

    override fun read(buf: ByteBuffer): Double = buf.getDouble()

    override fun lower(value: Double): Double = value

    override fun allocationSize(value: Double) = 8UL

    override fun write(
        value: Double,
        buf: ByteBuffer,
    ) {
        buf.putDouble(value)
    }
}

/**
 * @suppress
 */
public object FfiConverterBoolean : FfiConverter<Boolean, Byte> {
    override fun lift(value: Byte): Boolean = value.toInt() != 0

    override fun read(buf: ByteBuffer): Boolean = lift(buf.get())

    override fun lower(value: Boolean): Byte = if (value) 1.toByte() else 0.toByte()

    override fun allocationSize(value: Boolean) = 1UL

    override fun write(
        value: Boolean,
        buf: ByteBuffer,
    ) {
        buf.put(lower(value))
    }
}

/**
 * @suppress
 */
public object FfiConverterString : FfiConverter<String, RustBuffer.ByValue> {
    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    override fun lift(value: RustBuffer.ByValue): String {
        try {
            val byteArr = ByteArray(value.len.toInt())
            value.asByteBuffer()!!.get(byteArr)
            return byteArr.toString(Charsets.UTF_8)
        } finally {
            RustBuffer.free(value)
        }
    }

    override fun read(buf: ByteBuffer): String {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr.toString(Charsets.UTF_8)
    }

    fun toUtf8(value: String): ByteBuffer {
        // Make sure we don't have invalid UTF-16, check for lone surrogates.
        return Charsets.UTF_8.newEncoder().run {
            onMalformedInput(CodingErrorAction.REPORT)
            encode(CharBuffer.wrap(value))
        }
    }

    override fun lower(value: String): RustBuffer.ByValue {
        val byteBuf = toUtf8(value)
        // Ideally we'd pass these bytes to `ffi_bytebuffer_from_bytes`, but doing so would require us
        // to copy them into a JNA `Memory`. So we might as well directly copy them into a `RustBuffer`.
        val rbuf = RustBuffer.alloc(byteBuf.limit().toULong())
        rbuf.asByteBuffer()!!.put(byteBuf)
        return rbuf
    }

    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per UTF-16 code unit which will always be
    // enough.
    override fun allocationSize(value: String): ULong {
        val sizeForLength = 4UL
        val sizeForString = value.length.toULong() * 3UL
        return sizeForLength + sizeForString
    }

    override fun write(
        value: String,
        buf: ByteBuffer,
    ) {
        val byteBuf = toUtf8(value)
        buf.putInt(byteBuf.limit())
        buf.put(byteBuf)
    }
}

/**
 * @suppress
 */
public object FfiConverterByteArray : FfiConverterRustBuffer<ByteArray> {
    override fun read(buf: ByteBuffer): ByteArray {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr
    }

    override fun allocationSize(value: ByteArray): ULong = 4UL + value.size.toULong()

    override fun write(
        value: ByteArray,
        buf: ByteBuffer,
    ) {
        buf.putInt(value.size)
        buf.put(value)
    }
}

/**
 * @suppress
 */
public object FfiConverterTimestamp : FfiConverterRustBuffer<java.time.Instant> {
    override fun read(buf: ByteBuffer): java.time.Instant {
        val seconds = buf.getLong()
        // Type mismatch (should be u32) but we check for overflow/underflow below
        val nanoseconds = buf.getInt().toLong()
        if (nanoseconds < 0) {
            throw java.time.DateTimeException("Instant nanoseconds exceed minimum or maximum supported by uniffi")
        }
        if (seconds >= 0) {
            return java.time.Instant.EPOCH
                .plus(java.time.Duration.ofSeconds(seconds, nanoseconds))
        } else {
            return java.time.Instant.EPOCH
                .minus(java.time.Duration.ofSeconds(-seconds, nanoseconds))
        }
    }

    // 8 bytes for seconds, 4 bytes for nanoseconds
    override fun allocationSize(value: java.time.Instant) = 12UL

    override fun write(
        value: java.time.Instant,
        buf: ByteBuffer,
    ) {
        var epochOffset = java.time.Duration.between(java.time.Instant.EPOCH, value)

        var sign = 1
        if (epochOffset.isNegative()) {
            sign = -1
            epochOffset = epochOffset.negated()
        }

        if (epochOffset.nano < 0) {
            // Java docs provide guarantee that nano will always be positive, so this should be impossible
            // See: https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html
            throw IllegalArgumentException("Invalid timestamp, nano value must be non-negative")
        }

        buf.putLong(sign * epochOffset.seconds)
        // Type mismatch (should be u32) but since values will always be between 0 and 999,999,999 it should be OK
        buf.putInt(epochOffset.nano)
    }
}

/**
 * @suppress
 */
public object FfiConverterDuration : FfiConverterRustBuffer<java.time.Duration> {
    override fun read(buf: ByteBuffer): java.time.Duration {
        // Type mismatch (should be u64) but we check for overflow/underflow below
        val seconds = buf.getLong()
        // Type mismatch (should be u32) but we check for overflow/underflow below
        val nanoseconds = buf.getInt().toLong()
        if (seconds < 0) {
            throw java.time.DateTimeException("Duration exceeds minimum or maximum value supported by uniffi")
        }
        if (nanoseconds < 0) {
            throw java.time.DateTimeException("Duration nanoseconds exceed minimum or maximum supported by uniffi")
        }
        return java.time.Duration.ofSeconds(seconds, nanoseconds)
    }

    // 8 bytes for seconds, 4 bytes for nanoseconds
    override fun allocationSize(value: java.time.Duration) = 12UL

    override fun write(
        value: java.time.Duration,
        buf: ByteBuffer,
    ) {
        if (value.seconds < 0) {
            // Rust does not support negative Durations
            throw IllegalArgumentException("Invalid duration, must be non-negative")
        }

        if (value.nano < 0) {
            // Java docs provide guarantee that nano will always be positive, so this should be impossible
            // See: https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html
            throw IllegalArgumentException("Invalid duration, nano value must be non-negative")
        }

        // Type mismatch (should be u64) but since Rust doesn't support negative durations we should be OK
        buf.putLong(value.seconds)
        // Type mismatch (should be u32) but since values will always be between 0 and 999,999,999 it should be OK
        buf.putInt(value.nano)
    }
}

// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//

/**
 * The cleaner interface for Object finalization code to run.
 * This is the entry point to any implementation that we're using.
 *
 * The cleaner registers objects and returns cleanables, so now we are
 * defining a `UniffiCleaner` with a `UniffiClenaer.Cleanable` to abstract the
 * different implmentations available at compile time.
 *
 * @suppress
 */
interface UniffiCleaner {
    interface Cleanable {
        fun clean()
    }

    fun register(
        value: Any,
        cleanUpTask: Runnable,
    ): UniffiCleaner.Cleanable

    companion object
}

// The fallback Jna cleaner, which is available for both Android, and the JVM.
private class UniffiJnaCleaner : UniffiCleaner {
    private val cleaner =
        com.sun.jna.internal.Cleaner
            .getCleaner()

    override fun register(
        value: Any,
        cleanUpTask: Runnable,
    ): UniffiCleaner.Cleanable = UniffiJnaCleanable(cleaner.register(value, cleanUpTask))
}

private class UniffiJnaCleanable(
    private val cleanable: com.sun.jna.internal.Cleaner.Cleanable,
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}

// We decide at uniffi binding generation time whether we were
// using Android or not.
// There are further runtime checks to chose the correct implementation
// of the cleaner.
private fun UniffiCleaner.Companion.create(): UniffiCleaner =
    try {
        // For safety's sake: if the library hasn't been run in android_cleaner = true
        // mode, but is being run on Android, then we still need to think about
        // Android API versions.
        // So we check if java.lang.ref.Cleaner is there, and use that…
        java.lang.Class.forName("java.lang.ref.Cleaner")
        JavaLangRefCleaner()
    } catch (e: ClassNotFoundException) {
        // … otherwise, fallback to the JNA cleaner.
        UniffiJnaCleaner()
    }

private class JavaLangRefCleaner : UniffiCleaner {
    val cleaner =
        java.lang.ref.Cleaner
            .create()

    override fun register(
        value: Any,
        cleanUpTask: Runnable,
    ): UniffiCleaner.Cleanable = JavaLangRefCleanable(cleaner.register(value, cleanUpTask))
}

private class JavaLangRefCleanable(
    val cleanable: java.lang.ref.Cleaner.Cleanable,
) : UniffiCleaner.Cleanable {
    override fun clean() = cleanable.clean()
}

/**
 * A [Channel] is created with [Socket::channel](crate::Socket::channel)
 *
 * It represents a unique connection to the topic, and as a result, you may join
 * the same topic many times, each time receiving a new, unique `Channel` instance.
 *
 * To leave a topic/channel, you can either await the result of `Channel::leave`, or
 * drop the channel. Once all references to a specific `Channel` are dropped, if it
 * hasn't yet left its channel, this is
 * f sending messages to the channel:
 *
 * * [Channel::call] to send a message and await a reply from the server
 * * [Channel::cast] to send a message and ignore any replies

 */
public interface ChannelInterface {
    /**
     * Like `send`, except it takes a configurable `timeout` for awaiting the reply.
     *
     * If `timeout` is None, it is equivalent to `send`, and waits forever.
     * If `timeout` is Some(Duration), then waiting for the reply will stop after the duration expires,
     * and a `SendError::Timeout` will be produced. If the reply is received before that occurs, then
     * the reply payload will be returned.
     */
    suspend fun `call`(
        `event`: Event,
        `payload`: Payload,
        `timeout`: java.time.Duration,
    ): Payload

    /**
     * Sends `event` with `payload` to this channel, and returns `Ok` if successful.
     *
     * This function does not wait for any reply, if you need the reply, then use `send` or `send_with_timeout`.
     */
    suspend fun `cast`(
        `event`: Event,
        `payload`: Payload,
    )

    /**
     * Broadcasts [EventPayload] sent from server.
     */
    fun `events`(): Events

    /**
     * Join [Channel::topic] with [Channel::payload] within `timeout`.
     */
    suspend fun `join`(`timeout`: java.time.Duration): Payload

    /**
     * Leaves this channel
     */
    suspend fun `leave`()

    /**
     * Propagates panic from async task.
     */
    suspend fun `listenerShutdown`()

    /**
     * Returns the payload sent to the channel when joined
     */
    fun `payload`(): Payload

    /**
     * Creates a [Presences] for the channel
     */
    suspend fun `presences`(): Presences

    /**
     * Propagates panic from async task.
     */
    suspend fun `shutdown`()

    /**
     * The current [ChannelStatus].
     *
     * Use [Channel::statuses] to receive changes to the status.
     */
    fun `status`(): ChannelStatus

    /**
     * Broadcasts [Channel::status] changes.
     *
     * Use [Channel::status] to see the current status.
     */
    fun `statuses`(): ChannelStatuses

    /**
     * Returns the topic this channel is connected to
     */
    fun `topic`(): Topic

    companion object
}

/**
 * A [Channel] is created with [Socket::channel](crate::Socket::channel)
 *
 * It represents a unique connection to the topic, and as a result, you may join
 * the same topic many times, each time receiving a new, unique `Channel` instance.
 *
 * To leave a topic/channel, you can either await the result of `Channel::leave`, or
 * drop the channel. Once all references to a specific `Channel` are dropped, if it
 * hasn't yet left its channel, this is
 * f sending messages to the channel:
 *
 * * [Channel::call] to send a message and await a reply from the server
 * * [Channel::cast] to send a message and ignore any replies

 */
open class Channel :
    Disposable,
    AutoCloseable,
    ChannelInterface {
    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (!this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(
        private val pointer: Pointer?,
    ) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_free_channel(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer =
        uniffiRustCall { status ->
            UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_clone_channel(pointer!!, status)
        }

    /**
     * Like `send`, except it takes a configurable `timeout` for awaiting the reply.
     *
     * If `timeout` is None, it is equivalent to `send`, and waits forever.
     * If `timeout` is Some(Duration), then waiting for the reply will stop after the duration expires,
     * and a `SendError::Timeout` will be produced. If the reply is received before that occurs, then
     * the reply payload will be returned.
     */
    @Throws(CallException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `call`(
        `event`: Event,
        `payload`: Payload,
        `timeout`: java.time.Duration,
    ): Payload =
        uniffiRustCallAsync(
            callWithPointer { thisPtr ->
                UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_channel_call(
                    thisPtr,
                    FfiConverterTypeEvent.lower(`event`),
                    FfiConverterTypePayload.lower(`payload`),
                    FfiConverterDuration.lower(`timeout`),
                )
            },
            {
                    future,
                    callback,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_poll_rust_buffer(future, callback, continuation)
            },
            {
                    future,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_complete_rust_buffer(future, continuation)
            },
            { future -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_free_rust_buffer(future) },
            // lift function
            { FfiConverterTypePayload.lift(it) },
            // Error FFI converter
            CallException.ErrorHandler,
        )

    /**
     * Sends `event` with `payload` to this channel, and returns `Ok` if successful.
     *
     * This function does not wait for any reply, if you need the reply, then use `send` or `send_with_timeout`.
     */
    @Throws(CastException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `cast`(
        `event`: Event,
        `payload`: Payload,
    ) = uniffiRustCallAsync(
        callWithPointer { thisPtr ->
            UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_channel_cast(
                thisPtr,
                FfiConverterTypeEvent.lower(`event`),
                FfiConverterTypePayload.lower(`payload`),
            )
        },
        {
                future,
                callback,
                continuation,
            ->
            UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_poll_void(future, callback, continuation)
        },
        { future, continuation -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_complete_void(future, continuation) },
        { future -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_free_void(future) },
        // lift function
        { Unit },
        // Error FFI converter
        CastException.ErrorHandler,
    )

    /**
     * Broadcasts [EventPayload] sent from server.
     */
    override fun `events`(): Events =
        FfiConverterTypeEvents.lift(
            callWithPointer {
                uniffiRustCall { _status ->
                    UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_channel_events(
                        it,
                        _status,
                    )
                }
            },
        )

    /**
     * Join [Channel::topic] with [Channel::payload] within `timeout`.
     */
    @Throws(ChannelJoinException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `join`(`timeout`: java.time.Duration): Payload =
        uniffiRustCallAsync(
            callWithPointer { thisPtr ->
                UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_channel_join(
                    thisPtr,
                    FfiConverterDuration.lower(`timeout`),
                )
            },
            {
                    future,
                    callback,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_poll_rust_buffer(future, callback, continuation)
            },
            {
                    future,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_complete_rust_buffer(future, continuation)
            },
            { future -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_free_rust_buffer(future) },
            // lift function
            { FfiConverterTypePayload.lift(it) },
            // Error FFI converter
            ChannelJoinException.ErrorHandler,
        )

    /**
     * Leaves this channel
     */
    @Throws(LeaveException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `leave`() =
        uniffiRustCallAsync(
            callWithPointer { thisPtr ->
                UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_channel_leave(
                    thisPtr,
                )
            },
            {
                    future,
                    callback,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_poll_void(future, callback, continuation)
            },
            { future, continuation -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_complete_void(future, continuation) },
            { future -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_free_void(future) },
            // lift function
            { Unit },
            // Error FFI converter
            LeaveException.ErrorHandler,
        )

    /**
     * Propagates panic from async task.
     */
    @Throws(ChannelShutdownException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `listenerShutdown`() =
        uniffiRustCallAsync(
            callWithPointer { thisPtr ->
                UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_channel_listener_shutdown(
                    thisPtr,
                )
            },
            {
                    future,
                    callback,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_poll_void(future, callback, continuation)
            },
            { future, continuation -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_complete_void(future, continuation) },
            { future -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_free_void(future) },
            // lift function
            { Unit },
            // Error FFI converter
            ChannelShutdownException.ErrorHandler,
        )

    /**
     * Returns the payload sent to the channel when joined
     */
    override fun `payload`(): Payload =
        FfiConverterTypePayload.lift(
            callWithPointer {
                uniffiRustCall { _status ->
                    UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_channel_payload(
                        it,
                        _status,
                    )
                }
            },
        )

    /**
     * Creates a [Presences] for the channel
     */
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `presences`(): Presences =
        uniffiRustCallAsync(
            callWithPointer { thisPtr ->
                UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_channel_presences(
                    thisPtr,
                )
            },
            {
                    future,
                    callback,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_poll_pointer(future, callback, continuation)
            },
            { future, continuation -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_complete_pointer(future, continuation) },
            { future -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_free_pointer(future) },
            // lift function
            { FfiConverterTypePresences.lift(it) },
            // Error FFI converter
            UniffiNullRustCallStatusErrorHandler,
        )

    /**
     * Propagates panic from async task.
     */
    @Throws(ChannelShutdownException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `shutdown`() =
        uniffiRustCallAsync(
            callWithPointer { thisPtr ->
                UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_channel_shutdown(
                    thisPtr,
                )
            },
            {
                    future,
                    callback,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_poll_void(future, callback, continuation)
            },
            { future, continuation -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_complete_void(future, continuation) },
            { future -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_free_void(future) },
            // lift function
            { Unit },
            // Error FFI converter
            ChannelShutdownException.ErrorHandler,
        )

    /**
     * The current [ChannelStatus].
     *
     * Use [Channel::statuses] to receive changes to the status.
     */
    override fun `status`(): ChannelStatus =
        FfiConverterTypeChannelStatus.lift(
            callWithPointer {
                uniffiRustCall { _status ->
                    UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_channel_status(
                        it,
                        _status,
                    )
                }
            },
        )

    /**
     * Broadcasts [Channel::status] changes.
     *
     * Use [Channel::status] to see the current status.
     */
    override fun `statuses`(): ChannelStatuses =
        FfiConverterTypeChannelStatuses.lift(
            callWithPointer {
                uniffiRustCall { _status ->
                    UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_channel_statuses(
                        it,
                        _status,
                    )
                }
            },
        )

    /**
     * Returns the topic this channel is connected to
     */
    override fun `topic`(): Topic =
        FfiConverterTypeTopic.lift(
            callWithPointer {
                uniffiRustCall { _status ->
                    UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_channel_topic(
                        it,
                        _status,
                    )
                }
            },
        )

    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeChannel : FfiConverter<Channel, Pointer> {
    override fun lower(value: Channel): Pointer = value.uniffiClonePointer()

    override fun lift(value: Pointer): Channel = Channel(value)

    override fun read(buf: ByteBuffer): Channel {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Channel) = 8UL

    override fun write(
        value: Channel,
        buf: ByteBuffer,
    ) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//

/**
 * Waits for [ChannelStatus] changes from the [Channel](crate::Channel).
 */
public interface ChannelStatusesInterface {
    /**
     * Wait for next [ChannelStatus] when the [Channel::status](super::Channel::status) changes.
     */
    suspend fun `status`(): ChannelStatus

    companion object
}

/**
 * Waits for [ChannelStatus] changes from the [Channel](crate::Channel).
 */
open class ChannelStatuses :
    Disposable,
    AutoCloseable,
    ChannelStatusesInterface {
    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (!this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(
        private val pointer: Pointer?,
    ) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_free_channelstatuses(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer =
        uniffiRustCall { status ->
            UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_clone_channelstatuses(pointer!!, status)
        }

    /**
     * Wait for next [ChannelStatus] when the [Channel::status](super::Channel::status) changes.
     */
    @Throws(StatusesException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `status`(): ChannelStatus =
        uniffiRustCallAsync(
            callWithPointer { thisPtr ->
                UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_channelstatuses_status(
                    thisPtr,
                )
            },
            {
                    future,
                    callback,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_poll_rust_buffer(future, callback, continuation)
            },
            {
                    future,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_complete_rust_buffer(future, continuation)
            },
            { future -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_free_rust_buffer(future) },
            // lift function
            { FfiConverterTypeChannelStatus.lift(it) },
            // Error FFI converter
            StatusesException.ErrorHandler,
        )

    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeChannelStatuses : FfiConverter<ChannelStatuses, Pointer> {
    override fun lower(value: ChannelStatuses): Pointer = value.uniffiClonePointer()

    override fun lift(value: Pointer): ChannelStatuses = ChannelStatuses(value)

    override fun read(buf: ByteBuffer): ChannelStatuses {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: ChannelStatuses) = 8UL

    override fun write(
        value: ChannelStatuses,
        buf: ByteBuffer,
    ) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//

/**
 * Waits for [EventPayload]s sent from the server.
 */
public interface EventsInterface {
    /**
     * Wait for next [EventPayload] sent from the server.
     */
    suspend fun `event`(): EventPayload

    companion object
}

/**
 * Waits for [EventPayload]s sent from the server.
 */
open class Events :
    Disposable,
    AutoCloseable,
    EventsInterface {
    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (!this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(
        private val pointer: Pointer?,
    ) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_free_events(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer =
        uniffiRustCall { status ->
            UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_clone_events(pointer!!, status)
        }

    /**
     * Wait for next [EventPayload] sent from the server.
     */
    @Throws(EventsException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `event`(): EventPayload =
        uniffiRustCallAsync(
            callWithPointer { thisPtr ->
                UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_events_event(
                    thisPtr,
                )
            },
            {
                    future,
                    callback,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_poll_rust_buffer(future, callback, continuation)
            },
            {
                    future,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_complete_rust_buffer(future, continuation)
            },
            { future -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_free_rust_buffer(future) },
            // lift function
            { FfiConverterTypeEventPayload.lift(it) },
            // Error FFI converter
            EventsException.ErrorHandler,
        )

    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeEvents : FfiConverter<Events, Pointer> {
    override fun lower(value: Events): Pointer = value.uniffiClonePointer()

    override fun lift(value: Pointer): Events = Events(value)

    override fun read(buf: ByteBuffer): Events {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Events) = 8UL

    override fun write(
        value: Events,
        buf: ByteBuffer,
    ) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//

/**
 * All [Presence]s in a [Channel](Presences::channel), such as all users in chat room.
 */
public interface PresencesInterface {
    /**
     * The [Channel] on which [Presence]s are being tracked.
     */
    fun `channel`(): Channel

    /**
     * Broadcasts when a [Presence] joins the [Presences::channel].
     */
    fun `joins`(): PresencesJoins

    /**
     * Broadcasts when a [Presence] leaves the [Presences::channel].
     */
    fun `leaves`(): PresencesLeaves

    /**
     * The [Presence] currently in [Presences::channel].
     */
    suspend fun `list`(): List<Presence>

    /**
     * Propagates panic from the async task.
     */
    suspend fun `shutdown`()

    /**
     * Broadcasts on changes to [Presences::list].
     */
    fun `syncs`(): PresencesSyncs

    companion object
}

/**
 * All [Presence]s in a [Channel](Presences::channel), such as all users in chat room.
 */
open class Presences :
    Disposable,
    AutoCloseable,
    PresencesInterface {
    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (!this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(
        private val pointer: Pointer?,
    ) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_free_presences(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer =
        uniffiRustCall { status ->
            UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_clone_presences(pointer!!, status)
        }

    /**
     * The [Channel] on which [Presence]s are being tracked.
     */
    override fun `channel`(): Channel =
        FfiConverterTypeChannel.lift(
            callWithPointer {
                uniffiRustCall { _status ->
                    UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_presences_channel(
                        it,
                        _status,
                    )
                }
            },
        )

    /**
     * Broadcasts when a [Presence] joins the [Presences::channel].
     */
    override fun `joins`(): PresencesJoins =
        FfiConverterTypePresencesJoins.lift(
            callWithPointer {
                uniffiRustCall { _status ->
                    UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_presences_joins(
                        it,
                        _status,
                    )
                }
            },
        )

    /**
     * Broadcasts when a [Presence] leaves the [Presences::channel].
     */
    override fun `leaves`(): PresencesLeaves =
        FfiConverterTypePresencesLeaves.lift(
            callWithPointer {
                uniffiRustCall { _status ->
                    UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_presences_leaves(
                        it,
                        _status,
                    )
                }
            },
        )

    /**
     * The [Presence] currently in [Presences::channel].
     */
    @Throws(PresencesShutdownException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `list`(): List<Presence> =
        uniffiRustCallAsync(
            callWithPointer { thisPtr ->
                UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_presences_list(
                    thisPtr,
                )
            },
            {
                    future,
                    callback,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_poll_rust_buffer(future, callback, continuation)
            },
            {
                    future,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_complete_rust_buffer(future, continuation)
            },
            { future -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_free_rust_buffer(future) },
            // lift function
            { FfiConverterSequenceTypePresence.lift(it) },
            // Error FFI converter
            PresencesShutdownException.ErrorHandler,
        )

    /**
     * Propagates panic from the async task.
     */
    @Throws(PresencesShutdownException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `shutdown`() =
        uniffiRustCallAsync(
            callWithPointer { thisPtr ->
                UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_presences_shutdown(
                    thisPtr,
                )
            },
            {
                    future,
                    callback,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_poll_void(future, callback, continuation)
            },
            { future, continuation -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_complete_void(future, continuation) },
            { future -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_free_void(future) },
            // lift function
            { Unit },
            // Error FFI converter
            PresencesShutdownException.ErrorHandler,
        )

    /**
     * Broadcasts on changes to [Presences::list].
     */
    override fun `syncs`(): PresencesSyncs =
        FfiConverterTypePresencesSyncs.lift(
            callWithPointer {
                uniffiRustCall { _status ->
                    UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_presences_syncs(
                        it,
                        _status,
                    )
                }
            },
        )

    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePresences : FfiConverter<Presences, Pointer> {
    override fun lower(value: Presences): Pointer = value.uniffiClonePointer()

    override fun lift(value: Pointer): Presences = Presences(value)

    override fun read(buf: ByteBuffer): Presences {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Presences) = 8UL

    override fun write(
        value: Presences,
        buf: ByteBuffer,
    ) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//

/**
 * Waits for the next [PresenceJoin](crate::PresencesJoin) when
 * [Presences::list](crate::Presences::list) changes by a user joining.
 */
public interface PresencesJoinsInterface {
    /**
     * Wait for next time a user joins [Presences].
     */
    suspend fun `join`(): PresencesJoin

    companion object
}

/**
 * Waits for the next [PresenceJoin](crate::PresencesJoin) when
 * [Presences::list](crate::Presences::list) changes by a user joining.
 */
open class PresencesJoins :
    Disposable,
    AutoCloseable,
    PresencesJoinsInterface {
    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (!this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(
        private val pointer: Pointer?,
    ) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_free_presencesjoins(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer =
        uniffiRustCall { status ->
            UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_clone_presencesjoins(pointer!!, status)
        }

    /**
     * Wait for next time a user joins [Presences].
     */
    @Throws(PresencesJoinsException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `join`(): PresencesJoin =
        uniffiRustCallAsync(
            callWithPointer { thisPtr ->
                UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_presencesjoins_join(
                    thisPtr,
                )
            },
            {
                    future,
                    callback,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_poll_rust_buffer(future, callback, continuation)
            },
            {
                    future,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_complete_rust_buffer(future, continuation)
            },
            { future -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_free_rust_buffer(future) },
            // lift function
            { FfiConverterTypePresencesJoin.lift(it) },
            // Error FFI converter
            PresencesJoinsException.ErrorHandler,
        )

    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePresencesJoins : FfiConverter<PresencesJoins, Pointer> {
    override fun lower(value: PresencesJoins): Pointer = value.uniffiClonePointer()

    override fun lift(value: Pointer): PresencesJoins = PresencesJoins(value)

    override fun read(buf: ByteBuffer): PresencesJoins {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: PresencesJoins) = 8UL

    override fun write(
        value: PresencesJoins,
        buf: ByteBuffer,
    ) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//

/**
 * Waits for the next [PresenceLeave](crate::PresencesLeave) when
 * [Presences::list](crate::Presences::list) changes because a user leaves.
 */
public interface PresencesLeavesInterface {
    /**
     * Wait for next time a user leaves [Presences].
     */
    suspend fun `leave`(): PresencesLeave

    companion object
}

/**
 * Waits for the next [PresenceLeave](crate::PresencesLeave) when
 * [Presences::list](crate::Presences::list) changes because a user leaves.
 */
open class PresencesLeaves :
    Disposable,
    AutoCloseable,
    PresencesLeavesInterface {
    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (!this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(
        private val pointer: Pointer?,
    ) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_free_presencesleaves(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer =
        uniffiRustCall { status ->
            UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_clone_presencesleaves(pointer!!, status)
        }

    /**
     * Wait for next time a user leaves [Presences].
     */
    @Throws(PresencesLeavesException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `leave`(): PresencesLeave =
        uniffiRustCallAsync(
            callWithPointer { thisPtr ->
                UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_presencesleaves_leave(
                    thisPtr,
                )
            },
            {
                    future,
                    callback,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_poll_rust_buffer(future, callback, continuation)
            },
            {
                    future,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_complete_rust_buffer(future, continuation)
            },
            { future -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_free_rust_buffer(future) },
            // lift function
            { FfiConverterTypePresencesLeave.lift(it) },
            // Error FFI converter
            PresencesLeavesException.ErrorHandler,
        )

    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePresencesLeaves : FfiConverter<PresencesLeaves, Pointer> {
    override fun lower(value: PresencesLeaves): Pointer = value.uniffiClonePointer()

    override fun lift(value: Pointer): PresencesLeaves = PresencesLeaves(value)

    override fun read(buf: ByteBuffer): PresencesLeaves {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: PresencesLeaves) = 8UL

    override fun write(
        value: PresencesLeaves,
        buf: ByteBuffer,
    ) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//

public interface PresencesSyncsInterface {
    /**
     * Wait for next time [Presences] changes.  When [Presences] changes call [Presences::list] to get the up-to-date
     * list of [Presence]s.
     */
    suspend fun `sync`()

    companion object
}

open class PresencesSyncs :
    Disposable,
    AutoCloseable,
    PresencesSyncsInterface {
    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (!this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(
        private val pointer: Pointer?,
    ) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_free_presencessyncs(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer =
        uniffiRustCall { status ->
            UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_clone_presencessyncs(pointer!!, status)
        }

    /**
     * Wait for next time [Presences] changes.  When [Presences] changes call [Presences::list] to get the up-to-date
     * list of [Presence]s.
     */
    @Throws(PresencesSyncsException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `sync`() =
        uniffiRustCallAsync(
            callWithPointer { thisPtr ->
                UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_presencessyncs_sync(
                    thisPtr,
                )
            },
            {
                    future,
                    callback,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_poll_void(future, callback, continuation)
            },
            { future, continuation -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_complete_void(future, continuation) },
            { future -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_free_void(future) },
            // lift function
            { Unit },
            // Error FFI converter
            PresencesSyncsException.ErrorHandler,
        )

    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePresencesSyncs : FfiConverter<PresencesSyncs, Pointer> {
    override fun lower(value: PresencesSyncs): Pointer = value.uniffiClonePointer()

    override fun lift(value: Pointer): PresencesSyncs = PresencesSyncs(value)

    override fun read(buf: ByteBuffer): PresencesSyncs {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: PresencesSyncs) = 8UL

    override fun write(
        value: PresencesSyncs,
        buf: ByteBuffer,
    ) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//

/**
 * A [`Socket`] manages the underlying WebSocket connection used to talk to Phoenix.
 *
 * It acts as the primary interface (along with [`Channel`]) for working with Phoenix Channels.
 *
 * When a client is created, it is disconnected, and must be explicitly connected via [`Self::connect`].
 * Once connected, a worker task is spawned that acts as the broker for messages being sent or
 * received over the socket.
 *
 * Once connected, the more useful [`Channel`] instance can be obtained via [`Self::channel`]. Most functionality
 * related to channels is exposed there.
 */
public interface SocketInterface {
    /**
     * Creates a new, unjoined Phoenix Channel
     */
    suspend fun `channel`(
        `topic`: Topic,
        `payload`: Payload?,
    ): Channel

    /**
     * Connects this client to the configured Phoenix Channels endpoint
     *
     * This function must be called before using the client to join channels, etc.
     *
     * A join handle to the socket worker is returned, we can use this to wait until the worker
     * exits to ensure graceful termination. Otherwise, when the handle is dropped, it detaches the
     * worker from the task runtime (though it will continue to run in the background)
     */
    suspend fun `connect`(`timeout`: java.time.Duration)

    /**
     * Disconnect the client, regardless of any outstanding channel references
     *
     * Connected channels will return `ChannelError::Closed` when next used.
     *
     * New channels will need to be obtained from this client after `connect` is
     * called again.
     */
    suspend fun `disconnect`()

    /**
     * Propagates panic from async task.
     */
    suspend fun `shutdown`()

    /**
     * The current [SocketStatus].
     *
     * Use [Socket::status] to receive changes to the status.
     */
    fun `status`(): SocketStatus

    /**
     * Broadcasts [Socket::status] changes.
     *
     * Use [Socket::status] to see the current status.
     */
    fun `statuses`(): SocketStatuses

    /**
     * The `url` passed to [Socket::spawn]
     */
    fun `url`(): Url

    companion object
}

/**
 * A [`Socket`] manages the underlying WebSocket connection used to talk to Phoenix.
 *
 * It acts as the primary interface (along with [`Channel`]) for working with Phoenix Channels.
 *
 * When a client is created, it is disconnected, and must be explicitly connected via [`Self::connect`].
 * Once connected, a worker task is spawned that acts as the broker for messages being sent or
 * received over the socket.
 *
 * Once connected, the more useful [`Channel`] instance can be obtained via [`Self::channel`]. Most functionality
 * related to channels is exposed there.
 */
open class Socket :
    Disposable,
    AutoCloseable,
    SocketInterface {
    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (!this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(
        private val pointer: Pointer?,
    ) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_free_socket(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer =
        uniffiRustCall { status ->
            UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_clone_socket(pointer!!, status)
        }

    /**
     * Creates a new, unjoined Phoenix Channel
     */
    @Throws(SocketChannelException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `channel`(
        `topic`: Topic,
        `payload`: Payload?,
    ): Channel =
        uniffiRustCallAsync(
            callWithPointer { thisPtr ->
                UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_socket_channel(
                    thisPtr,
                    FfiConverterTypeTopic.lower(`topic`),
                    FfiConverterOptionalTypePayload.lower(`payload`),
                )
            },
            {
                    future,
                    callback,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_poll_pointer(future, callback, continuation)
            },
            { future, continuation -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_complete_pointer(future, continuation) },
            { future -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_free_pointer(future) },
            // lift function
            { FfiConverterTypeChannel.lift(it) },
            // Error FFI converter
            SocketChannelException.ErrorHandler,
        )

    /**
     * Connects this client to the configured Phoenix Channels endpoint
     *
     * This function must be called before using the client to join channels, etc.
     *
     * A join handle to the socket worker is returned, we can use this to wait until the worker
     * exits to ensure graceful termination. Otherwise, when the handle is dropped, it detaches the
     * worker from the task runtime (though it will continue to run in the background)
     */
    @Throws(ConnectException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `connect`(`timeout`: java.time.Duration) =
        uniffiRustCallAsync(
            callWithPointer { thisPtr ->
                UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_socket_connect(
                    thisPtr,
                    FfiConverterDuration.lower(`timeout`),
                )
            },
            {
                    future,
                    callback,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_poll_void(future, callback, continuation)
            },
            { future, continuation -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_complete_void(future, continuation) },
            { future -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_free_void(future) },
            // lift function
            { Unit },
            // Error FFI converter
            ConnectException.ErrorHandler,
        )

    /**
     * Disconnect the client, regardless of any outstanding channel references
     *
     * Connected channels will return `ChannelError::Closed` when next used.
     *
     * New channels will need to be obtained from this client after `connect` is
     * called again.
     */
    @Throws(DisconnectException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `disconnect`() =
        uniffiRustCallAsync(
            callWithPointer { thisPtr ->
                UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_socket_disconnect(
                    thisPtr,
                )
            },
            {
                    future,
                    callback,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_poll_void(future, callback, continuation)
            },
            { future, continuation -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_complete_void(future, continuation) },
            { future -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_free_void(future) },
            // lift function
            { Unit },
            // Error FFI converter
            DisconnectException.ErrorHandler,
        )

    /**
     * Propagates panic from async task.
     */
    @Throws(SocketShutdownException::class)
    @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
    override suspend fun `shutdown`() =
        uniffiRustCallAsync(
            callWithPointer { thisPtr ->
                UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_socket_shutdown(
                    thisPtr,
                )
            },
            {
                    future,
                    callback,
                    continuation,
                ->
                UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_poll_void(future, callback, continuation)
            },
            { future, continuation -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_complete_void(future, continuation) },
            { future -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_free_void(future) },
            // lift function
            { Unit },
            // Error FFI converter
            SocketShutdownException.ErrorHandler,
        )

    /**
     * The current [SocketStatus].
     *
     * Use [Socket::status] to receive changes to the status.
     */
    override fun `status`(): SocketStatus =
        FfiConverterTypeSocketStatus.lift(
            callWithPointer {
                uniffiRustCall { _status ->
                    UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_socket_status(
                        it,
                        _status,
                    )
                }
            },
        )

    /**
     * Broadcasts [Socket::status] changes.
     *
     * Use [Socket::status] to see the current status.
     */
    override fun `statuses`(): SocketStatuses =
        FfiConverterTypeSocketStatuses.lift(
            callWithPointer {
                uniffiRustCall { _status ->
                    UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_socket_statuses(
                        it,
                        _status,
                    )
                }
            },
        )

    /**
     * The `url` passed to [Socket::spawn]
     */
    override fun `url`(): Url =
        FfiConverterTypeUrl.lift(
            callWithPointer {
                uniffiRustCall { _status ->
                    UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_method_socket_url(
                        it,
                        _status,
                    )
                }
            },
        )

    companion object {
        /**
         * Spawns a new [Socket] that must be [Socket::connect]ed.
         */
        @Throws(SpawnException::class)
        @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
        suspend fun `spawn`(
            `url`: Url,
            `cookies`: List<kotlin.String>?,
        ): Socket =
            uniffiRustCallAsync(
                UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_constructor_socket_spawn(
                    FfiConverterTypeUrl.lower(`url`),
                    FfiConverterOptionalSequenceString.lower(`cookies`),
                ),
                {
                        future,
                        callback,
                        continuation,
                    ->
                    UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_poll_pointer(future, callback, continuation)
                },
                {
                        future,
                        continuation,
                    ->
                    UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_complete_pointer(future, continuation)
                },
                { future -> UniffiLib.INSTANCE.ffi_phoenix_channels_client_rust_future_free_pointer(future) },
                // lift function
                { FfiConverterTypeSocket.lift(it) },
                // Error FFI converter
                SpawnException.ErrorHandler,
            )
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeSocket : FfiConverter<Socket, Pointer> {
    override fun lower(value: Socket): Pointer = value.uniffiClonePointer()

    override fun lift(value: Pointer): Socket = Socket(value)

    override fun read(buf: ByteBuffer): Socket {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Socket) = 8UL

    override fun write(
        value: Socket,
        buf: ByteBuffer,
    ) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//

/**
 * A wrapper anound `observable_status::Statuses` because `uniffi` does not support generics
 */
public interface SocketStatusesInterface {
    companion object
}

/**
 * A wrapper anound `observable_status::Statuses` because `uniffi` does not support generics
 */
open class SocketStatuses :
    Disposable,
    AutoCloseable,
    SocketStatusesInterface {
    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (!this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(
        private val pointer: Pointer?,
    ) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_free_socketstatuses(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer =
        uniffiRustCall { status ->
            UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_clone_socketstatuses(pointer!!, status)
        }

    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSocketStatuses : FfiConverter<SocketStatuses, Pointer> {
    override fun lower(value: SocketStatuses): Pointer = value.uniffiClonePointer()

    override fun lift(value: Pointer): SocketStatuses = SocketStatuses(value)

    override fun read(buf: ByteBuffer): SocketStatuses {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: SocketStatuses) = 8UL

    override fun write(
        value: SocketStatuses,
        buf: ByteBuffer,
    ) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

// This template implements a class for working with a Rust struct via a Pointer/Arc<T>
// to the live Rust struct on the other side of the FFI.
//
// Each instance implements core operations for working with the Rust `Arc<T>` and the
// Kotlin Pointer to work with the live Rust struct on the other side of the FFI.
//
// There's some subtlety here, because we have to be careful not to operate on a Rust
// struct after it has been dropped, and because we must expose a public API for freeing
// theq Kotlin wrapper object in lieu of reliable finalizers. The core requirements are:
//
//   * Each instance holds an opaque pointer to the underlying Rust struct.
//     Method calls need to read this pointer from the object's state and pass it in to
//     the Rust FFI.
//
//   * When an instance is no longer needed, its pointer should be passed to a
//     special destructor function provided by the Rust FFI, which will drop the
//     underlying Rust struct.
//
//   * Given an instance, calling code is expected to call the special
//     `destroy` method in order to free it after use, either by calling it explicitly
//     or by using a higher-level helper like the `use` method. Failing to do so risks
//     leaking the underlying Rust struct.
//
//   * We can't assume that calling code will do the right thing, and must be prepared
//     to handle Kotlin method calls executing concurrently with or even after a call to
//     `destroy`, and to handle multiple (possibly concurrent!) calls to `destroy`.
//
//   * We must never allow Rust code to operate on the underlying Rust struct after
//     the destructor has been called, and must never call the destructor more than once.
//     Doing so may trigger memory unsafety.
//
//   * To mitigate many of the risks of leaking memory and use-after-free unsafety, a `Cleaner`
//     is implemented to call the destructor when the Kotlin object becomes unreachable.
//     This is done in a background thread. This is not a panacea, and client code should be aware that
//      1. the thread may starve if some there are objects that have poorly performing
//     `drop` methods or do significant work in their `drop` methods.
//      2. the thread is shared across the whole library. This can be tuned by using `android_cleaner = true`,
//         or `android = true` in the [`kotlin` section of the `uniffi.toml` file](https://mozilla.github.io/uniffi-rs/kotlin/configuration.html).
//
// If we try to implement this with mutual exclusion on access to the pointer, there is the
// possibility of a race between a method call and a concurrent call to `destroy`:
//
//    * Thread A starts a method call, reads the value of the pointer, but is interrupted
//      before it can pass the pointer over the FFI to Rust.
//    * Thread B calls `destroy` and frees the underlying Rust struct.
//    * Thread A resumes, passing the already-read pointer value to Rust and triggering
//      a use-after-free.
//
// One possible solution would be to use a `ReadWriteLock`, with each method call taking
// a read lock (and thus allowed to run concurrently) and the special `destroy` method
// taking a write lock (and thus blocking on live method calls). However, we aim not to
// generate methods with any hidden blocking semantics, and a `destroy` method that might
// block if called incorrectly seems to meet that bar.
//
// So, we achieve our goals by giving each instance an associated `AtomicLong` counter to track
// the number of in-flight method calls, and an `AtomicBoolean` flag to indicate whether `destroy`
// has been called. These are updated according to the following rules:
//
//    * The initial value of the counter is 1, indicating a live object with no in-flight calls.
//      The initial value for the flag is false.
//
//    * At the start of each method call, we atomically check the counter.
//      If it is 0 then the underlying Rust struct has already been destroyed and the call is aborted.
//      If it is nonzero them we atomically increment it by 1 and proceed with the method call.
//
//    * At the end of each method call, we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
//    * When `destroy` is called, we atomically flip the flag from false to true.
//      If the flag was already true we silently fail.
//      Otherwise we atomically decrement and check the counter.
//      If it has reached zero then we destroy the underlying Rust struct.
//
// Astute readers may observe that this all sounds very similar to the way that Rust's `Arc<T>` works,
// and indeed it is, with the addition of a flag to guard against multiple calls to `destroy`.
//
// The overall effect is that the underlying Rust struct is destroyed only when `destroy` has been
// called *and* all in-flight method calls have completed, avoiding violating any of the expectations
// of the underlying Rust code.
//
// This makes a cleaner a better alternative to _not_ calling `destroy()` as
// and when the object is finished with, but the abstraction is not perfect: if the Rust object's `drop`
// method is slow, and/or there are many objects to cleanup, and it's on a low end Android device, then the cleaner
// thread may be starved, and the app will leak memory.
//
// In this case, `destroy`ing manually may be a better solution.
//
// The cleaner can live side by side with the manual calling of `destroy`. In the order of responsiveness, uniffi objects
// with Rust peers are reclaimed:
//
// 1. By calling the `destroy` method of the object, which calls `rustObject.free()`. If that doesn't happen:
// 2. When the object becomes unreachable, AND the Cleaner thread gets to call `rustObject.free()`. If the thread is starved then:
// 3. The memory is reclaimed when the process terminates.
//
// [1] https://stackoverflow.com/questions/24376768/can-java-finalize-an-object-when-it-is-still-in-scope/24380219
//

/**
 * A [Channel](crate::Channel) topic.
 */
public interface TopicInterface {
    companion object
}

/**
 * A [Channel](crate::Channel) topic.
 */
open class Topic :
    Disposable,
    AutoCloseable,
    TopicInterface {
    constructor(pointer: Pointer) {
        this.pointer = pointer
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    /**
     * This constructor can be used to instantiate a fake object. Only used for tests. Any
     * attempt to actually use an object constructed this way will fail as there is no
     * connected Rust object.
     */
    @Suppress("UNUSED_PARAMETER")
    constructor(noPointer: NoPointer) {
        this.pointer = null
        this.cleanable = UniffiLib.CLEANER.register(this, UniffiCleanAction(pointer))
    }

    protected val pointer: Pointer?
    protected val cleanable: UniffiCleaner.Cleanable

    private val wasDestroyed = AtomicBoolean(false)
    private val callCounter = AtomicLong(1)

    override fun destroy() {
        // Only allow a single call to this method.
        // TODO: maybe we should log a warning if called more than once?
        if (this.wasDestroyed.compareAndSet(false, true)) {
            // This decrement always matches the initial count of 1 given at creation time.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    @Synchronized
    override fun close() {
        this.destroy()
    }

    internal inline fun <R> callWithPointer(block: (ptr: Pointer) -> R): R {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        do {
            val c = this.callCounter.get()
            if (c == 0L) {
                throw IllegalStateException("${this.javaClass.simpleName} object has already been destroyed")
            }
            if (c == Long.MAX_VALUE) {
                throw IllegalStateException("${this.javaClass.simpleName} call counter would overflow")
            }
        } while (!this.callCounter.compareAndSet(c, c + 1L))
        // Now we can safely do the method call without the pointer being freed concurrently.
        try {
            return block(this.uniffiClonePointer())
        } finally {
            // This decrement always matches the increment we performed above.
            if (this.callCounter.decrementAndGet() == 0L) {
                cleanable.clean()
            }
        }
    }

    // Use a static inner class instead of a closure so as not to accidentally
    // capture `this` as part of the cleanable's action.
    private class UniffiCleanAction(
        private val pointer: Pointer?,
    ) : Runnable {
        override fun run() {
            pointer?.let { ptr ->
                uniffiRustCall { status ->
                    UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_free_topic(ptr, status)
                }
            }
        }
    }

    fun uniffiClonePointer(): Pointer =
        uniffiRustCall { status ->
            UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_clone_topic(pointer!!, status)
        }

    companion object {
        /**
         * Create [Topic] from string.
         */
        fun `fromString`(`topic`: kotlin.String): Topic =
            FfiConverterTypeTopic.lift(
                uniffiRustCall { _status ->
                    UniffiLib.INSTANCE.uniffi_phoenix_channels_client_fn_constructor_topic_from_string(
                        FfiConverterString.lower(`topic`),
                        _status,
                    )
                },
            )
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeTopic : FfiConverter<Topic, Pointer> {
    override fun lower(value: Topic): Pointer = value.uniffiClonePointer()

    override fun lift(value: Pointer): Topic = Topic(value)

    override fun read(buf: ByteBuffer): Topic {
        // The Rust code always writes pointers as 8 bytes, and will
        // fail to compile if they don't fit.
        return lift(Pointer(buf.getLong()))
    }

    override fun allocationSize(value: Topic) = 8UL

    override fun write(
        value: Topic,
        buf: ByteBuffer,
    ) {
        // The Rust code always expects pointers written as 8 bytes,
        // and will fail to compile if they don't fit.
        buf.putLong(Pointer.nativeValue(lower(value)))
    }
}

/**
 * [tokio_tungstenite::tungstenite::protocol::frame::CloseFrame], but with `uniffi::support`
 * A struct representing the close command.
 */
data class CloseFrame(
    /**
     * The reason as a code.
     */
    var `code`: TungsteniteCloseCode,
    /**
     * The reason as text string.
     */
    var `reason`: kotlin.String,
) {
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeCloseFrame : FfiConverterRustBuffer<CloseFrame> {
    override fun read(buf: ByteBuffer): CloseFrame =
        CloseFrame(
            FfiConverterTypeTungsteniteCloseCode.read(buf),
            FfiConverterString.read(buf),
        )

    override fun allocationSize(value: CloseFrame) =
        (
            FfiConverterTypeTungsteniteCloseCode.allocationSize(value.`code`) +
                FfiConverterString.allocationSize(value.`reason`)
        )

    override fun write(
        value: CloseFrame,
        buf: ByteBuffer,
    ) {
        FfiConverterTypeTungsteniteCloseCode.write(value.`code`, buf)
        FfiConverterString.write(value.`reason`, buf)
    }
}

/**
 * The [EventPayload::event] sent by the server along with the [EventPayload::payload] for that
 * [EventPayload::event].
 */
data class EventPayload(
    /**
     * The [Event] name.
     */
    var `event`: Event,
    /**
     * The data sent for the [EventPayload::event].
     */
    var `payload`: Payload,
) {
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeEventPayload : FfiConverterRustBuffer<EventPayload> {
    override fun read(buf: ByteBuffer): EventPayload =
        EventPayload(
            FfiConverterTypeEvent.read(buf),
            FfiConverterTypePayload.read(buf),
        )

    override fun allocationSize(value: EventPayload) =
        (
            FfiConverterTypeEvent.allocationSize(value.`event`) +
                FfiConverterTypePayload.allocationSize(value.`payload`)
        )

    override fun write(
        value: EventPayload,
        buf: ByteBuffer,
    ) {
        FfiConverterTypeEvent.write(value.`event`, buf)
        FfiConverterTypePayload.write(value.`payload`, buf)
    }
}

/**
 * [tokio_tungstenite::tungstenite::protocol::frame::Frame], but with `uniffi` support.
 * A struct representing a WebSocket frame.
 */
data class Frame(
    var `header`: FrameHeader,
    var `payload`: kotlin.ByteArray,
) {
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFrame : FfiConverterRustBuffer<Frame> {
    override fun read(buf: ByteBuffer): Frame =
        Frame(
            FfiConverterTypeFrameHeader.read(buf),
            FfiConverterByteArray.read(buf),
        )

    override fun allocationSize(value: Frame) =
        (
            FfiConverterTypeFrameHeader.allocationSize(value.`header`) +
                FfiConverterByteArray.allocationSize(value.`payload`)
        )

    override fun write(
        value: Frame,
        buf: ByteBuffer,
    ) {
        FfiConverterTypeFrameHeader.write(value.`header`, buf)
        FfiConverterByteArray.write(value.`payload`, buf)
    }
}

/**
 * [tokio_tungstenite::tungstenite::protocol::frame::FrameHeader], but with `uniffi` support.
 * A struct representing a WebSocket frame header.
 */
data class FrameHeader(
    /**
     * Indicates that the frame is the last one of a possibly fragmented message.
     */
    var `isFinal`: kotlin.Boolean,
    /**
     * Reserved for protocol extensions.
     */
    var `rsv1`: kotlin.Boolean,
    /**
     * Reserved for protocol extensions.
     */
    var `rsv2`: kotlin.Boolean,
    /**
     * Reserved for protocol extensions.
     */
    var `rsv3`: kotlin.Boolean,
    /**
     * WebSocket protocol opcode.
     */
    var `opcode`: TungsteniteOpCode,
    /**
     * A frame mask, if any.
     */
    var `mask`: kotlin.ByteArray?,
) {
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeFrameHeader : FfiConverterRustBuffer<FrameHeader> {
    override fun read(buf: ByteBuffer): FrameHeader =
        FrameHeader(
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterBoolean.read(buf),
            FfiConverterTypeTungsteniteOpCode.read(buf),
            FfiConverterOptionalByteArray.read(buf),
        )

    override fun allocationSize(value: FrameHeader) =
        (
            FfiConverterBoolean.allocationSize(value.`isFinal`) +
                FfiConverterBoolean.allocationSize(value.`rsv1`) +
                FfiConverterBoolean.allocationSize(value.`rsv2`) +
                FfiConverterBoolean.allocationSize(value.`rsv3`) +
                FfiConverterTypeTungsteniteOpCode.allocationSize(value.`opcode`) +
                FfiConverterOptionalByteArray.allocationSize(value.`mask`)
        )

    override fun write(
        value: FrameHeader,
        buf: ByteBuffer,
    ) {
        FfiConverterBoolean.write(value.`isFinal`, buf)
        FfiConverterBoolean.write(value.`rsv1`, buf)
        FfiConverterBoolean.write(value.`rsv2`, buf)
        FfiConverterBoolean.write(value.`rsv3`, buf)
        FfiConverterTypeTungsteniteOpCode.write(value.`opcode`, buf)
        FfiConverterOptionalByteArray.write(value.`mask`, buf)
    }
}

data class Meta(
    var `joinReference`: kotlin.String,
    var `others`: Map<kotlin.String, Json>,
) {
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeMeta : FfiConverterRustBuffer<Meta> {
    override fun read(buf: ByteBuffer): Meta =
        Meta(
            FfiConverterString.read(buf),
            FfiConverterMapStringTypeJSON.read(buf),
        )

    override fun allocationSize(value: Meta) =
        (
            FfiConverterString.allocationSize(value.`joinReference`) +
                FfiConverterMapStringTypeJSON.allocationSize(value.`others`)
        )

    override fun write(
        value: Meta,
        buf: ByteBuffer,
    ) {
        FfiConverterString.write(value.`joinReference`, buf)
        FfiConverterMapStringTypeJSON.write(value.`others`, buf)
    }
}

/**
 * A Presence tracks connections to a [Channel](crate::Channel), such as users in a chat room.
 */
data class Presence(
    /**
     * Meta data about this presence
     */
    var `metas`: List<Meta>,
) {
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePresence : FfiConverterRustBuffer<Presence> {
    override fun read(buf: ByteBuffer): Presence =
        Presence(
            FfiConverterSequenceTypeMeta.read(buf),
        )

    override fun allocationSize(value: Presence) =
        (
            FfiConverterSequenceTypeMeta.allocationSize(value.`metas`)
        )

    override fun write(
        value: Presence,
        buf: ByteBuffer,
    ) {
        FfiConverterSequenceTypeMeta.write(value.`metas`, buf)
    }
}

/**
 * When a join occurs on a channel.
 */
data class PresencesJoin(
    /**
     * The key used to group multiple [Presence] together, such as the user name when tracking all connection one
     * user has to the same chat room, such as from multiple devices or multiple browser tabs.
     */
    var `key`: kotlin.String,
    /**
     * The `key`'s [Presence] before this join occurred.
     */
    var `current`: Presence?,
    /**
     * The `key`'s updated [Presence] due to this join.
     */
    var `joined`: Presence,
) {
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePresencesJoin : FfiConverterRustBuffer<PresencesJoin> {
    override fun read(buf: ByteBuffer): PresencesJoin =
        PresencesJoin(
            FfiConverterString.read(buf),
            FfiConverterOptionalTypePresence.read(buf),
            FfiConverterTypePresence.read(buf),
        )

    override fun allocationSize(value: PresencesJoin) =
        (
            FfiConverterString.allocationSize(value.`key`) +
                FfiConverterOptionalTypePresence.allocationSize(value.`current`) +
                FfiConverterTypePresence.allocationSize(value.`joined`)
        )

    override fun write(
        value: PresencesJoin,
        buf: ByteBuffer,
    ) {
        FfiConverterString.write(value.`key`, buf)
        FfiConverterOptionalTypePresence.write(value.`current`, buf)
        FfiConverterTypePresence.write(value.`joined`, buf)
    }
}

/**
 * When a leave occurs on a channel.
 */
data class PresencesLeave(
    /**
     * The key used to group multiple [Presence] together, such as the user name when tracking all connection one
     * user has to the same chat room, such as from multiple devices or multiple browser tabs.
     */
    var `key`: kotlin.String,
    /**
     * The `key`'s [Presence] before this leave occurred.
     */
    var `current`: Presence,
    /**
     * The `key`'s updated [Presence] due to this leave.
     */
    var `left`: Presence,
) {
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePresencesLeave : FfiConverterRustBuffer<PresencesLeave> {
    override fun read(buf: ByteBuffer): PresencesLeave =
        PresencesLeave(
            FfiConverterString.read(buf),
            FfiConverterTypePresence.read(buf),
            FfiConverterTypePresence.read(buf),
        )

    override fun allocationSize(value: PresencesLeave) =
        (
            FfiConverterString.allocationSize(value.`key`) +
                FfiConverterTypePresence.allocationSize(value.`current`) +
                FfiConverterTypePresence.allocationSize(value.`left`)
        )

    override fun write(
        value: PresencesLeave,
        buf: ByteBuffer,
    ) {
        FfiConverterString.write(value.`key`, buf)
        FfiConverterTypePresence.write(value.`current`, buf)
        FfiConverterTypePresence.write(value.`left`, buf)
    }
}

/**
 * [http::response::Response], but without the generics that `uniffi` does not support and with `uniffi` support
 */
data class Response(
    var `statusCode`: kotlin.UShort,
    var `headers`: Map<kotlin.String, List<kotlin.String>>,
    var `body`: kotlin.ByteArray?,
) {
    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeResponse : FfiConverterRustBuffer<Response> {
    override fun read(buf: ByteBuffer): Response =
        Response(
            FfiConverterUShort.read(buf),
            FfiConverterMapStringSequenceString.read(buf),
            FfiConverterOptionalByteArray.read(buf),
        )

    override fun allocationSize(value: Response) =
        (
            FfiConverterUShort.allocationSize(value.`statusCode`) +
                FfiConverterMapStringSequenceString.allocationSize(value.`headers`) +
                FfiConverterOptionalByteArray.allocationSize(value.`body`)
        )

    override fun write(
        value: Response,
        buf: ByteBuffer,
    ) {
        FfiConverterUShort.write(value.`statusCode`, buf)
        FfiConverterMapStringSequenceString.write(value.`headers`, buf)
        FfiConverterOptionalByteArray.write(value.`body`, buf)
    }
}

/**
 * Errors when calling [Channel::call].
 */
sealed class CallException : kotlin.Exception() {
    /**
     * The async task for the [Channel] was already joined by another call, so the [Result] or
     * panic from the async task can't be reported here.
     */
    class Shutdown : CallException() {
        override val message
            get() = ""
    }

    /**
     * Error from [Socket::shutdown](crate::Socket::shutdown) or from the server itself that caused
     * the [Socket](crate::Socket) to shutdown.
     */
    class SocketShutdown(
        /**
         * Error from [Socket::shutdown](crate::Socket::shutdown) or from the server itself that
         * caused the [Socket](crate::Socket) to shutdown.
         */
        val `socketShutdownError`: SocketShutdownException,
    ) : CallException() {
        override val message
            get() = "socketShutdownError=${ `socketShutdownError` }"
    }

    /**
     * Timeout passed to [Channel::call] has expired.
     */
    class Timeout : CallException() {
        override val message
            get() = ""
    }

    /**
     * Error from [Channel]'s [Socket](crate::Socket)'s underlying
     * [tokio_tungstenite::tungstenite::protocol::WebSocket].
     */
    class WebSocket(
        /**
         * Error from [Channel]'s [Socket](crate::Socket)'s underlying
         * [tokio_tungstenite::tungstenite::protocol::WebSocket].
         */
        val `webSocketError`: WebSocketException,
    ) : CallException() {
        override val message
            get() = "webSocketError=${ `webSocketError` }"
    }

    /**
     * [Socket::disconnect](crate::Socket::disconnect) called after [Channel::call] while waiting
     * for a reply from the server.
     */
    class SocketDisconnected : CallException() {
        override val message
            get() = ""
    }

    /**
     * An error was returned from the server in reply to [Channel::call]'s `event` and `payload`.
     */
    class Reply(
        /**
         * Error response from the server.
         */
        val `reply`: Payload,
    ) : CallException() {
        override val message
            get() = "reply=${ `reply` }"
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<CallException> {
        override fun lift(error_buf: RustBuffer.ByValue): CallException = FfiConverterTypeCallError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeCallError : FfiConverterRustBuffer<CallException> {
    override fun read(buf: ByteBuffer): CallException =
        when (buf.getInt()) {
            1 -> CallException.Shutdown()
            2 ->
                CallException.SocketShutdown(
                    FfiConverterTypeSocketShutdownError.read(buf),
                )
            3 -> CallException.Timeout()
            4 ->
                CallException.WebSocket(
                    FfiConverterTypeWebSocketError.read(buf),
                )
            5 -> CallException.SocketDisconnected()
            6 ->
                CallException.Reply(
                    FfiConverterTypePayload.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: CallException): ULong =
        when (value) {
            is CallException.Shutdown -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is CallException.SocketShutdown -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeSocketShutdownError.allocationSize(value.`socketShutdownError`)
            )
            is CallException.Timeout -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is CallException.WebSocket -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeWebSocketError.allocationSize(value.`webSocketError`)
            )
            is CallException.SocketDisconnected -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is CallException.Reply -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypePayload.allocationSize(value.`reply`)
            )
        }

    override fun write(
        value: CallException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is CallException.Shutdown -> {
                buf.putInt(1)
                Unit
            }
            is CallException.SocketShutdown -> {
                buf.putInt(2)
                FfiConverterTypeSocketShutdownError.write(value.`socketShutdownError`, buf)
                Unit
            }
            is CallException.Timeout -> {
                buf.putInt(3)
                Unit
            }
            is CallException.WebSocket -> {
                buf.putInt(4)
                FfiConverterTypeWebSocketError.write(value.`webSocketError`, buf)
                Unit
            }
            is CallException.SocketDisconnected -> {
                buf.putInt(5)
                Unit
            }
            is CallException.Reply -> {
                buf.putInt(6)
                FfiConverterTypePayload.write(value.`reply`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * [tungstenite::error::CapacityError], but with `uniffi` support.
 * Indicates the specific type/cause of a capacity error.
 */
sealed class CapacityException : kotlin.Exception() {
    /**
     * Too many headers provided (see [`httparse::Error::TooManyHeaders`]).
     */
    class TooManyHeaders : CapacityException() {
        override val message
            get() = ""
    }

    /**
     * Received header is too long.
     * Message is bigger than the maximum allowed size.
     */
    class MessageTooLong(
        /**
         * The size of the message.
         */
        val `size`: kotlin.ULong,
        /**
         * The maximum allowed message size.
         */
        val `maxSize`: kotlin.ULong,
    ) : CapacityException() {
        override val message
            get() = "size=${ `size` }, maxSize=${ `maxSize` }"
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<CapacityException> {
        override fun lift(error_buf: RustBuffer.ByValue): CapacityException = FfiConverterTypeCapacityError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeCapacityError : FfiConverterRustBuffer<CapacityException> {
    override fun read(buf: ByteBuffer): CapacityException =
        when (buf.getInt()) {
            1 -> CapacityException.TooManyHeaders()
            2 ->
                CapacityException.MessageTooLong(
                    FfiConverterULong.read(buf),
                    FfiConverterULong.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: CapacityException): ULong =
        when (value) {
            is CapacityException.TooManyHeaders -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is CapacityException.MessageTooLong -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterULong.allocationSize(value.`size`) +
                    FfiConverterULong.allocationSize(value.`maxSize`)
            )
        }

    override fun write(
        value: CapacityException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is CapacityException.TooManyHeaders -> {
                buf.putInt(1)
                Unit
            }
            is CapacityException.MessageTooLong -> {
                buf.putInt(2)
                FfiConverterULong.write(value.`size`, buf)
                FfiConverterULong.write(value.`maxSize`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * Errors when calling [Channel::cast].
 */
sealed class CastException : kotlin.Exception() {
    /**
     * The async task for the [Channel] was already joined by another call, so the [Result] or
     * panic from the async task can't be reported here.
     */
    class Shutdown : CastException() {
        override val message
            get() = ""
    }

    /**
     * The async task for the [Socket] was already joined by another call, so the [Result] or panic
     * from the async task can't be reported here.
     */
    class SocketShutdown : CastException() {
        override val message
            get() = ""
    }

    /**
     * [tokio_tungstenite::tungstenite::error::UrlError] with the `url` passed to [Socket::spawn].  This can include
     * incorrect scheme ([tokio_tungstenite::tungstenite::error::UrlError::UnsupportedUrlScheme]).
     */
    class Url(
        val `urlError`: kotlin.String,
    ) : CastException() {
        override val message
            get() = "urlError=${ `urlError` }"
    }

    /**
     * HTTP error response from server.
     */
    class Http(
        val `response`: Response,
    ) : CastException() {
        override val message
            get() = "response=${ `response` }"
    }

    /**
     * HTTP format error.
     */
    class HttpFormat(
        val `error`: HttpException,
    ) : CastException() {
        override val message
            get() = "error=${ `error` }"
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<CastException> {
        override fun lift(error_buf: RustBuffer.ByValue): CastException = FfiConverterTypeCastError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeCastError : FfiConverterRustBuffer<CastException> {
    override fun read(buf: ByteBuffer): CastException =
        when (buf.getInt()) {
            1 -> CastException.Shutdown()
            2 -> CastException.SocketShutdown()
            3 ->
                CastException.Url(
                    FfiConverterString.read(buf),
                )
            4 ->
                CastException.Http(
                    FfiConverterTypeResponse.read(buf),
                )
            5 ->
                CastException.HttpFormat(
                    FfiConverterTypeHttpError.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: CastException): ULong =
        when (value) {
            is CastException.Shutdown -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is CastException.SocketShutdown -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is CastException.Url -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterString.allocationSize(value.`urlError`)
            )
            is CastException.Http -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeResponse.allocationSize(value.`response`)
            )
            is CastException.HttpFormat -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeHttpError.allocationSize(value.`error`)
            )
        }

    override fun write(
        value: CastException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is CastException.Shutdown -> {
                buf.putInt(1)
                Unit
            }
            is CastException.SocketShutdown -> {
                buf.putInt(2)
                Unit
            }
            is CastException.Url -> {
                buf.putInt(3)
                FfiConverterString.write(value.`urlError`, buf)
                Unit
            }
            is CastException.Http -> {
                buf.putInt(4)
                FfiConverterTypeResponse.write(value.`response`, buf)
                Unit
            }
            is CastException.HttpFormat -> {
                buf.putInt(5)
                FfiConverterTypeHttpError.write(value.`error`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * Errors returned by [Channel] functions.
 */
sealed class ChannelException : kotlin.Exception() {
    /**
     * Errors when calling [Channel::join].
     */
    class Join(
        /**
         * Errors when calling [Channel::join].
         */
        val `join`: ChannelJoinException,
    ) : ChannelException() {
        override val message
            get() = "join=${ `join` }"
    }

    /**
     * Errors when calling [Channel::cast].
     */
    class Cast(
        /**
         * Errors when calling [Channel::cast].
         */
        val `cast`: CastException,
    ) : ChannelException() {
        override val message
            get() = "cast=${ `cast` }"
    }

    /**
     * Errors when calling [Channel::call].
     */
    class Call(
        /**
         * Errors when calling [Channel::call].
         */
        val `call`: CallException,
    ) : ChannelException() {
        override val message
            get() = "call=${ `call` }"
    }

    /**
     * Errors when calling [Channel::leave].
     */
    class Leave(
        /**
         * Errors when calling [Channel::leave].
         */
        val `leave`: LeaveException,
    ) : ChannelException() {
        override val message
            get() = "leave=${ `leave` }"
    }

    /**
     * Errors when calling [Channel::shutdown].
     */
    class Shutdown(
        /**
         * Errors when calling [Channel::shutdown].
         */
        val `shutdown`: ChannelShutdownException,
    ) : ChannelException() {
        override val message
            get() = "shutdown=${ `shutdown` }"
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<ChannelException> {
        override fun lift(error_buf: RustBuffer.ByValue): ChannelException = FfiConverterTypeChannelError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeChannelError : FfiConverterRustBuffer<ChannelException> {
    override fun read(buf: ByteBuffer): ChannelException =
        when (buf.getInt()) {
            1 ->
                ChannelException.Join(
                    FfiConverterTypeChannelJoinError.read(buf),
                )
            2 ->
                ChannelException.Cast(
                    FfiConverterTypeCastError.read(buf),
                )
            3 ->
                ChannelException.Call(
                    FfiConverterTypeCallError.read(buf),
                )
            4 ->
                ChannelException.Leave(
                    FfiConverterTypeLeaveError.read(buf),
                )
            5 ->
                ChannelException.Shutdown(
                    FfiConverterTypeChannelShutdownError.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: ChannelException): ULong =
        when (value) {
            is ChannelException.Join -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeChannelJoinError.allocationSize(value.`join`)
            )
            is ChannelException.Cast -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeCastError.allocationSize(value.`cast`)
            )
            is ChannelException.Call -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeCallError.allocationSize(value.`call`)
            )
            is ChannelException.Leave -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeLeaveError.allocationSize(value.`leave`)
            )
            is ChannelException.Shutdown -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeChannelShutdownError.allocationSize(value.`shutdown`)
            )
        }

    override fun write(
        value: ChannelException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is ChannelException.Join -> {
                buf.putInt(1)
                FfiConverterTypeChannelJoinError.write(value.`join`, buf)
                Unit
            }
            is ChannelException.Cast -> {
                buf.putInt(2)
                FfiConverterTypeCastError.write(value.`cast`, buf)
                Unit
            }
            is ChannelException.Call -> {
                buf.putInt(3)
                FfiConverterTypeCallError.write(value.`call`, buf)
                Unit
            }
            is ChannelException.Leave -> {
                buf.putInt(4)
                FfiConverterTypeLeaveError.write(value.`leave`, buf)
                Unit
            }
            is ChannelException.Shutdown -> {
                buf.putInt(5)
                FfiConverterTypeChannelShutdownError.write(value.`shutdown`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * Errors when calling [Channel::join].
 */
sealed class ChannelJoinException : kotlin.Exception() {
    /**
     * Timeout joining channel
     */
    class Timeout : ChannelJoinException() {
        override val message
            get() = ""
    }

    /**
     * [Channel] shutting down because [Channel::shutdown] was called.
     */
    class ShuttingDown : ChannelJoinException() {
        override val message
            get() = ""
    }

    /**
     * The async task was already joined by another call, so the [Result] or panic from the async
     * task can't be reported here.
     */
    class Shutdown : ChannelJoinException() {
        override val message
            get() = ""
    }

    /**
     * The [Socket](crate::Socket) the channel is on shutdown
     */
    class SocketShutdown(
        /**
         * The error that shutdown the [Socket](crate::Socket)
         */
        val `socketShutdownError`: SocketShutdownException,
    ) : ChannelJoinException() {
        override val message
            get() = "socketShutdownError=${ `socketShutdownError` }"
    }

    /**
     * The [Socket](crate::Socket) was disconnected after [Channel::join] was called while waiting
     * for a response from the server.
     */
    class SocketDisconnected : ChannelJoinException() {
        override val message
            get() = ""
    }

    /**
     * [Channel::leave] was called while awaiting a response from the server to a previous
     * [Channel::join]
     */
    class LeavingWhileJoining : ChannelJoinException() {
        override val message
            get() = ""
    }

    /**
     * The [Channel] is currently waiting `until` [SystemTime] to rejoin to not overload the
     * server, so can't honor the explicit [Channel::join].
     */
    class WaitingToRejoin(
        /**
         * When the [Channel] will rejoin.
         */
        val `until`: java.time.Instant,
    ) : ChannelJoinException() {
        override val message
            get() = "until=${ `until` }"
    }

    /**
     * The [Channel::payload] was rejected when attempting to [Channel::join] or automatically
     * rejoin [Channel::topic].
     */
    class Rejected(
        /**
         * Rejection server sent when attempting to join the [Channel].
         */
        val `rejection`: Payload,
    ) : ChannelJoinException() {
        override val message
            get() = "rejection=${ `rejection` }"
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<ChannelJoinException> {
        override fun lift(error_buf: RustBuffer.ByValue): ChannelJoinException = FfiConverterTypeChannelJoinError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeChannelJoinError : FfiConverterRustBuffer<ChannelJoinException> {
    override fun read(buf: ByteBuffer): ChannelJoinException =
        when (buf.getInt()) {
            1 -> ChannelJoinException.Timeout()
            2 -> ChannelJoinException.ShuttingDown()
            3 -> ChannelJoinException.Shutdown()
            4 ->
                ChannelJoinException.SocketShutdown(
                    FfiConverterTypeSocketShutdownError.read(buf),
                )
            5 -> ChannelJoinException.SocketDisconnected()
            6 -> ChannelJoinException.LeavingWhileJoining()
            7 ->
                ChannelJoinException.WaitingToRejoin(
                    FfiConverterTimestamp.read(buf),
                )
            8 ->
                ChannelJoinException.Rejected(
                    FfiConverterTypePayload.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: ChannelJoinException): ULong =
        when (value) {
            is ChannelJoinException.Timeout -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ChannelJoinException.ShuttingDown -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ChannelJoinException.Shutdown -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ChannelJoinException.SocketShutdown -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeSocketShutdownError.allocationSize(value.`socketShutdownError`)
            )
            is ChannelJoinException.SocketDisconnected -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ChannelJoinException.LeavingWhileJoining -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ChannelJoinException.WaitingToRejoin -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTimestamp.allocationSize(value.`until`)
            )
            is ChannelJoinException.Rejected -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypePayload.allocationSize(value.`rejection`)
            )
        }

    override fun write(
        value: ChannelJoinException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is ChannelJoinException.Timeout -> {
                buf.putInt(1)
                Unit
            }
            is ChannelJoinException.ShuttingDown -> {
                buf.putInt(2)
                Unit
            }
            is ChannelJoinException.Shutdown -> {
                buf.putInt(3)
                Unit
            }
            is ChannelJoinException.SocketShutdown -> {
                buf.putInt(4)
                FfiConverterTypeSocketShutdownError.write(value.`socketShutdownError`, buf)
                Unit
            }
            is ChannelJoinException.SocketDisconnected -> {
                buf.putInt(5)
                Unit
            }
            is ChannelJoinException.LeavingWhileJoining -> {
                buf.putInt(6)
                Unit
            }
            is ChannelJoinException.WaitingToRejoin -> {
                buf.putInt(7)
                FfiConverterTimestamp.write(value.`until`, buf)
                Unit
            }
            is ChannelJoinException.Rejected -> {
                buf.putInt(8)
                FfiConverterTypePayload.write(value.`rejection`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

sealed class ChannelShutdownException : kotlin.Exception() {
    class SocketShutdown : ChannelShutdownException() {
        override val message
            get() = ""
    }

    class AlreadyJoined : ChannelShutdownException() {
        override val message
            get() = ""
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<ChannelShutdownException> {
        override fun lift(error_buf: RustBuffer.ByValue): ChannelShutdownException = FfiConverterTypeChannelShutdownError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeChannelShutdownError : FfiConverterRustBuffer<ChannelShutdownException> {
    override fun read(buf: ByteBuffer): ChannelShutdownException =
        when (buf.getInt()) {
            1 -> ChannelShutdownException.SocketShutdown()
            2 -> ChannelShutdownException.AlreadyJoined()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: ChannelShutdownException): ULong =
        when (value) {
            is ChannelShutdownException.SocketShutdown -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ChannelShutdownException.AlreadyJoined -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
        }

    override fun write(
        value: ChannelShutdownException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is ChannelShutdownException.SocketShutdown -> {
                buf.putInt(1)
                Unit
            }
            is ChannelShutdownException.AlreadyJoined -> {
                buf.putInt(2)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * The status of the [Channel].
 */
sealed class ChannelStatus {
    /**
     * [Channel] is waiting for the [Socket](crate::Socket) to
     * [Socket::connect](crate::Socket::connect) or automatically reconnect.
     */
    object WaitingForSocketToConnect : ChannelStatus()

    /**
     * [Socket::status](crate::Socket::status) is
     * [SocketStatus::Connected](crate::SocketStatus::Connected) and [Channel] is waiting for
     * [Channel::join] to be called.
     */
    object WaitingToJoin : ChannelStatus()

    /**
     * [Channel::join] was called and awaiting response from server.
     */
    object Joining : ChannelStatus()

    /**
     * [Channel::join] was called previously, but the [Socket](crate::Socket) was disconnected and
     * reconnected.
     */
    data class WaitingToRejoin(
        /**
         * When the [Channel] will automatically [Channel::join].
         */
        val `until`: java.time.Instant,
    ) : ChannelStatus() {
        companion object
    }

    /**
     * [Channel::join] was called and the server responded that the [Channel::topic] was joined
     * using [Channel::payload].
     */
    object Joined : ChannelStatus()

    /**
     * [Channel::leave] was called and awaiting response from server.
     */
    object Leaving : ChannelStatus()

    /**
     * [Channel::leave] was called and the server responded that the [Channel::topic] was left.
     */
    object Left : ChannelStatus()

    /**
     * [Channel::shutdown] was called, but the async task hasn't exited yet.
     */
    object ShuttingDown : ChannelStatus()

    /**
     * The async task has exited.
     */
    object ShutDown : ChannelStatus()

    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeChannelStatus : FfiConverterRustBuffer<ChannelStatus> {
    override fun read(buf: ByteBuffer): ChannelStatus =
        when (buf.getInt()) {
            1 -> ChannelStatus.WaitingForSocketToConnect
            2 -> ChannelStatus.WaitingToJoin
            3 -> ChannelStatus.Joining
            4 ->
                ChannelStatus.WaitingToRejoin(
                    FfiConverterTimestamp.read(buf),
                )
            5 -> ChannelStatus.Joined
            6 -> ChannelStatus.Leaving
            7 -> ChannelStatus.Left
            8 -> ChannelStatus.ShuttingDown
            9 -> ChannelStatus.ShutDown
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }

    override fun allocationSize(value: ChannelStatus) =
        when (value) {
            is ChannelStatus.WaitingForSocketToConnect -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is ChannelStatus.WaitingToJoin -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is ChannelStatus.Joining -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is ChannelStatus.WaitingToRejoin -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterTimestamp.allocationSize(value.`until`)
                )
            }
            is ChannelStatus.Joined -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is ChannelStatus.Leaving -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is ChannelStatus.Left -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is ChannelStatus.ShuttingDown -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is ChannelStatus.ShutDown -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
        }

    override fun write(
        value: ChannelStatus,
        buf: ByteBuffer,
    ) {
        when (value) {
            is ChannelStatus.WaitingForSocketToConnect -> {
                buf.putInt(1)
                Unit
            }
            is ChannelStatus.WaitingToJoin -> {
                buf.putInt(2)
                Unit
            }
            is ChannelStatus.Joining -> {
                buf.putInt(3)
                Unit
            }
            is ChannelStatus.WaitingToRejoin -> {
                buf.putInt(4)
                FfiConverterTimestamp.write(value.`until`, buf)
                Unit
            }
            is ChannelStatus.Joined -> {
                buf.putInt(5)
                Unit
            }
            is ChannelStatus.Leaving -> {
                buf.putInt(6)
                Unit
            }
            is ChannelStatus.Left -> {
                buf.putInt(7)
                Unit
            }
            is ChannelStatus.ShuttingDown -> {
                buf.putInt(8)
                Unit
            }
            is ChannelStatus.ShutDown -> {
                buf.putInt(9)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * Errors when calling [Channel::join](super::Channel::join).
 */
sealed class ChannelStatusJoinException : kotlin.Exception() {
    /**
     * The [Channel::payload](super::Channel::payload) was rejected when attempting to
     * [Channel::join](super::Channel::join) or automatically rejoin
     * [Channel::topic](super::Channel::topic).
     */
    class Rejected(
        /**
         * Error response from the serrve.
         */
        val `response`: Payload,
    ) : ChannelStatusJoinException() {
        override val message
            get() = "response=${ `response` }"
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<ChannelStatusJoinException> {
        override fun lift(error_buf: RustBuffer.ByValue): ChannelStatusJoinException =
            FfiConverterTypeChannelStatusJoinError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeChannelStatusJoinError : FfiConverterRustBuffer<ChannelStatusJoinException> {
    override fun read(buf: ByteBuffer): ChannelStatusJoinException =
        when (buf.getInt()) {
            1 ->
                ChannelStatusJoinException.Rejected(
                    FfiConverterTypePayload.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: ChannelStatusJoinException): ULong =
        when (value) {
            is ChannelStatusJoinException.Rejected -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypePayload.allocationSize(value.`response`)
            )
        }

    override fun write(
        value: ChannelStatusJoinException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is ChannelStatusJoinException.Rejected -> {
                buf.putInt(1)
                FfiConverterTypePayload.write(value.`response`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * Errors from [Socket::connect].
 */
sealed class ConnectException(
    message: String,
) : kotlin.Exception(message) {
    /**
     * Server did not respond before timeout passed to [Socket::connect] expired.
     */
    class Timeout(
        message: String,
    ) : ConnectException(message)

    /**
     * Error from the underlying
     * [tokio_tungstenite::tungstenite::protocol::WebSocket].
     */
    class WebSocket(
        message: String,
    ) : ConnectException(message)

    /**
     * [Socket] shutting down because [Socket::shutdown] was called.
     */
    class ShuttingDown(
        message: String,
    ) : ConnectException(message)

    /**
     * Error from [Socket::shutdown] or from the server itself that caused the [Socket] to shutdown.
     */
    class Shutdown(
        message: String,
    ) : ConnectException(message)

    /**
     * The [Socket] is currently waiting until [Instant] to reconnect to not overload the server,
     * so can't honor the explicit [Socket::connect].
     */
    class WaitingToReconnect(
        message: String,
    ) : ConnectException(message)

    /**
     * These are TLS errors.
     */
    class Tls(
        message: String,
    ) : ConnectException(message)

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<ConnectException> {
        override fun lift(error_buf: RustBuffer.ByValue): ConnectException = FfiConverterTypeConnectError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeConnectError : FfiConverterRustBuffer<ConnectException> {
    override fun read(buf: ByteBuffer): ConnectException =
        when (buf.getInt()) {
            1 -> ConnectException.Timeout(FfiConverterString.read(buf))
            2 -> ConnectException.WebSocket(FfiConverterString.read(buf))
            3 -> ConnectException.ShuttingDown(FfiConverterString.read(buf))
            4 -> ConnectException.Shutdown(FfiConverterString.read(buf))
            5 -> ConnectException.WaitingToReconnect(FfiConverterString.read(buf))
            6 -> ConnectException.Tls(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: ConnectException): ULong = 4UL

    override fun write(
        value: ConnectException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is ConnectException.Timeout -> {
                buf.putInt(1)
                Unit
            }
            is ConnectException.WebSocket -> {
                buf.putInt(2)
                Unit
            }
            is ConnectException.ShuttingDown -> {
                buf.putInt(3)
                Unit
            }
            is ConnectException.Shutdown -> {
                buf.putInt(4)
                Unit
            }
            is ConnectException.WaitingToReconnect -> {
                buf.putInt(5)
                Unit
            }
            is ConnectException.Tls -> {
                buf.putInt(6)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * Error when calling [Socket::disconnect]
 */
sealed class DisconnectException : kotlin.Exception() {
    class Shutdown(
        val `shutdownError`: SocketShutdownException,
    ) : DisconnectException() {
        override val message
            get() = "shutdownError=${ `shutdownError` }"
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<DisconnectException> {
        override fun lift(error_buf: RustBuffer.ByValue): DisconnectException = FfiConverterTypeDisconnectError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeDisconnectError : FfiConverterRustBuffer<DisconnectException> {
    override fun read(buf: ByteBuffer): DisconnectException =
        when (buf.getInt()) {
            1 ->
                DisconnectException.Shutdown(
                    FfiConverterTypeSocketShutdownError.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: DisconnectException): ULong =
        when (value) {
            is DisconnectException.Shutdown -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeSocketShutdownError.allocationSize(value.`shutdownError`)
            )
        }

    override fun write(
        value: DisconnectException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is DisconnectException.Shutdown -> {
                buf.putInt(1)
                FfiConverterTypeSocketShutdownError.write(value.`shutdownError`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * This is a strongly typed wrapper around the event associated with a `Message`.
 *
 * We discriminate between special Phoenix events and user-defined events, as they have slightly
 * different semantics. Generally speaking, Phoenix events are not exposed to users, and are not
 * permitted to be sent by them either.
 */
sealed class Event {
    /**
     * Represents one of the built-in Phoenix channel events, e.g. join
     */
    data class Phoenix(
        /**
         * The built-in event name
         */
        val `phoenix`: PhoenixEvent,
    ) : Event() {
        companion object
    }

    /**
     * Represents a user-defined event
     */
    data class User(
        /**
         * The user-defined event name
         */
        val `user`: kotlin.String,
    ) : Event() {
        companion object
    }

    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeEvent : FfiConverterRustBuffer<Event> {
    override fun read(buf: ByteBuffer): Event =
        when (buf.getInt()) {
            1 ->
                Event.Phoenix(
                    FfiConverterTypePhoenixEvent.read(buf),
                )
            2 ->
                Event.User(
                    FfiConverterString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }

    override fun allocationSize(value: Event) =
        when (value) {
            is Event.Phoenix -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterTypePhoenixEvent.allocationSize(value.`phoenix`)
                )
            }
            is Event.User -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterString.allocationSize(value.`user`)
                )
            }
        }

    override fun write(
        value: Event,
        buf: ByteBuffer,
    ) {
        when (value) {
            is Event.Phoenix -> {
                buf.putInt(1)
                FfiConverterTypePhoenixEvent.write(value.`phoenix`, buf)
                Unit
            }
            is Event.User -> {
                buf.putInt(2)
                FfiConverterString.write(value.`user`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * Errors when calling [Events::event].
 */
sealed class EventsException : kotlin.Exception() {
    /**
     * There are no more events because the [Channel] shutdown.
     */
    class NoMoreEvents : EventsException() {
        override val message
            get() = ""
    }

    /**
     * [Events::event] wasn't called often enough and some [EventPayload] won't be sent to not
     * block the other receivers or the sender.  Call [Events::event] to catch up and get the next
     * [EventPayload].
     */
    class MissedEvents(
        /**
         * How many [EventPayload] were missed.
         */
        val `missedEventCount`: kotlin.ULong,
    ) : EventsException() {
        override val message
            get() = "missedEventCount=${ `missedEventCount` }"
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<EventsException> {
        override fun lift(error_buf: RustBuffer.ByValue): EventsException = FfiConverterTypeEventsError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeEventsError : FfiConverterRustBuffer<EventsException> {
    override fun read(buf: ByteBuffer): EventsException =
        when (buf.getInt()) {
            1 -> EventsException.NoMoreEvents()
            2 ->
                EventsException.MissedEvents(
                    FfiConverterULong.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: EventsException): ULong =
        when (value) {
            is EventsException.NoMoreEvents -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is EventsException.MissedEvents -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterULong.allocationSize(value.`missedEventCount`)
            )
        }

    override fun write(
        value: EventsException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is EventsException.NoMoreEvents -> {
                buf.putInt(1)
                Unit
            }
            is EventsException.MissedEvents -> {
                buf.putInt(2)
                FfiConverterULong.write(value.`missedEventCount`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * [httparse::Error], but with `uniffi` support
 * An error in parsing.
 */
sealed class HttParseException : kotlin.Exception() {
    /**
     * Invalid byte in header name.
     */
    class HeaderName : HttParseException() {
        override val message
            get() = ""
    }

    /**
     * Invalid byte in header value.
     */
    class HeaderValue : HttParseException() {
        override val message
            get() = ""
    }

    /**
     * Invalid byte in new line.
     */
    class NewLine : HttParseException() {
        override val message
            get() = ""
    }

    /**
     * Invalid byte in Response status.
     */
    class Status : HttParseException() {
        override val message
            get() = ""
    }

    /**
     * Invalid byte where token is required.
     */
    class Token : HttParseException() {
        override val message
            get() = ""
    }

    /**
     * Parsed more headers than provided buffer can contain.
     */
    class TooManyHeaders : HttParseException() {
        override val message
            get() = ""
    }

    /**
     * Invalid byte in HTTP version.
     */
    class Version : HttParseException() {
        override val message
            get() = ""
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<HttParseException> {
        override fun lift(error_buf: RustBuffer.ByValue): HttParseException = FfiConverterTypeHTTParseError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeHTTParseError : FfiConverterRustBuffer<HttParseException> {
    override fun read(buf: ByteBuffer): HttParseException =
        when (buf.getInt()) {
            1 -> HttParseException.HeaderName()
            2 -> HttParseException.HeaderValue()
            3 -> HttParseException.NewLine()
            4 -> HttParseException.Status()
            5 -> HttParseException.Token()
            6 -> HttParseException.TooManyHeaders()
            7 -> HttParseException.Version()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: HttParseException): ULong =
        when (value) {
            is HttParseException.HeaderName -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is HttParseException.HeaderValue -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is HttParseException.NewLine -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is HttParseException.Status -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is HttParseException.Token -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is HttParseException.TooManyHeaders -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is HttParseException.Version -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
        }

    override fun write(
        value: HttParseException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is HttParseException.HeaderName -> {
                buf.putInt(1)
                Unit
            }
            is HttParseException.HeaderValue -> {
                buf.putInt(2)
                Unit
            }
            is HttParseException.NewLine -> {
                buf.putInt(3)
                Unit
            }
            is HttParseException.Status -> {
                buf.putInt(4)
                Unit
            }
            is HttParseException.Token -> {
                buf.putInt(5)
                Unit
            }
            is HttParseException.TooManyHeaders -> {
                buf.putInt(6)
                Unit
            }
            is HttParseException.Version -> {
                buf.putInt(7)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * [http::error::Error], but with `uniffi` support
 */
sealed class HttpException : kotlin.Exception() {
    class StatusCode : HttpException() {
        override val message
            get() = ""
    }

    class Method : HttpException() {
        override val message
            get() = ""
    }

    class Uri(
        val `invalidUri`: kotlin.String,
    ) : HttpException() {
        override val message
            get() = "invalidUri=${ `invalidUri` }"
    }

    class UriParts(
        val `invalidUri`: kotlin.String,
    ) : HttpException() {
        override val message
            get() = "invalidUri=${ `invalidUri` }"
    }

    class HeaderName : HttpException() {
        override val message
            get() = ""
    }

    class HeaderValue : HttpException() {
        override val message
            get() = ""
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<HttpException> {
        override fun lift(error_buf: RustBuffer.ByValue): HttpException = FfiConverterTypeHttpError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeHttpError : FfiConverterRustBuffer<HttpException> {
    override fun read(buf: ByteBuffer): HttpException =
        when (buf.getInt()) {
            1 -> HttpException.StatusCode()
            2 -> HttpException.Method()
            3 ->
                HttpException.Uri(
                    FfiConverterString.read(buf),
                )
            4 ->
                HttpException.UriParts(
                    FfiConverterString.read(buf),
                )
            5 -> HttpException.HeaderName()
            6 -> HttpException.HeaderValue()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: HttpException): ULong =
        when (value) {
            is HttpException.StatusCode -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is HttpException.Method -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is HttpException.Uri -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterString.allocationSize(value.`invalidUri`)
            )
            is HttpException.UriParts -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterString.allocationSize(value.`invalidUri`)
            )
            is HttpException.HeaderName -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is HttpException.HeaderValue -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
        }

    override fun write(
        value: HttpException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is HttpException.StatusCode -> {
                buf.putInt(1)
                Unit
            }
            is HttpException.Method -> {
                buf.putInt(2)
                Unit
            }
            is HttpException.Uri -> {
                buf.putInt(3)
                FfiConverterString.write(value.`invalidUri`, buf)
                Unit
            }
            is HttpException.UriParts -> {
                buf.putInt(4)
                FfiConverterString.write(value.`invalidUri`, buf)
                Unit
            }
            is HttpException.HeaderName -> {
                buf.putInt(5)
                Unit
            }
            is HttpException.HeaderValue -> {
                buf.putInt(6)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

sealed class InvalidUri : kotlin.Exception() {
    class InvalidChar : InvalidUri() {
        override val message
            get() = ""
    }

    class InvalidScheme : InvalidUri() {
        override val message
            get() = ""
    }

    class InvalidAuthority : InvalidUri() {
        override val message
            get() = ""
    }

    class InvalidPort : InvalidUri() {
        override val message
            get() = ""
    }

    class InvalidFormat : InvalidUri() {
        override val message
            get() = ""
    }

    class SchemeMissing : InvalidUri() {
        override val message
            get() = ""
    }

    class AuthorityMissing : InvalidUri() {
        override val message
            get() = ""
    }

    class PathAndQueryMissing : InvalidUri() {
        override val message
            get() = ""
    }

    class TooLong : InvalidUri() {
        override val message
            get() = ""
    }

    class Empty : InvalidUri() {
        override val message
            get() = ""
    }

    class SchemeTooLong : InvalidUri() {
        override val message
            get() = ""
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<InvalidUri> {
        override fun lift(error_buf: RustBuffer.ByValue): InvalidUri = FfiConverterTypeInvalidUri.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeInvalidUri : FfiConverterRustBuffer<InvalidUri> {
    override fun read(buf: ByteBuffer): InvalidUri =
        when (buf.getInt()) {
            1 -> InvalidUri.InvalidChar()
            2 -> InvalidUri.InvalidScheme()
            3 -> InvalidUri.InvalidAuthority()
            4 -> InvalidUri.InvalidPort()
            5 -> InvalidUri.InvalidFormat()
            6 -> InvalidUri.SchemeMissing()
            7 -> InvalidUri.AuthorityMissing()
            8 -> InvalidUri.PathAndQueryMissing()
            9 -> InvalidUri.TooLong()
            10 -> InvalidUri.Empty()
            11 -> InvalidUri.SchemeTooLong()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: InvalidUri): ULong =
        when (value) {
            is InvalidUri.InvalidChar -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is InvalidUri.InvalidScheme -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is InvalidUri.InvalidAuthority -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is InvalidUri.InvalidPort -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is InvalidUri.InvalidFormat -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is InvalidUri.SchemeMissing -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is InvalidUri.AuthorityMissing -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is InvalidUri.PathAndQueryMissing -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is InvalidUri.TooLong -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is InvalidUri.Empty -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is InvalidUri.SchemeTooLong -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
        }

    override fun write(
        value: InvalidUri,
        buf: ByteBuffer,
    ) {
        when (value) {
            is InvalidUri.InvalidChar -> {
                buf.putInt(1)
                Unit
            }
            is InvalidUri.InvalidScheme -> {
                buf.putInt(2)
                Unit
            }
            is InvalidUri.InvalidAuthority -> {
                buf.putInt(3)
                Unit
            }
            is InvalidUri.InvalidPort -> {
                buf.putInt(4)
                Unit
            }
            is InvalidUri.InvalidFormat -> {
                buf.putInt(5)
                Unit
            }
            is InvalidUri.SchemeMissing -> {
                buf.putInt(6)
                Unit
            }
            is InvalidUri.AuthorityMissing -> {
                buf.putInt(7)
                Unit
            }
            is InvalidUri.PathAndQueryMissing -> {
                buf.putInt(8)
                Unit
            }
            is InvalidUri.TooLong -> {
                buf.putInt(9)
                Unit
            }
            is InvalidUri.Empty -> {
                buf.putInt(10)
                Unit
            }
            is InvalidUri.SchemeTooLong -> {
                buf.putInt(11)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * [std::io::Error] and [std::io::ErrorKind], but with `uniffi` support.
 */
sealed class IoException : kotlin.Exception() {
    /**
     * An entity was not found.
     */
    class NotFound : IoException() {
        override val message
            get() = ""
    }

    /**
     * Permission Denied for this operation.
     */
    class PermissionDenied : IoException() {
        override val message
            get() = ""
    }

    /**
     * The connection was refused.
     */
    class ConnectionRefused : IoException() {
        override val message
            get() = ""
    }

    /**
     * The connection was reset by server.
     */
    class ConnectionReset : IoException() {
        override val message
            get() = ""
    }

    /**
     * The host is not reachable.
     */
    class HostUnreachable : IoException() {
        override val message
            get() = ""
    }

    /**
     * The network for the host is not reachable.
     */
    class NetworkUnreachable : IoException() {
        override val message
            get() = ""
    }

    /**
     * The connection was aborted by the remote server.
     */
    class ConnectionAborted : IoException() {
        override val message
            get() = ""
    }

    /**
     * The network operation failed because it is not connected yet.
     */
    class NotConnected : IoException() {
        override val message
            get() = ""
    }

    /**
     * A socket address is already in use elsewhere.
     */
    class AddrInUse : IoException() {
        override val message
            get() = ""
    }

    /**
     * A nonexistent interface was requested or the requested address was not
     * local.
     */
    class AddrNotAvailable : IoException() {
        override val message
            get() = ""
    }

    /**
     * The system's networking is down.
     */
    class NetworkDown : IoException() {
        override val message
            get() = ""
    }

    /**
     * The operation failed because a pipe was closed.
     */
    class BrokenPipe : IoException() {
        override val message
            get() = ""
    }

    /**
     * An entity already exists.
     */
    class AlreadyExists : IoException() {
        override val message
            get() = ""
    }

    /**
     * The operation needs to block to complete, but the blocking operation was
     * requested to not occur.
     */
    class WouldBlock : IoException() {
        override val message
            get() = ""
    }

    /**
     * A filesystem object is, unexpectedly, not a directory.
     */
    class NotADirectory : IoException() {
        override val message
            get() = ""
    }

    /**
     * The filesystem object is, unexpectedly, a directory.
     */
    class IsADirectory : IoException() {
        override val message
            get() = ""
    }

    /**
     * A non-empty directory was specified when a empty directory was expected.
     */
    class DirectoryNotEmpty : IoException() {
        override val message
            get() = ""
    }

    /**
     * The filesystem is read-only when a write operation was attempted.
     */
    class ReadOnlyFilesystem : IoException() {
        override val message
            get() = ""
    }

    /**
     * Loop in the filesystem or IO subsystem; often, too many levels of symbolic links.
     *
     * There was a loop (or excessively long chain) resolving a filesystem object
     * or file IO object.
     */
    class FilesystemLoop : IoException() {
        override val message
            get() = ""
    }

    /**
     * Stale network file handle.
     */
    class StaleNetworkFileHandle : IoException() {
        override val message
            get() = ""
    }

    /**
     * A parameter was incorrect.
     */
    class InvalidInput : IoException() {
        override val message
            get() = ""
    }

    /**
     * Data not valid for the operation were encountered.

     */
    class InvalidData : IoException() {
        override val message
            get() = ""
    }

    /**
     * The I/O operation's timeout expired.
     */
    class TimedOut : IoException() {
        override val message
            get() = ""
    }

    /**
     * An error returned when an operation could not be completed because a
     * call to [`write`] returned [`Ok(0)`].

     */
    class WriteZero : IoException() {
        override val message
            get() = ""
    }

    /**
     * The underlying storage is full.
     */
    class StorageFull : IoException() {
        override val message
            get() = ""
    }

    /**
     * Seek on unseekable file.
     */
    class NotSeekable : IoException() {
        override val message
            get() = ""
    }

    /**
     * Filesystem quota was exceeded.
     */
    class FilesystemQuotaExceeded : IoException() {
        override val message
            get() = ""
    }

    /**
     * File larger than allowed or supported.
     */
    class FileTooLarge : IoException() {
        override val message
            get() = ""
    }

    /**
     * Resource is busy.
     */
    class ResourceBusy : IoException() {
        override val message
            get() = ""
    }

    /**
     * Executable file is busy.
     */
    class ExecutableFileBusy : IoException() {
        override val message
            get() = ""
    }

    /**
     * Deadlock (avoided).
     */
    class Deadlock : IoException() {
        override val message
            get() = ""
    }

    /**
     * Cross-device or cross-filesystem (hard) link or rename.
     */
    class CrossesDevices : IoException() {
        override val message
            get() = ""
    }

    /**
     * Too many (hard) links to the same filesystem object.
     *
     * The filesystem does not support making so many hardlinks to the same file.
     */
    class TooManyLinks : IoException() {
        override val message
            get() = ""
    }

    /**
     * A filename was invalid.
     *
     * This error can also cause if it exceeded the filename length limit.
     */
    class InvalidFilename : IoException() {
        override val message
            get() = ""
    }

    /**
     * Program argument list too long.
     *
     * When trying to run an external program, a system or process limit on the size of the
     * arguments would have been exceeded.
     */
    class ArgumentListTooLong : IoException() {
        override val message
            get() = ""
    }

    /**
     * This operation was interrupted.
     *
     * Interrupted operations can typically be retried.
     */
    class Interrupted : IoException() {
        override val message
            get() = ""
    }

    /**
     * This operation is unsupported on this platform.
     *
     * This means that the operation can never succeed.
     */
    class Unsupported : IoException() {
        override val message
            get() = ""
    }

    /**
     * An error returned when an operation could not be completed because an
     * "end of file" was reached prematurely.
     *
     * This typically means that an operation could only succeed if it read a
     * particular number of bytes but only a smaller number of bytes could be
     * read.
     */
    class UnexpectedEof : IoException() {
        override val message
            get() = ""
    }

    /**
     * An operation could not be completed, because it failed
     * to allocate enough memory.
     */
    class OutOfMemory : IoException() {
        override val message
            get() = ""
    }

    /**
     * A custom error that does not fall under any other I/O error kind.
     *
     * This can be used to construct your own [`IoError`]s that do not match any
     * [`ErrorKind`].
     *
     * This [`ErrorKind`] is not used by the standard library.
     *
     * Errors from the standard library that do not fall under any of the I/O
     * error kinds cannot be `match`ed on, and will only match a wildcard (`_`) pattern.
     * New [`ErrorKind`]s might be added in the future for some of those.
     */
    class Other : IoException() {
        override val message
            get() = ""
    }

    /**
     * Any I/O error from the standard library that's not part of this list.
     *
     * Errors that are `Uncategorized` now may move to a different or a new
     * [`ErrorKind`] variant in the future. It is not recommended to match
     * an error against `Uncategorized`; use a wildcard match (`_`) instead.
     */
    class Uncategorized : IoException() {
        override val message
            get() = ""
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<IoException> {
        override fun lift(error_buf: RustBuffer.ByValue): IoException = FfiConverterTypeIoError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeIoError : FfiConverterRustBuffer<IoException> {
    override fun read(buf: ByteBuffer): IoException =
        when (buf.getInt()) {
            1 -> IoException.NotFound()
            2 -> IoException.PermissionDenied()
            3 -> IoException.ConnectionRefused()
            4 -> IoException.ConnectionReset()
            5 -> IoException.HostUnreachable()
            6 -> IoException.NetworkUnreachable()
            7 -> IoException.ConnectionAborted()
            8 -> IoException.NotConnected()
            9 -> IoException.AddrInUse()
            10 -> IoException.AddrNotAvailable()
            11 -> IoException.NetworkDown()
            12 -> IoException.BrokenPipe()
            13 -> IoException.AlreadyExists()
            14 -> IoException.WouldBlock()
            15 -> IoException.NotADirectory()
            16 -> IoException.IsADirectory()
            17 -> IoException.DirectoryNotEmpty()
            18 -> IoException.ReadOnlyFilesystem()
            19 -> IoException.FilesystemLoop()
            20 -> IoException.StaleNetworkFileHandle()
            21 -> IoException.InvalidInput()
            22 -> IoException.InvalidData()
            23 -> IoException.TimedOut()
            24 -> IoException.WriteZero()
            25 -> IoException.StorageFull()
            26 -> IoException.NotSeekable()
            27 -> IoException.FilesystemQuotaExceeded()
            28 -> IoException.FileTooLarge()
            29 -> IoException.ResourceBusy()
            30 -> IoException.ExecutableFileBusy()
            31 -> IoException.Deadlock()
            32 -> IoException.CrossesDevices()
            33 -> IoException.TooManyLinks()
            34 -> IoException.InvalidFilename()
            35 -> IoException.ArgumentListTooLong()
            36 -> IoException.Interrupted()
            37 -> IoException.Unsupported()
            38 -> IoException.UnexpectedEof()
            39 -> IoException.OutOfMemory()
            40 -> IoException.Other()
            41 -> IoException.Uncategorized()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: IoException): ULong =
        when (value) {
            is IoException.NotFound -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.PermissionDenied -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.ConnectionRefused -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.ConnectionReset -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.HostUnreachable -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.NetworkUnreachable -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.ConnectionAborted -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.NotConnected -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.AddrInUse -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.AddrNotAvailable -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.NetworkDown -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.BrokenPipe -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.AlreadyExists -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.WouldBlock -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.NotADirectory -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.IsADirectory -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.DirectoryNotEmpty -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.ReadOnlyFilesystem -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.FilesystemLoop -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.StaleNetworkFileHandle -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.InvalidInput -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.InvalidData -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.TimedOut -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.WriteZero -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.StorageFull -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.NotSeekable -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.FilesystemQuotaExceeded -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.FileTooLarge -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.ResourceBusy -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.ExecutableFileBusy -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.Deadlock -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.CrossesDevices -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.TooManyLinks -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.InvalidFilename -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.ArgumentListTooLong -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.Interrupted -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.Unsupported -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.UnexpectedEof -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.OutOfMemory -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.Other -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is IoException.Uncategorized -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
        }

    override fun write(
        value: IoException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is IoException.NotFound -> {
                buf.putInt(1)
                Unit
            }
            is IoException.PermissionDenied -> {
                buf.putInt(2)
                Unit
            }
            is IoException.ConnectionRefused -> {
                buf.putInt(3)
                Unit
            }
            is IoException.ConnectionReset -> {
                buf.putInt(4)
                Unit
            }
            is IoException.HostUnreachable -> {
                buf.putInt(5)
                Unit
            }
            is IoException.NetworkUnreachable -> {
                buf.putInt(6)
                Unit
            }
            is IoException.ConnectionAborted -> {
                buf.putInt(7)
                Unit
            }
            is IoException.NotConnected -> {
                buf.putInt(8)
                Unit
            }
            is IoException.AddrInUse -> {
                buf.putInt(9)
                Unit
            }
            is IoException.AddrNotAvailable -> {
                buf.putInt(10)
                Unit
            }
            is IoException.NetworkDown -> {
                buf.putInt(11)
                Unit
            }
            is IoException.BrokenPipe -> {
                buf.putInt(12)
                Unit
            }
            is IoException.AlreadyExists -> {
                buf.putInt(13)
                Unit
            }
            is IoException.WouldBlock -> {
                buf.putInt(14)
                Unit
            }
            is IoException.NotADirectory -> {
                buf.putInt(15)
                Unit
            }
            is IoException.IsADirectory -> {
                buf.putInt(16)
                Unit
            }
            is IoException.DirectoryNotEmpty -> {
                buf.putInt(17)
                Unit
            }
            is IoException.ReadOnlyFilesystem -> {
                buf.putInt(18)
                Unit
            }
            is IoException.FilesystemLoop -> {
                buf.putInt(19)
                Unit
            }
            is IoException.StaleNetworkFileHandle -> {
                buf.putInt(20)
                Unit
            }
            is IoException.InvalidInput -> {
                buf.putInt(21)
                Unit
            }
            is IoException.InvalidData -> {
                buf.putInt(22)
                Unit
            }
            is IoException.TimedOut -> {
                buf.putInt(23)
                Unit
            }
            is IoException.WriteZero -> {
                buf.putInt(24)
                Unit
            }
            is IoException.StorageFull -> {
                buf.putInt(25)
                Unit
            }
            is IoException.NotSeekable -> {
                buf.putInt(26)
                Unit
            }
            is IoException.FilesystemQuotaExceeded -> {
                buf.putInt(27)
                Unit
            }
            is IoException.FileTooLarge -> {
                buf.putInt(28)
                Unit
            }
            is IoException.ResourceBusy -> {
                buf.putInt(29)
                Unit
            }
            is IoException.ExecutableFileBusy -> {
                buf.putInt(30)
                Unit
            }
            is IoException.Deadlock -> {
                buf.putInt(31)
                Unit
            }
            is IoException.CrossesDevices -> {
                buf.putInt(32)
                Unit
            }
            is IoException.TooManyLinks -> {
                buf.putInt(33)
                Unit
            }
            is IoException.InvalidFilename -> {
                buf.putInt(34)
                Unit
            }
            is IoException.ArgumentListTooLong -> {
                buf.putInt(35)
                Unit
            }
            is IoException.Interrupted -> {
                buf.putInt(36)
                Unit
            }
            is IoException.Unsupported -> {
                buf.putInt(37)
                Unit
            }
            is IoException.UnexpectedEof -> {
                buf.putInt(38)
                Unit
            }
            is IoException.OutOfMemory -> {
                buf.putInt(39)
                Unit
            }
            is IoException.Other -> {
                buf.putInt(40)
                Unit
            }
            is IoException.Uncategorized -> {
                buf.putInt(41)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * Replicates [serde_json::Value], but with `uniffi` support.
 */
sealed class Json {
    /**
     * JSON `null`
     */
    object Null : Json()

    /**
     * JSON `true` or `false`
     */
    data class Bool(
        /**
         * The boolean
         */
        val `bool`: kotlin.Boolean,
    ) : Json() {
        companion object
    }

    /**
     * JSON integer or float
     */
    data class Numb(
        /**
         * The integer or float
         */
        val `number`: Number,
    ) : Json() {
        companion object
    }

    /**
     * JSON string
     */
    data class Str(
        /**
         * The string
         */
        val `string`: kotlin.String,
    ) : Json() {
        companion object
    }

    /**
     * JSON array of JSON
     */
    data class Array(
        /**
         * The array
         */
        val `array`: List<Json>,
    ) : Json() {
        companion object
    }

    /**
     * JSON object
     */
    data class Object(
        /**
         * The object
         */
        val `object`: Map<kotlin.String, Json>,
    ) : Json() {
        companion object
    }

    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeJSON : FfiConverterRustBuffer<Json> {
    override fun read(buf: ByteBuffer): Json =
        when (buf.getInt()) {
            1 -> Json.Null
            2 ->
                Json.Bool(
                    FfiConverterBoolean.read(buf),
                )
            3 ->
                Json.Numb(
                    FfiConverterTypeNumber.read(buf),
                )
            4 ->
                Json.Str(
                    FfiConverterString.read(buf),
                )
            5 ->
                Json.Array(
                    FfiConverterSequenceTypeJSON.read(buf),
                )
            6 ->
                Json.Object(
                    FfiConverterMapStringTypeJSON.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }

    override fun allocationSize(value: Json) =
        when (value) {
            is Json.Null -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is Json.Bool -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterBoolean.allocationSize(value.`bool`)
                )
            }
            is Json.Numb -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterTypeNumber.allocationSize(value.`number`)
                )
            }
            is Json.Str -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterString.allocationSize(value.`string`)
                )
            }
            is Json.Array -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterSequenceTypeJSON.allocationSize(value.`array`)
                )
            }
            is Json.Object -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterMapStringTypeJSON.allocationSize(value.`object`)
                )
            }
        }

    override fun write(
        value: Json,
        buf: ByteBuffer,
    ) {
        when (value) {
            is Json.Null -> {
                buf.putInt(1)
                Unit
            }
            is Json.Bool -> {
                buf.putInt(2)
                FfiConverterBoolean.write(value.`bool`, buf)
                Unit
            }
            is Json.Numb -> {
                buf.putInt(3)
                FfiConverterTypeNumber.write(value.`number`, buf)
                Unit
            }
            is Json.Str -> {
                buf.putInt(4)
                FfiConverterString.write(value.`string`, buf)
                Unit
            }
            is Json.Array -> {
                buf.putInt(5)
                FfiConverterSequenceTypeJSON.write(value.`array`, buf)
                Unit
            }
            is Json.Object -> {
                buf.putInt(6)
                FfiConverterMapStringTypeJSON.write(value.`object`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * Error from [JSON::deserialize]
 */
sealed class JsonDeserializationException : kotlin.Exception() {
    /**
     * There was error reading from the underlying IO device after reading `column` of `line`.
     */
    class Io(
        /**
         * The line that was being read before the `io_error` occurred.
         */
        val `line`: kotlin.ULong,
        /**
         * The column on `line` that was being read before the `io_error` occurred.
         */
        val `column`: kotlin.ULong,
        /**
         * The underlying [IoError] that occurred on `line` at `column`.
         */
        val `ioError`: IoException,
    ) : JsonDeserializationException() {
        override val message
            get() = "line=${ `line` }, column=${ `column` }, ioError=${ `ioError` }"
    }

    /**
     * There was a JSON syntax error at `line` on `column`.
     */
    class Syntax(
        /**
         * The line where the syntax error occurred.
         */
        val `line`: kotlin.ULong,
        /**
         * The column on `line` where the syntax error occurred.
         */
        val `column`: kotlin.ULong,
    ) : JsonDeserializationException() {
        override val message
            get() = "line=${ `line` }, column=${ `column` }"
    }

    /**
     * The data such as a string or number could not be converted from JSON at `line` on `column`.
     */
    class Data(
        /**
         * The line where the invalid string or number occurred.
         */
        val `line`: kotlin.ULong,
        /**
         * The column on `line` where the invalid string or number occurred.
         */
        val `column`: kotlin.ULong,
    ) : JsonDeserializationException() {
        override val message
            get() = "line=${ `line` }, column=${ `column` }"
    }

    /**
     * The EOF was reached at `line` on `column` while still parsing a JSON structure.
     */
    class Eof(
        /**
         * The last line that was read before the premature End-Of-File.
         */
        val `line`: kotlin.ULong,
        /**
         * The last column on `line` that was read before the premature End-Of-File.
         */
        val `column`: kotlin.ULong,
    ) : JsonDeserializationException() {
        override val message
            get() = "line=${ `line` }, column=${ `column` }"
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<JsonDeserializationException> {
        override fun lift(error_buf: RustBuffer.ByValue): JsonDeserializationException =
            FfiConverterTypeJSONDeserializationError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeJSONDeserializationError : FfiConverterRustBuffer<JsonDeserializationException> {
    override fun read(buf: ByteBuffer): JsonDeserializationException =
        when (buf.getInt()) {
            1 ->
                JsonDeserializationException.Io(
                    FfiConverterULong.read(buf),
                    FfiConverterULong.read(buf),
                    FfiConverterTypeIoError.read(buf),
                )
            2 ->
                JsonDeserializationException.Syntax(
                    FfiConverterULong.read(buf),
                    FfiConverterULong.read(buf),
                )
            3 ->
                JsonDeserializationException.Data(
                    FfiConverterULong.read(buf),
                    FfiConverterULong.read(buf),
                )
            4 ->
                JsonDeserializationException.Eof(
                    FfiConverterULong.read(buf),
                    FfiConverterULong.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: JsonDeserializationException): ULong =
        when (value) {
            is JsonDeserializationException.Io -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterULong.allocationSize(value.`line`) +
                    FfiConverterULong.allocationSize(value.`column`) +
                    FfiConverterTypeIoError.allocationSize(value.`ioError`)
            )
            is JsonDeserializationException.Syntax -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterULong.allocationSize(value.`line`) +
                    FfiConverterULong.allocationSize(value.`column`)
            )
            is JsonDeserializationException.Data -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterULong.allocationSize(value.`line`) +
                    FfiConverterULong.allocationSize(value.`column`)
            )
            is JsonDeserializationException.Eof -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterULong.allocationSize(value.`line`) +
                    FfiConverterULong.allocationSize(value.`column`)
            )
        }

    override fun write(
        value: JsonDeserializationException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is JsonDeserializationException.Io -> {
                buf.putInt(1)
                FfiConverterULong.write(value.`line`, buf)
                FfiConverterULong.write(value.`column`, buf)
                FfiConverterTypeIoError.write(value.`ioError`, buf)
                Unit
            }
            is JsonDeserializationException.Syntax -> {
                buf.putInt(2)
                FfiConverterULong.write(value.`line`, buf)
                FfiConverterULong.write(value.`column`, buf)
                Unit
            }
            is JsonDeserializationException.Data -> {
                buf.putInt(3)
                FfiConverterULong.write(value.`line`, buf)
                FfiConverterULong.write(value.`column`, buf)
                Unit
            }
            is JsonDeserializationException.Eof -> {
                buf.putInt(4)
                FfiConverterULong.write(value.`line`, buf)
                FfiConverterULong.write(value.`column`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * Errors for when leaving a channel fails.
 */
sealed class LeaveException : kotlin.Exception() {
    /**
     * The leave operation timeout.
     */
    class Timeout : LeaveException() {
        override val message
            get() = ""
    }

    /**
     * The channel was shutting down when the client was leaving the channel.
     */
    class ShuttingDown : LeaveException() {
        override val message
            get() = ""
    }

    /**
     * The channel was shutting down when the client was leaving the channel.
     */
    class Shutdown : LeaveException() {
        override val message
            get() = ""
    }

    /**
     * The channel already shut down when the client was leaving the channel.
     */
    class SocketShutdown(
        /**
         * The shut down error
         */
        val `socketShutdownError`: SocketShutdownException,
    ) : LeaveException() {
        override val message
            get() = "socketShutdownError=${ `socketShutdownError` }"
    }

    /**
     * There was a websocket error when the client was leaving the channel.
     */
    class WebSocket(
        /**
         * The specific websocket error for this shutdown.
         */
        val `webSocketError`: WebSocketException,
    ) : LeaveException() {
        override val message
            get() = "webSocketError=${ `webSocketError` }"
    }

    /**
     * The server rejected the clients request to leave the channel.
     */
    class Rejected(
        /**
         * Response from the server of why the leave was rejected
         */
        val `rejection`: Payload,
    ) : LeaveException() {
        override val message
            get() = "rejection=${ `rejection` }"
    }

    /**
     * A join was initiated before the server could respond if leave was successful
     */
    class JoinBeforeLeft : LeaveException() {
        override val message
            get() = ""
    }

    /**
     * There was a URL error when leaving the channel.
     */
    class Url(
        /**
         * The url error itself.
         */
        val `urlError`: kotlin.String,
    ) : LeaveException() {
        override val message
            get() = "urlError=${ `urlError` }"
    }

    /**
     * There was an HTTP error when leaving the cheannel.
     */
    class Http(
        /**
         * The http response for the error.
         */
        val `response`: Response,
    ) : LeaveException() {
        override val message
            get() = "response=${ `response` }"
    }

    /**
     * HTTP format error.
     */
    class HttpFormat(
        /**
         * The http error.
         */
        val `error`: HttpException,
    ) : LeaveException() {
        override val message
            get() = "error=${ `error` }"
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<LeaveException> {
        override fun lift(error_buf: RustBuffer.ByValue): LeaveException = FfiConverterTypeLeaveError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeLeaveError : FfiConverterRustBuffer<LeaveException> {
    override fun read(buf: ByteBuffer): LeaveException =
        when (buf.getInt()) {
            1 -> LeaveException.Timeout()
            2 -> LeaveException.ShuttingDown()
            3 -> LeaveException.Shutdown()
            4 ->
                LeaveException.SocketShutdown(
                    FfiConverterTypeSocketShutdownError.read(buf),
                )
            5 ->
                LeaveException.WebSocket(
                    FfiConverterTypeWebSocketError.read(buf),
                )
            6 ->
                LeaveException.Rejected(
                    FfiConverterTypePayload.read(buf),
                )
            7 -> LeaveException.JoinBeforeLeft()
            8 ->
                LeaveException.Url(
                    FfiConverterString.read(buf),
                )
            9 ->
                LeaveException.Http(
                    FfiConverterTypeResponse.read(buf),
                )
            10 ->
                LeaveException.HttpFormat(
                    FfiConverterTypeHttpError.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: LeaveException): ULong =
        when (value) {
            is LeaveException.Timeout -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is LeaveException.ShuttingDown -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is LeaveException.Shutdown -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is LeaveException.SocketShutdown -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeSocketShutdownError.allocationSize(value.`socketShutdownError`)
            )
            is LeaveException.WebSocket -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeWebSocketError.allocationSize(value.`webSocketError`)
            )
            is LeaveException.Rejected -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypePayload.allocationSize(value.`rejection`)
            )
            is LeaveException.JoinBeforeLeft -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is LeaveException.Url -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterString.allocationSize(value.`urlError`)
            )
            is LeaveException.Http -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeResponse.allocationSize(value.`response`)
            )
            is LeaveException.HttpFormat -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeHttpError.allocationSize(value.`error`)
            )
        }

    override fun write(
        value: LeaveException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is LeaveException.Timeout -> {
                buf.putInt(1)
                Unit
            }
            is LeaveException.ShuttingDown -> {
                buf.putInt(2)
                Unit
            }
            is LeaveException.Shutdown -> {
                buf.putInt(3)
                Unit
            }
            is LeaveException.SocketShutdown -> {
                buf.putInt(4)
                FfiConverterTypeSocketShutdownError.write(value.`socketShutdownError`, buf)
                Unit
            }
            is LeaveException.WebSocket -> {
                buf.putInt(5)
                FfiConverterTypeWebSocketError.write(value.`webSocketError`, buf)
                Unit
            }
            is LeaveException.Rejected -> {
                buf.putInt(6)
                FfiConverterTypePayload.write(value.`rejection`, buf)
                Unit
            }
            is LeaveException.JoinBeforeLeft -> {
                buf.putInt(7)
                Unit
            }
            is LeaveException.Url -> {
                buf.putInt(8)
                FfiConverterString.write(value.`urlError`, buf)
                Unit
            }
            is LeaveException.Http -> {
                buf.putInt(9)
                FfiConverterTypeResponse.write(value.`response`, buf)
                Unit
            }
            is LeaveException.HttpFormat -> {
                buf.putInt(10)
                FfiConverterTypeHttpError.write(value.`error`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * Replicates [serde_json::Number] but with `uniffi` support.
 */
sealed class Number {
    /**
     * Positive number
     */
    data class PosInt(
        /**
         * Positive number
         */
        val `pos`: kotlin.ULong,
    ) : Number() {
        companion object
    }

    /**
     * Negative number
     */
    data class NegInt(
        /**
         * Negative number
         */
        val `neg`: kotlin.Long,
    ) : Number() {
        companion object
    }

    /**
     * Float
     */
    data class Float(
        /**
         * Float
         */
        val `float`: kotlin.Double,
    ) : Number() {
        companion object
    }

    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeNumber : FfiConverterRustBuffer<Number> {
    override fun read(buf: ByteBuffer): Number =
        when (buf.getInt()) {
            1 ->
                Number.PosInt(
                    FfiConverterULong.read(buf),
                )
            2 ->
                Number.NegInt(
                    FfiConverterLong.read(buf),
                )
            3 ->
                Number.Float(
                    FfiConverterDouble.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }

    override fun allocationSize(value: Number) =
        when (value) {
            is Number.PosInt -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterULong.allocationSize(value.`pos`)
                )
            }
            is Number.NegInt -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterLong.allocationSize(value.`neg`)
                )
            }
            is Number.Float -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterDouble.allocationSize(value.`float`)
                )
            }
        }

    override fun write(
        value: Number,
        buf: ByteBuffer,
    ) {
        when (value) {
            is Number.PosInt -> {
                buf.putInt(1)
                FfiConverterULong.write(value.`pos`, buf)
                Unit
            }
            is Number.NegInt -> {
                buf.putInt(2)
                FfiConverterLong.write(value.`neg`, buf)
                Unit
            }
            is Number.Float -> {
                buf.putInt(3)
                FfiConverterDouble.write(value.`float`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * Contains the response payload sent to/received from Phoenix
 */
sealed class Payload {
    /**
     * A JSON payload
     */
    data class JsonPayload(
        /**
         * The JSON payload
         */
        val `json`: Json,
    ) : Payload() {
        companion object
    }

    /**
     * A binary payload
     */
    data class Binary(
        /**
         * The bytes of the binary payload.
         */
        val `bytes`: kotlin.ByteArray,
    ) : Payload() {
        companion object
    }

    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePayload : FfiConverterRustBuffer<Payload> {
    override fun read(buf: ByteBuffer): Payload =
        when (buf.getInt()) {
            1 ->
                Payload.JsonPayload(
                    FfiConverterTypeJSON.read(buf),
                )
            2 ->
                Payload.Binary(
                    FfiConverterByteArray.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }

    override fun allocationSize(value: Payload) =
        when (value) {
            is Payload.JsonPayload -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterTypeJSON.allocationSize(value.`json`)
                )
            }
            is Payload.Binary -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterByteArray.allocationSize(value.`bytes`)
                )
            }
        }

    override fun write(
        value: Payload,
        buf: ByteBuffer,
    ) {
        when (value) {
            is Payload.JsonPayload -> {
                buf.putInt(1)
                FfiConverterTypeJSON.write(value.`json`, buf)
                Unit
            }
            is Payload.Binary -> {
                buf.putInt(2)
                FfiConverterByteArray.write(value.`bytes`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * All errors that can be produced by this library.
 */
sealed class PhoenixException : kotlin.Exception() {
    /**
     * Timeout elapsed
     */
    class Elapsed : PhoenixException() {
        override val message
            get() = ""
    }

    /**
     * Error when parsing URL
     */
    class UrlParse(
        /**
         * Error parsing URL
         */
        val `urlParse`: UrlParseException,
    ) : PhoenixException() {
        override val message
            get() = "urlParse=${ `urlParse` }"
    }

    /**
     * An error from any function on [Socket](crate::Socket).
     */
    class Socket(
        /**
         * Error from any function on [Socket](crate::Socket).
         */
        val `socket`: SocketException,
    ) : PhoenixException() {
        override val message
            get() = "socket=${ `socket` }"
    }

    /**
     * An error from any function on [Channel](crate::Channel).
     */
    class Channel(
        /**
         * An error from any function on [Channel](crate::Channel).
         */
        val `channel`: ChannelException,
    ) : PhoenixException() {
        override val message
            get() = "channel=${ `channel` }"
    }

    /**
     * An error from calling `status` on [Channel::statuses](crate::Channel::statuses) or
     * [Socket::statuses](crate::Socket::statuses).
     */
    class Statuses(
        /**
         * An error from calling `status` on [Channel::statuses](crate::Channel::statuses) or
         * [Socket::statuses](crate::Socket::statuses).
         */
        val `statuses`: StatusesException,
    ) : PhoenixException() {
        override val message
            get() = "statuses=${ `statuses` }"
    }

    /**
     * An error from calling [Presences](crate::Presences), [PresencesJoins](crate::PresencesJoins),
     * [PresencesLeaves](crate::PresencesLeaves), or [PresencesJoins](crate::PresencesJoins).
     */
    class Presences(
        /**
         * An error from calling [Presences](crate::Presences), [PresencesJoins](crate::PresencesJoins),
         * [PresencesLeaves](crate::PresencesLeaves), or [PresencesJoins](crate::PresencesJoins).
         */
        val `presences`: PresencesException,
    ) : PhoenixException() {
        override val message
            get() = "presences=${ `presences` }"
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<PhoenixException> {
        override fun lift(error_buf: RustBuffer.ByValue): PhoenixException = FfiConverterTypePhoenixError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypePhoenixError : FfiConverterRustBuffer<PhoenixException> {
    override fun read(buf: ByteBuffer): PhoenixException =
        when (buf.getInt()) {
            1 -> PhoenixException.Elapsed()
            2 ->
                PhoenixException.UrlParse(
                    FfiConverterTypeURLParseError.read(buf),
                )
            3 ->
                PhoenixException.Socket(
                    FfiConverterTypeSocketError.read(buf),
                )
            4 ->
                PhoenixException.Channel(
                    FfiConverterTypeChannelError.read(buf),
                )
            5 ->
                PhoenixException.Statuses(
                    FfiConverterTypeStatusesError.read(buf),
                )
            6 ->
                PhoenixException.Presences(
                    FfiConverterTypePresencesError.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: PhoenixException): ULong =
        when (value) {
            is PhoenixException.Elapsed -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is PhoenixException.UrlParse -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeURLParseError.allocationSize(value.`urlParse`)
            )
            is PhoenixException.Socket -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeSocketError.allocationSize(value.`socket`)
            )
            is PhoenixException.Channel -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeChannelError.allocationSize(value.`channel`)
            )
            is PhoenixException.Statuses -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeStatusesError.allocationSize(value.`statuses`)
            )
            is PhoenixException.Presences -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypePresencesError.allocationSize(value.`presences`)
            )
        }

    override fun write(
        value: PhoenixException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is PhoenixException.Elapsed -> {
                buf.putInt(1)
                Unit
            }
            is PhoenixException.UrlParse -> {
                buf.putInt(2)
                FfiConverterTypeURLParseError.write(value.`urlParse`, buf)
                Unit
            }
            is PhoenixException.Socket -> {
                buf.putInt(3)
                FfiConverterTypeSocketError.write(value.`socket`, buf)
                Unit
            }
            is PhoenixException.Channel -> {
                buf.putInt(4)
                FfiConverterTypeChannelError.write(value.`channel`, buf)
                Unit
            }
            is PhoenixException.Statuses -> {
                buf.putInt(5)
                FfiConverterTypeStatusesError.write(value.`statuses`, buf)
                Unit
            }
            is PhoenixException.Presences -> {
                buf.putInt(6)
                FfiConverterTypePresencesError.write(value.`presences`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * Represents special events related to management of Phoenix channels.
 */

enum class PhoenixEvent {
    /**
     * Used when sending a message to join a channel
     */
    JOIN,

    /**
     * Used when sending a message to leave a channel
     */
    LEAVE,

    /**
     * Sent/received when a channel is closed
     */
    CLOSE,

    /**
     * Sent/received with replies
     */
    REPLY,

    /**
     * Sent by the server when an error occurs
     */
    ERROR,

    /**
     * Sent/received as a keepalive for the underlying socket
     */
    HEARTBEAT,

    ;

    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypePhoenixEvent : FfiConverterRustBuffer<PhoenixEvent> {
    override fun read(buf: ByteBuffer) =
        try {
            PhoenixEvent.values()[buf.getInt() - 1]
        } catch (e: IndexOutOfBoundsException) {
            throw RuntimeException("invalid enum value, something is very wrong!!", e)
        }

    override fun allocationSize(value: PhoenixEvent) = 4UL

    override fun write(
        value: PhoenixEvent,
        buf: ByteBuffer,
    ) {
        buf.putInt(value.ordinal + 1)
    }
}

/**
 * Errors reutrned by [Presences] functions.
 */
sealed class PresencesException : kotlin.Exception() {
    /**
     * Errors when calling [PresencesJoins::join].
     */
    class PresencesJoins(
        val `presencesJoins`: PresencesJoinsException,
    ) : PresencesException() {
        override val message
            get() = "presencesJoins=${ `presencesJoins` }"
    }

    /**
     * Errors when calling [PresencesLeaves::leave].
     */
    class PresencesLeaves(
        val `presencesLeave`: PresencesLeavesException,
    ) : PresencesException() {
        override val message
            get() = "presencesLeave=${ `presencesLeave` }"
    }

    /**
     * Errors when calling [PresencesSyncs::sync].
     */
    class PresencesSyncs(
        val `presencesSyncs`: PresencesSyncsException,
    ) : PresencesException() {
        override val message
            get() = "presencesSyncs=${ `presencesSyncs` }"
    }

    /**
     * Errors when calling [Presences::shutdown].
     */
    class Shutdown(
        val `shutdown`: PresencesShutdownException,
    ) : PresencesException() {
        override val message
            get() = "shutdown=${ `shutdown` }"
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<PresencesException> {
        override fun lift(error_buf: RustBuffer.ByValue): PresencesException = FfiConverterTypePresencesError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypePresencesError : FfiConverterRustBuffer<PresencesException> {
    override fun read(buf: ByteBuffer): PresencesException =
        when (buf.getInt()) {
            1 ->
                PresencesException.PresencesJoins(
                    FfiConverterTypePresencesJoinsError.read(buf),
                )
            2 ->
                PresencesException.PresencesLeaves(
                    FfiConverterTypePresencesLeavesError.read(buf),
                )
            3 ->
                PresencesException.PresencesSyncs(
                    FfiConverterTypePresencesSyncsError.read(buf),
                )
            4 ->
                PresencesException.Shutdown(
                    FfiConverterTypePresencesShutdownError.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: PresencesException): ULong =
        when (value) {
            is PresencesException.PresencesJoins -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypePresencesJoinsError.allocationSize(value.`presencesJoins`)
            )
            is PresencesException.PresencesLeaves -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypePresencesLeavesError.allocationSize(value.`presencesLeave`)
            )
            is PresencesException.PresencesSyncs -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypePresencesSyncsError.allocationSize(value.`presencesSyncs`)
            )
            is PresencesException.Shutdown -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypePresencesShutdownError.allocationSize(value.`shutdown`)
            )
        }

    override fun write(
        value: PresencesException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is PresencesException.PresencesJoins -> {
                buf.putInt(1)
                FfiConverterTypePresencesJoinsError.write(value.`presencesJoins`, buf)
                Unit
            }
            is PresencesException.PresencesLeaves -> {
                buf.putInt(2)
                FfiConverterTypePresencesLeavesError.write(value.`presencesLeave`, buf)
                Unit
            }
            is PresencesException.PresencesSyncs -> {
                buf.putInt(3)
                FfiConverterTypePresencesSyncsError.write(value.`presencesSyncs`, buf)
                Unit
            }
            is PresencesException.Shutdown -> {
                buf.putInt(4)
                FfiConverterTypePresencesShutdownError.write(value.`shutdown`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

sealed class PresencesJoinsException : kotlin.Exception() {
    class NoMoreJoins : PresencesJoinsException() {
        override val message
            get() = ""
    }

    class MissedJoins(
        val `missedJoinCount`: kotlin.ULong,
    ) : PresencesJoinsException() {
        override val message
            get() = "missedJoinCount=${ `missedJoinCount` }"
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<PresencesJoinsException> {
        override fun lift(error_buf: RustBuffer.ByValue): PresencesJoinsException = FfiConverterTypePresencesJoinsError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypePresencesJoinsError : FfiConverterRustBuffer<PresencesJoinsException> {
    override fun read(buf: ByteBuffer): PresencesJoinsException =
        when (buf.getInt()) {
            1 -> PresencesJoinsException.NoMoreJoins()
            2 ->
                PresencesJoinsException.MissedJoins(
                    FfiConverterULong.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: PresencesJoinsException): ULong =
        when (value) {
            is PresencesJoinsException.NoMoreJoins -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is PresencesJoinsException.MissedJoins -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterULong.allocationSize(value.`missedJoinCount`)
            )
        }

    override fun write(
        value: PresencesJoinsException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is PresencesJoinsException.NoMoreJoins -> {
                buf.putInt(1)
                Unit
            }
            is PresencesJoinsException.MissedJoins -> {
                buf.putInt(2)
                FfiConverterULong.write(value.`missedJoinCount`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

sealed class PresencesLeavesException : kotlin.Exception() {
    class NoMoreLeaves : PresencesLeavesException() {
        override val message
            get() = ""
    }

    class MissedLeaves(
        val `missedLeaveCount`: kotlin.ULong,
    ) : PresencesLeavesException() {
        override val message
            get() = "missedLeaveCount=${ `missedLeaveCount` }"
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<PresencesLeavesException> {
        override fun lift(error_buf: RustBuffer.ByValue): PresencesLeavesException = FfiConverterTypePresencesLeavesError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypePresencesLeavesError : FfiConverterRustBuffer<PresencesLeavesException> {
    override fun read(buf: ByteBuffer): PresencesLeavesException =
        when (buf.getInt()) {
            1 -> PresencesLeavesException.NoMoreLeaves()
            2 ->
                PresencesLeavesException.MissedLeaves(
                    FfiConverterULong.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: PresencesLeavesException): ULong =
        when (value) {
            is PresencesLeavesException.NoMoreLeaves -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is PresencesLeavesException.MissedLeaves -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterULong.allocationSize(value.`missedLeaveCount`)
            )
        }

    override fun write(
        value: PresencesLeavesException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is PresencesLeavesException.NoMoreLeaves -> {
                buf.putInt(1)
                Unit
            }
            is PresencesLeavesException.MissedLeaves -> {
                buf.putInt(2)
                FfiConverterULong.write(value.`missedLeaveCount`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

sealed class PresencesShutdownException : kotlin.Exception() {
    class AlreadyJoined : PresencesShutdownException() {
        override val message
            get() = ""
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<PresencesShutdownException> {
        override fun lift(error_buf: RustBuffer.ByValue): PresencesShutdownException =
            FfiConverterTypePresencesShutdownError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypePresencesShutdownError : FfiConverterRustBuffer<PresencesShutdownException> {
    override fun read(buf: ByteBuffer): PresencesShutdownException =
        when (buf.getInt()) {
            1 -> PresencesShutdownException.AlreadyJoined()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: PresencesShutdownException): ULong =
        when (value) {
            is PresencesShutdownException.AlreadyJoined -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
        }

    override fun write(
        value: PresencesShutdownException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is PresencesShutdownException.AlreadyJoined -> {
                buf.putInt(1)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

sealed class PresencesSyncsException : kotlin.Exception() {
    class NoMoreSyncs : PresencesSyncsException() {
        override val message
            get() = ""
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<PresencesSyncsException> {
        override fun lift(error_buf: RustBuffer.ByValue): PresencesSyncsException = FfiConverterTypePresencesSyncsError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypePresencesSyncsError : FfiConverterRustBuffer<PresencesSyncsException> {
    override fun read(buf: ByteBuffer): PresencesSyncsException =
        when (buf.getInt()) {
            1 -> PresencesSyncsException.NoMoreSyncs()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: PresencesSyncsException): ULong =
        when (value) {
            is PresencesSyncsException.NoMoreSyncs -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
        }

    override fun write(
        value: PresencesSyncsException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is PresencesSyncsException.NoMoreSyncs -> {
                buf.putInt(1)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * [tokio_tungstenite::tungstenite::error::ProtocolError], but with `uniffi` support.
 * Indicates the specific type/cause of a protocol error.
 */
sealed class ProtocolException : kotlin.Exception() {
    /**
     * Use of the wrong HTTP method (the WebSocket protocol requires the GET method be used).
     */
    class WrongHttpMethod : ProtocolException() {
        override val message
            get() = ""
    }

    /**
     * Wrong HTTP version used (the WebSocket protocol requires version 1.1 or higher).
     */
    class WrongHttpVersion : ProtocolException() {
        override val message
            get() = ""
    }

    /**
     * Missing `Connection: upgrade` HTTP header.
     */
    class MissingConnectionUpgradeHeader : ProtocolException() {
        override val message
            get() = ""
    }

    /**
     * Missing `Upgrade: websocket` HTTP header.
     */
    class MissingUpgradeWebSocketHeader : ProtocolException() {
        override val message
            get() = ""
    }

    /**
     * Missing `Sec-WebSocket-Version: 13` HTTP header.
     */
    class MissingSecWebSocketVersionHeader : ProtocolException() {
        override val message
            get() = ""
    }

    /**
     * Missing `Sec-WebSocket-Key` HTTP header.
     */
    class MissingSecWebSocketKey : ProtocolException() {
        override val message
            get() = ""
    }

    /**
     * The `Sec-WebSocket-Accept` header is either not present or does not specify the correct key value.
     */
    class SecWebSocketAcceptKeyMismatch : ProtocolException() {
        override val message
            get() = ""
    }

    /**
     * Garbage data encountered after client request.
     */
    class JunkAfterRequest : ProtocolException() {
        override val message
            get() = ""
    }

    /**
     * Custom responses must be unsuccessful.
     */
    class CustomResponseSuccessful : ProtocolException() {
        override val message
            get() = ""
    }

    /**
     * Invalid header is passed. Or the header is missing in the request. Or not present at all. Check the request that you pass.
     */
    class InvalidHeader(
        val `header`: kotlin.String,
    ) : ProtocolException() {
        override val message
            get() = "header=${ `header` }"
    }

    /**
     * No more data while still performing handshake.
     */
    class HandshakeIncomplete : ProtocolException() {
        override val message
            get() = ""
    }

    /**
     * Wrapper around a [`httparse::Error`] value.
     */
    class HttparseException(
        val `httparseError`: HttParseException,
    ) : ProtocolException() {
        override val message
            get() = "httparseError=${ `httparseError` }"
    }

    /**
     * Not allowed to send after having sent a closing frame.
     */
    class SendAfterClosing : ProtocolException() {
        override val message
            get() = ""
    }

    /**
     * Remote sent data after sending a closing frame.
     */
    class ReceivedAfterClosing : ProtocolException() {
        override val message
            get() = ""
    }

    /**
     * Reserved bits in frame header are non-zero.
     */
    class NonZeroReservedBits : ProtocolException() {
        override val message
            get() = ""
    }

    /**
     * The server must close the connection when an unmasked frame is received.
     */
    class UnmaskedFrameFromClient : ProtocolException() {
        override val message
            get() = ""
    }

    /**
     * The client must close the connection when a masked frame is received.
     */
    class MaskedFrameFromServer : ProtocolException() {
        override val message
            get() = ""
    }

    /**
     * Control frames must not be fragmented.
     */
    class FragmentedControlFrame : ProtocolException() {
        override val message
            get() = ""
    }

    /**
     * Control frames must have a payload of 125 bytes or less.
     */
    class ControlFrameTooBig : ProtocolException() {
        override val message
            get() = ""
    }

    /**
     * Type of control frame not recognised.
     */
    class UnknownControlFrameType(
        val `controlFrameType`: kotlin.UByte,
    ) : ProtocolException() {
        override val message
            get() = "controlFrameType=${ `controlFrameType` }"
    }

    /**
     * Type of data frame not recognised.
     */
    class UnknownDataFrameType(
        val `dataFrameType`: kotlin.UByte,
    ) : ProtocolException() {
        override val message
            get() = "dataFrameType=${ `dataFrameType` }"
    }

    /**
     * Received a continue frame despite there being nothing to continue.
     */
    class UnexpectedContinueFrame : ProtocolException() {
        override val message
            get() = ""
    }

    /**
     * Received data while waiting for more fragments.
     */
    class ExpectedFragment(
        val `data`: TungsteniteData,
    ) : ProtocolException() {
        override val message
            get() = "data=${ `data` }"
    }

    /**
     * Connection closed without performing the closing handshake.
     */
    class ResetWithoutClosingHandshake : ProtocolException() {
        override val message
            get() = ""
    }

    /**
     * Encountered an invalid opcode.
     */
    class InvalidOpcode(
        val `opcode`: kotlin.UByte,
    ) : ProtocolException() {
        override val message
            get() = "opcode=${ `opcode` }"
    }

    /**
     * The payload for the closing frame is invalid.
     */
    class InvalidCloseSequence : ProtocolException() {
        override val message
            get() = ""
    }

    /**
     * The server sent a subprotocol to a client handshake request but none was requested
     */
    class ServerSentSubProtocolNoneRequested : ProtocolException() {
        override val message
            get() = ""
    }

    /**
     * The server sent an invalid subprotocol to a client handhshake request
     */
    class InvalidSubProtocol : ProtocolException() {
        override val message
            get() = ""
    }

    /**
     * The server sent no subprotocol to a client handshake request that requested one or more
     * subprotocols
     */
    class NoSubProtocol : ProtocolException() {
        override val message
            get() = ""
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<ProtocolException> {
        override fun lift(error_buf: RustBuffer.ByValue): ProtocolException = FfiConverterTypeProtocolError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeProtocolError : FfiConverterRustBuffer<ProtocolException> {
    override fun read(buf: ByteBuffer): ProtocolException =
        when (buf.getInt()) {
            1 -> ProtocolException.WrongHttpMethod()
            2 -> ProtocolException.WrongHttpVersion()
            3 -> ProtocolException.MissingConnectionUpgradeHeader()
            4 -> ProtocolException.MissingUpgradeWebSocketHeader()
            5 -> ProtocolException.MissingSecWebSocketVersionHeader()
            6 -> ProtocolException.MissingSecWebSocketKey()
            7 -> ProtocolException.SecWebSocketAcceptKeyMismatch()
            8 -> ProtocolException.JunkAfterRequest()
            9 -> ProtocolException.CustomResponseSuccessful()
            10 ->
                ProtocolException.InvalidHeader(
                    FfiConverterString.read(buf),
                )
            11 -> ProtocolException.HandshakeIncomplete()
            12 ->
                ProtocolException.HttparseException(
                    FfiConverterTypeHTTParseError.read(buf),
                )
            13 -> ProtocolException.SendAfterClosing()
            14 -> ProtocolException.ReceivedAfterClosing()
            15 -> ProtocolException.NonZeroReservedBits()
            16 -> ProtocolException.UnmaskedFrameFromClient()
            17 -> ProtocolException.MaskedFrameFromServer()
            18 -> ProtocolException.FragmentedControlFrame()
            19 -> ProtocolException.ControlFrameTooBig()
            20 ->
                ProtocolException.UnknownControlFrameType(
                    FfiConverterUByte.read(buf),
                )
            21 ->
                ProtocolException.UnknownDataFrameType(
                    FfiConverterUByte.read(buf),
                )
            22 -> ProtocolException.UnexpectedContinueFrame()
            23 ->
                ProtocolException.ExpectedFragment(
                    FfiConverterTypeTungsteniteData.read(buf),
                )
            24 -> ProtocolException.ResetWithoutClosingHandshake()
            25 ->
                ProtocolException.InvalidOpcode(
                    FfiConverterUByte.read(buf),
                )
            26 -> ProtocolException.InvalidCloseSequence()
            27 -> ProtocolException.ServerSentSubProtocolNoneRequested()
            28 -> ProtocolException.InvalidSubProtocol()
            29 -> ProtocolException.NoSubProtocol()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: ProtocolException): ULong =
        when (value) {
            is ProtocolException.WrongHttpMethod -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ProtocolException.WrongHttpVersion -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ProtocolException.MissingConnectionUpgradeHeader -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ProtocolException.MissingUpgradeWebSocketHeader -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ProtocolException.MissingSecWebSocketVersionHeader -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ProtocolException.MissingSecWebSocketKey -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ProtocolException.SecWebSocketAcceptKeyMismatch -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ProtocolException.JunkAfterRequest -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ProtocolException.CustomResponseSuccessful -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ProtocolException.InvalidHeader -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterString.allocationSize(value.`header`)
            )
            is ProtocolException.HandshakeIncomplete -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ProtocolException.HttparseException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeHTTParseError.allocationSize(value.`httparseError`)
            )
            is ProtocolException.SendAfterClosing -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ProtocolException.ReceivedAfterClosing -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ProtocolException.NonZeroReservedBits -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ProtocolException.UnmaskedFrameFromClient -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ProtocolException.MaskedFrameFromServer -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ProtocolException.FragmentedControlFrame -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ProtocolException.ControlFrameTooBig -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ProtocolException.UnknownControlFrameType -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterUByte.allocationSize(value.`controlFrameType`)
            )
            is ProtocolException.UnknownDataFrameType -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterUByte.allocationSize(value.`dataFrameType`)
            )
            is ProtocolException.UnexpectedContinueFrame -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ProtocolException.ExpectedFragment -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeTungsteniteData.allocationSize(value.`data`)
            )
            is ProtocolException.ResetWithoutClosingHandshake -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ProtocolException.InvalidOpcode -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterUByte.allocationSize(value.`opcode`)
            )
            is ProtocolException.InvalidCloseSequence -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ProtocolException.ServerSentSubProtocolNoneRequested -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ProtocolException.InvalidSubProtocol -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is ProtocolException.NoSubProtocol -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
        }

    override fun write(
        value: ProtocolException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is ProtocolException.WrongHttpMethod -> {
                buf.putInt(1)
                Unit
            }
            is ProtocolException.WrongHttpVersion -> {
                buf.putInt(2)
                Unit
            }
            is ProtocolException.MissingConnectionUpgradeHeader -> {
                buf.putInt(3)
                Unit
            }
            is ProtocolException.MissingUpgradeWebSocketHeader -> {
                buf.putInt(4)
                Unit
            }
            is ProtocolException.MissingSecWebSocketVersionHeader -> {
                buf.putInt(5)
                Unit
            }
            is ProtocolException.MissingSecWebSocketKey -> {
                buf.putInt(6)
                Unit
            }
            is ProtocolException.SecWebSocketAcceptKeyMismatch -> {
                buf.putInt(7)
                Unit
            }
            is ProtocolException.JunkAfterRequest -> {
                buf.putInt(8)
                Unit
            }
            is ProtocolException.CustomResponseSuccessful -> {
                buf.putInt(9)
                Unit
            }
            is ProtocolException.InvalidHeader -> {
                buf.putInt(10)
                FfiConverterString.write(value.`header`, buf)
                Unit
            }
            is ProtocolException.HandshakeIncomplete -> {
                buf.putInt(11)
                Unit
            }
            is ProtocolException.HttparseException -> {
                buf.putInt(12)
                FfiConverterTypeHTTParseError.write(value.`httparseError`, buf)
                Unit
            }
            is ProtocolException.SendAfterClosing -> {
                buf.putInt(13)
                Unit
            }
            is ProtocolException.ReceivedAfterClosing -> {
                buf.putInt(14)
                Unit
            }
            is ProtocolException.NonZeroReservedBits -> {
                buf.putInt(15)
                Unit
            }
            is ProtocolException.UnmaskedFrameFromClient -> {
                buf.putInt(16)
                Unit
            }
            is ProtocolException.MaskedFrameFromServer -> {
                buf.putInt(17)
                Unit
            }
            is ProtocolException.FragmentedControlFrame -> {
                buf.putInt(18)
                Unit
            }
            is ProtocolException.ControlFrameTooBig -> {
                buf.putInt(19)
                Unit
            }
            is ProtocolException.UnknownControlFrameType -> {
                buf.putInt(20)
                FfiConverterUByte.write(value.`controlFrameType`, buf)
                Unit
            }
            is ProtocolException.UnknownDataFrameType -> {
                buf.putInt(21)
                FfiConverterUByte.write(value.`dataFrameType`, buf)
                Unit
            }
            is ProtocolException.UnexpectedContinueFrame -> {
                buf.putInt(22)
                Unit
            }
            is ProtocolException.ExpectedFragment -> {
                buf.putInt(23)
                FfiConverterTypeTungsteniteData.write(value.`data`, buf)
                Unit
            }
            is ProtocolException.ResetWithoutClosingHandshake -> {
                buf.putInt(24)
                Unit
            }
            is ProtocolException.InvalidOpcode -> {
                buf.putInt(25)
                FfiConverterUByte.write(value.`opcode`, buf)
                Unit
            }
            is ProtocolException.InvalidCloseSequence -> {
                buf.putInt(26)
                Unit
            }
            is ProtocolException.ServerSentSubProtocolNoneRequested -> {
                buf.putInt(27)
                Unit
            }
            is ProtocolException.InvalidSubProtocol -> {
                buf.putInt(28)
                Unit
            }
            is ProtocolException.NoSubProtocol -> {
                buf.putInt(29)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * Errors when calling [Socket::channel]
 */
sealed class SocketChannelException : kotlin.Exception() {
    /**
     * The shutdown error for this SocketChannelError
     */
    class Shutdown(
        /**
         * The shutdown error for this shutdown
         */
        val `shutdownError`: SocketShutdownException,
    ) : SocketChannelException() {
        override val message
            get() = "shutdownError=${ `shutdownError` }"
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<SocketChannelException> {
        override fun lift(error_buf: RustBuffer.ByValue): SocketChannelException = FfiConverterTypeSocketChannelError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeSocketChannelError : FfiConverterRustBuffer<SocketChannelException> {
    override fun read(buf: ByteBuffer): SocketChannelException =
        when (buf.getInt()) {
            1 ->
                SocketChannelException.Shutdown(
                    FfiConverterTypeSocketShutdownError.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: SocketChannelException): ULong =
        when (value) {
            is SocketChannelException.Shutdown -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeSocketShutdownError.allocationSize(value.`shutdownError`)
            )
        }

    override fun write(
        value: SocketChannelException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is SocketChannelException.Shutdown -> {
                buf.putInt(1)
                FfiConverterTypeSocketShutdownError.write(value.`shutdownError`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * Errors when calling [Socket] functions.
 */
sealed class SocketException : kotlin.Exception() {
    /**
     * Error when calling [Socket::spawn].
     */
    class Spawn(
        /**
         * Represents errors that occur from [`Socket::spawn`]
         */
        val `spawnError`: SpawnException,
    ) : SocketException() {
        override val message
            get() = "spawnError=${ `spawnError` }"
    }

    /**
     * Error when calling [Socket::connect].
     */
    class Connect(
        /**
         * Errors from [Socket::connect].
         */
        val `connectError`: ConnectException,
    ) : SocketException() {
        override val message
            get() = "connectError=${ `connectError` }"
    }

    /**
     * Error when calling [Socket::channel].
     */
    class Channel(
        /**
         * Errors when calling [Socket::channel]
         */
        val `channelError`: SocketChannelException,
    ) : SocketException() {
        override val message
            get() = "channelError=${ `channelError` }"
    }

    /**
     * Error when calling [Socket::disconnect].
     */
    class Disconnect(
        /**
         * Error when calling [Socket::disconnect]
         */
        val `disconnectError`: DisconnectException,
    ) : SocketException() {
        override val message
            get() = "disconnectError=${ `disconnectError` }"
    }

    /**
     * Error when calling [Socket::shutdown].
     */
    class Shutdown(
        /**
         * Error from [Socket::shutdown] or from the server itself that caused the [Socket] to shutdown.
         */
        val `shutdownError`: SocketShutdownException,
    ) : SocketException() {
        override val message
            get() = "shutdownError=${ `shutdownError` }"
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<SocketException> {
        override fun lift(error_buf: RustBuffer.ByValue): SocketException = FfiConverterTypeSocketError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeSocketError : FfiConverterRustBuffer<SocketException> {
    override fun read(buf: ByteBuffer): SocketException =
        when (buf.getInt()) {
            1 ->
                SocketException.Spawn(
                    FfiConverterTypeSpawnError.read(buf),
                )
            2 ->
                SocketException.Connect(
                    FfiConverterTypeConnectError.read(buf),
                )
            3 ->
                SocketException.Channel(
                    FfiConverterTypeSocketChannelError.read(buf),
                )
            4 ->
                SocketException.Disconnect(
                    FfiConverterTypeDisconnectError.read(buf),
                )
            5 ->
                SocketException.Shutdown(
                    FfiConverterTypeSocketShutdownError.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: SocketException): ULong =
        when (value) {
            is SocketException.Spawn -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeSpawnError.allocationSize(value.`spawnError`)
            )
            is SocketException.Connect -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeConnectError.allocationSize(value.`connectError`)
            )
            is SocketException.Channel -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeSocketChannelError.allocationSize(value.`channelError`)
            )
            is SocketException.Disconnect -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeDisconnectError.allocationSize(value.`disconnectError`)
            )
            is SocketException.Shutdown -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeSocketShutdownError.allocationSize(value.`shutdownError`)
            )
        }

    override fun write(
        value: SocketException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is SocketException.Spawn -> {
                buf.putInt(1)
                FfiConverterTypeSpawnError.write(value.`spawnError`, buf)
                Unit
            }
            is SocketException.Connect -> {
                buf.putInt(2)
                FfiConverterTypeConnectError.write(value.`connectError`, buf)
                Unit
            }
            is SocketException.Channel -> {
                buf.putInt(3)
                FfiConverterTypeSocketChannelError.write(value.`channelError`, buf)
                Unit
            }
            is SocketException.Disconnect -> {
                buf.putInt(4)
                FfiConverterTypeDisconnectError.write(value.`disconnectError`, buf)
                Unit
            }
            is SocketException.Shutdown -> {
                buf.putInt(5)
                FfiConverterTypeSocketShutdownError.write(value.`shutdownError`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * Error from [Socket::shutdown] or from the server itself that caused the [Socket] to shutdown.
 */
sealed class SocketShutdownException : kotlin.Exception() {
    /**
     * The async task was already joined by another call, so the [Result] or panic from the async
     * task can't be reported here.
     */
    class AlreadyJoined : SocketShutdownException() {
        override val message
            get() = ""
    }

    /**
     * [CVE-2023-43669](https://nvd.nist.gov/vuln/detail/CVE-2023-43669) attack attempt
     */
    class AttackAttempt : SocketShutdownException() {
        override val message
            get() = ""
    }

    /**
     * Invalid URL.
     */
    class Url(
        val `urlError`: kotlin.String,
    ) : SocketShutdownException() {
        override val message
            get() = "urlError=${ `urlError` }"
    }

    /**
     * HTTP error.
     */
    class Http(
        val `response`: Response,
    ) : SocketShutdownException() {
        override val message
            get() = "response=${ `response` }"
    }

    /**
     * HTTP format error.
     */
    class HttpFormat(
        val `error`: HttpException,
    ) : SocketShutdownException() {
        override val message
            get() = "error=${ `error` }"
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<SocketShutdownException> {
        override fun lift(error_buf: RustBuffer.ByValue): SocketShutdownException = FfiConverterTypeSocketShutdownError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeSocketShutdownError : FfiConverterRustBuffer<SocketShutdownException> {
    override fun read(buf: ByteBuffer): SocketShutdownException =
        when (buf.getInt()) {
            1 -> SocketShutdownException.AlreadyJoined()
            2 -> SocketShutdownException.AttackAttempt()
            3 ->
                SocketShutdownException.Url(
                    FfiConverterString.read(buf),
                )
            4 ->
                SocketShutdownException.Http(
                    FfiConverterTypeResponse.read(buf),
                )
            5 ->
                SocketShutdownException.HttpFormat(
                    FfiConverterTypeHttpError.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: SocketShutdownException): ULong =
        when (value) {
            is SocketShutdownException.AlreadyJoined -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is SocketShutdownException.AttackAttempt -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is SocketShutdownException.Url -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterString.allocationSize(value.`urlError`)
            )
            is SocketShutdownException.Http -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeResponse.allocationSize(value.`response`)
            )
            is SocketShutdownException.HttpFormat -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeHttpError.allocationSize(value.`error`)
            )
        }

    override fun write(
        value: SocketShutdownException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is SocketShutdownException.AlreadyJoined -> {
                buf.putInt(1)
                Unit
            }
            is SocketShutdownException.AttackAttempt -> {
                buf.putInt(2)
                Unit
            }
            is SocketShutdownException.Url -> {
                buf.putInt(3)
                FfiConverterString.write(value.`urlError`, buf)
                Unit
            }
            is SocketShutdownException.Http -> {
                buf.putInt(4)
                FfiConverterTypeResponse.write(value.`response`, buf)
                Unit
            }
            is SocketShutdownException.HttpFormat -> {
                buf.putInt(5)
                FfiConverterTypeHttpError.write(value.`error`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * The status of the [Socket].
 */
sealed class SocketStatus {
    /**
     * [Socket::connect] has never been called.
     */
    object NeverConnected : SocketStatus()

    /**
     * [Socket::connect] was called and server responded the socket is connected.
     */
    object Connected : SocketStatus()

    /**
     * [Socket::connect] was called previously, but the [Socket] was disconnected by the server and
     * [Socket] needs to wait to reconnect.
     */
    data class WaitingToReconnect(
        /**
         * When the [Socket] will automatically [Socket::connect] next.
         */
        val `until`: java.time.Instant,
    ) : SocketStatus() {
        companion object
    }

    /**
     * [Socket::disconnect] was called and the server responded that the socket as disconnected.
     */
    object Disconnected : SocketStatus()

    /**
     * [Socket::shutdown] was called, but the async task hasn't exited yet.
     */
    object ShuttingDown : SocketStatus()

    /**
     * The async task has exited.
     */
    object ShutDown : SocketStatus()

    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeSocketStatus : FfiConverterRustBuffer<SocketStatus> {
    override fun read(buf: ByteBuffer): SocketStatus =
        when (buf.getInt()) {
            1 -> SocketStatus.NeverConnected
            2 -> SocketStatus.Connected
            3 ->
                SocketStatus.WaitingToReconnect(
                    FfiConverterTimestamp.read(buf),
                )
            4 -> SocketStatus.Disconnected
            5 -> SocketStatus.ShuttingDown
            6 -> SocketStatus.ShutDown
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }

    override fun allocationSize(value: SocketStatus) =
        when (value) {
            is SocketStatus.NeverConnected -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is SocketStatus.Connected -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is SocketStatus.WaitingToReconnect -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterTimestamp.allocationSize(value.`until`)
                )
            }
            is SocketStatus.Disconnected -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is SocketStatus.ShuttingDown -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is SocketStatus.ShutDown -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
        }

    override fun write(
        value: SocketStatus,
        buf: ByteBuffer,
    ) {
        when (value) {
            is SocketStatus.NeverConnected -> {
                buf.putInt(1)
                Unit
            }
            is SocketStatus.Connected -> {
                buf.putInt(2)
                Unit
            }
            is SocketStatus.WaitingToReconnect -> {
                buf.putInt(3)
                FfiConverterTimestamp.write(value.`until`, buf)
                Unit
            }
            is SocketStatus.Disconnected -> {
                buf.putInt(4)
                Unit
            }
            is SocketStatus.ShuttingDown -> {
                buf.putInt(5)
                Unit
            }
            is SocketStatus.ShutDown -> {
                buf.putInt(6)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * Represents errors that occur from [`Socket::spawn`]
 */
sealed class SpawnException(
    message: String,
) : kotlin.Exception(message) {
    /**
     * Occurs when the configured url's scheme is not ws or wss.
     */
    class UnsupportedScheme(
        message: String,
    ) : SpawnException(message)

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<SpawnException> {
        override fun lift(error_buf: RustBuffer.ByValue): SpawnException = FfiConverterTypeSpawnError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeSpawnError : FfiConverterRustBuffer<SpawnException> {
    override fun read(buf: ByteBuffer): SpawnException =
        when (buf.getInt()) {
            1 -> SpawnException.UnsupportedScheme(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: SpawnException): ULong = 4UL

    override fun write(
        value: SpawnException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is SpawnException.UnsupportedScheme -> {
                buf.putInt(1)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * Wraps [tokio::sync::broadcast::error::RecvError] to add `uniffi` support and names specific to
 * [ChannelStatuses](crate::ChannelStatuses).
 */
sealed class StatusesException : kotlin.Exception() {
    /**
     * No more statuses
     */
    class NoMoreStatuses : StatusesException() {
        override val message
            get() = ""
    }

    /**
     * Missed statuses, jump to the next status
     */
    class MissedStatuses(
        /**
         * Number of missed statuses.
         */
        val `missedStatusCount`: kotlin.ULong,
    ) : StatusesException() {
        override val message
            get() = "missedStatusCount=${ `missedStatusCount` }"
    }

    /**
     * Failed to join a Channel (due to rejection).
     */
    class ChannelStatusJoin(
        /**
         * The join Error
         */
        val `joinError`: ChannelStatusJoinException,
    ) : StatusesException() {
        override val message
            get() = "joinError=${ `joinError` }"
    }

    /**
     * An error with WebSockets
     */
    class WebSocket(
        /**
         * The websocket error
         */
        val `websocketError`: WebSocketException,
    ) : StatusesException() {
        override val message
            get() = "websocketError=${ `websocketError` }"
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<StatusesException> {
        override fun lift(error_buf: RustBuffer.ByValue): StatusesException = FfiConverterTypeStatusesError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeStatusesError : FfiConverterRustBuffer<StatusesException> {
    override fun read(buf: ByteBuffer): StatusesException =
        when (buf.getInt()) {
            1 -> StatusesException.NoMoreStatuses()
            2 ->
                StatusesException.MissedStatuses(
                    FfiConverterULong.read(buf),
                )
            3 ->
                StatusesException.ChannelStatusJoin(
                    FfiConverterTypeChannelStatusJoinError.read(buf),
                )
            4 ->
                StatusesException.WebSocket(
                    FfiConverterTypeWebSocketError.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: StatusesException): ULong =
        when (value) {
            is StatusesException.NoMoreStatuses -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is StatusesException.MissedStatuses -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterULong.allocationSize(value.`missedStatusCount`)
            )
            is StatusesException.ChannelStatusJoin -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeChannelStatusJoinError.allocationSize(value.`joinError`)
            )
            is StatusesException.WebSocket -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeWebSocketError.allocationSize(value.`websocketError`)
            )
        }

    override fun write(
        value: StatusesException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is StatusesException.NoMoreStatuses -> {
                buf.putInt(1)
                Unit
            }
            is StatusesException.MissedStatuses -> {
                buf.putInt(2)
                FfiConverterULong.write(value.`missedStatusCount`, buf)
                Unit
            }
            is StatusesException.ChannelStatusJoin -> {
                buf.putInt(3)
                FfiConverterTypeChannelStatusJoinError.write(value.`joinError`, buf)
                Unit
            }
            is StatusesException.WebSocket -> {
                buf.putInt(4)
                FfiConverterTypeWebSocketError.write(value.`websocketError`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * [tokio_tungstenite::tungstenite::protocol::frame::coding::CloseCode], but with `uniffi::support`
 * Status code used to indicate why an endpoint is closing the WebSocket connection.
 */
sealed class TungsteniteCloseCode {
    /**
     * Indicates a normal closure, meaning that the purpose for
     * which the connection was established has been fulfilled.
     */
    object Normal : TungsteniteCloseCode()

    /**
     * Indicates that an endpoint is "going away", such as a server
     * going down or a browser having navigated away from a page.
     */
    object Away : TungsteniteCloseCode()

    /**
     * Indicates that an endpoint is terminating the connection due
     * to a protocol error.
     */
    object Protocol : TungsteniteCloseCode()

    /**
     * Indicates that an endpoint is terminating the connection
     * because it has received a type of data it cannot accept (e.g., an
     * endpoint that understands only text data MAY send this if it
     * receives a binary message).
     */
    object Unsupported : TungsteniteCloseCode()

    /**
     * Indicates that no status code was included in a closing frame. This
     * close code makes it possible to use a single method, `on_close` to
     * handle even cases where no close code was provided.
     */
    object Status : TungsteniteCloseCode()

    /**
     * Indicates an abnormal closure. If the abnormal closure was due to an
     * error, this close code will not be used. Instead, the `on_error` method
     * of the handler will be called with the error. However, if the connection
     * is simply dropped, without an error, this close code will be sent to the
     * handler.
     */
    object Abnormal : TungsteniteCloseCode()

    /**
     * Indicates that an endpoint is terminating the connection
     * because it has received data within a message that was not
     * consistent with the type of the message (e.g., non-UTF-8 \[RFC3629\]
     * data within a text message).
     */
    object Invalid : TungsteniteCloseCode()

    /**
     * Indicates that an endpoint is terminating the connection
     * because it has received a message that violates its policy.  This
     * is a generic status code that can be returned when there is no
     * other more suitable status code (e.g., Unsupported or Size) or if there
     * is a need to hide specific details about the policy.
     */
    object Policy : TungsteniteCloseCode()

    /**
     * Indicates that an endpoint is terminating the connection
     * because it has received a message that is too big for it to
     * process.
     */
    object Size : TungsteniteCloseCode()

    /**
     * Indicates that an endpoint (client) is terminating the
     * connection because it has expected the server to negotiate one or
     * more extension, but the server didn't return them in the response
     * message of the WebSocket handshake.  The list of extensions that
     * are needed should be given as the reason for closing.
     * Note that this status code is not used by the server, because it
     * can fail the WebSocket handshake instead.
     */
    object Extension : TungsteniteCloseCode()

    /**
     * Indicates that a server is terminating the connection because
     * it encountered an unexpected condition that prevented it from
     * fulfilling the request.
     */
    object Error : TungsteniteCloseCode()

    /**
     * Indicates that the server is restarting. A client may choose to reconnect,
     * and if it does, it should use a randomized delay of 5-30 seconds between attempts.
     */
    object Restart : TungsteniteCloseCode()

    /**
     * Indicates that the server is overloaded and the client should either connect
     * to a different IP (when multiple targets exist), or reconnect to the same IP
     * when a user has performed an action.
     */
    object Again : TungsteniteCloseCode()

    object Tls : TungsteniteCloseCode()

    data class Reserved(
        val `code`: kotlin.UShort,
    ) : TungsteniteCloseCode() {
        companion object
    }

    data class Iana(
        val `code`: kotlin.UShort,
    ) : TungsteniteCloseCode() {
        companion object
    }

    data class Library(
        val `code`: kotlin.UShort,
    ) : TungsteniteCloseCode() {
        companion object
    }

    data class Bad(
        val `code`: kotlin.UShort,
    ) : TungsteniteCloseCode() {
        companion object
    }

    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTungsteniteCloseCode : FfiConverterRustBuffer<TungsteniteCloseCode> {
    override fun read(buf: ByteBuffer): TungsteniteCloseCode =
        when (buf.getInt()) {
            1 -> TungsteniteCloseCode.Normal
            2 -> TungsteniteCloseCode.Away
            3 -> TungsteniteCloseCode.Protocol
            4 -> TungsteniteCloseCode.Unsupported
            5 -> TungsteniteCloseCode.Status
            6 -> TungsteniteCloseCode.Abnormal
            7 -> TungsteniteCloseCode.Invalid
            8 -> TungsteniteCloseCode.Policy
            9 -> TungsteniteCloseCode.Size
            10 -> TungsteniteCloseCode.Extension
            11 -> TungsteniteCloseCode.Error
            12 -> TungsteniteCloseCode.Restart
            13 -> TungsteniteCloseCode.Again
            14 -> TungsteniteCloseCode.Tls
            15 ->
                TungsteniteCloseCode.Reserved(
                    FfiConverterUShort.read(buf),
                )
            16 ->
                TungsteniteCloseCode.Iana(
                    FfiConverterUShort.read(buf),
                )
            17 ->
                TungsteniteCloseCode.Library(
                    FfiConverterUShort.read(buf),
                )
            18 ->
                TungsteniteCloseCode.Bad(
                    FfiConverterUShort.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }

    override fun allocationSize(value: TungsteniteCloseCode) =
        when (value) {
            is TungsteniteCloseCode.Normal -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is TungsteniteCloseCode.Away -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is TungsteniteCloseCode.Protocol -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is TungsteniteCloseCode.Unsupported -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is TungsteniteCloseCode.Status -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is TungsteniteCloseCode.Abnormal -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is TungsteniteCloseCode.Invalid -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is TungsteniteCloseCode.Policy -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is TungsteniteCloseCode.Size -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is TungsteniteCloseCode.Extension -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is TungsteniteCloseCode.Error -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is TungsteniteCloseCode.Restart -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is TungsteniteCloseCode.Again -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is TungsteniteCloseCode.Tls -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is TungsteniteCloseCode.Reserved -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterUShort.allocationSize(value.`code`)
                )
            }
            is TungsteniteCloseCode.Iana -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterUShort.allocationSize(value.`code`)
                )
            }
            is TungsteniteCloseCode.Library -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterUShort.allocationSize(value.`code`)
                )
            }
            is TungsteniteCloseCode.Bad -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterUShort.allocationSize(value.`code`)
                )
            }
        }

    override fun write(
        value: TungsteniteCloseCode,
        buf: ByteBuffer,
    ) {
        when (value) {
            is TungsteniteCloseCode.Normal -> {
                buf.putInt(1)
                Unit
            }
            is TungsteniteCloseCode.Away -> {
                buf.putInt(2)
                Unit
            }
            is TungsteniteCloseCode.Protocol -> {
                buf.putInt(3)
                Unit
            }
            is TungsteniteCloseCode.Unsupported -> {
                buf.putInt(4)
                Unit
            }
            is TungsteniteCloseCode.Status -> {
                buf.putInt(5)
                Unit
            }
            is TungsteniteCloseCode.Abnormal -> {
                buf.putInt(6)
                Unit
            }
            is TungsteniteCloseCode.Invalid -> {
                buf.putInt(7)
                Unit
            }
            is TungsteniteCloseCode.Policy -> {
                buf.putInt(8)
                Unit
            }
            is TungsteniteCloseCode.Size -> {
                buf.putInt(9)
                Unit
            }
            is TungsteniteCloseCode.Extension -> {
                buf.putInt(10)
                Unit
            }
            is TungsteniteCloseCode.Error -> {
                buf.putInt(11)
                Unit
            }
            is TungsteniteCloseCode.Restart -> {
                buf.putInt(12)
                Unit
            }
            is TungsteniteCloseCode.Again -> {
                buf.putInt(13)
                Unit
            }
            is TungsteniteCloseCode.Tls -> {
                buf.putInt(14)
                Unit
            }
            is TungsteniteCloseCode.Reserved -> {
                buf.putInt(15)
                FfiConverterUShort.write(value.`code`, buf)
                Unit
            }
            is TungsteniteCloseCode.Iana -> {
                buf.putInt(16)
                FfiConverterUShort.write(value.`code`, buf)
                Unit
            }
            is TungsteniteCloseCode.Library -> {
                buf.putInt(17)
                FfiConverterUShort.write(value.`code`, buf)
                Unit
            }
            is TungsteniteCloseCode.Bad -> {
                buf.putInt(18)
                FfiConverterUShort.write(value.`code`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * [tokio_tungstenite::tungstenite::protocol::frame::coding::Control], but with `uniffi` support.
 * Control opcodes as in RFC 6455
 */
sealed class TungsteniteControl {
    /**
     * 0x8 denotes a connection close
     */
    object Close : TungsteniteControl()

    /**
     * 0x9 denotes a ping
     */
    object Ping : TungsteniteControl()

    /**
     * 0xa denotes a pong
     */
    object Pong : TungsteniteControl()

    /**
     * 0xb-f are reserved for further control frames
     */
    data class Reserved(
        val `bit`: kotlin.UByte,
    ) : TungsteniteControl() {
        companion object
    }

    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTungsteniteControl : FfiConverterRustBuffer<TungsteniteControl> {
    override fun read(buf: ByteBuffer): TungsteniteControl =
        when (buf.getInt()) {
            1 -> TungsteniteControl.Close
            2 -> TungsteniteControl.Ping
            3 -> TungsteniteControl.Pong
            4 ->
                TungsteniteControl.Reserved(
                    FfiConverterUByte.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }

    override fun allocationSize(value: TungsteniteControl) =
        when (value) {
            is TungsteniteControl.Close -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is TungsteniteControl.Ping -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is TungsteniteControl.Pong -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is TungsteniteControl.Reserved -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterUByte.allocationSize(value.`bit`)
                )
            }
        }

    override fun write(
        value: TungsteniteControl,
        buf: ByteBuffer,
    ) {
        when (value) {
            is TungsteniteControl.Close -> {
                buf.putInt(1)
                Unit
            }
            is TungsteniteControl.Ping -> {
                buf.putInt(2)
                Unit
            }
            is TungsteniteControl.Pong -> {
                buf.putInt(3)
                Unit
            }
            is TungsteniteControl.Reserved -> {
                buf.putInt(4)
                FfiConverterUByte.write(value.`bit`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * [tokio_tungstenite::tungstenite::protocol::frame::coding::Data], but with `uniffi` support.
 * Data opcodes as in RFC 6455
 */
sealed class TungsteniteData {
    /**
     * 0x0 denotes a continuation frame
     */
    object Continue : TungsteniteData()

    /**
     * 0x1 denotes a text frame
     */
    object Text : TungsteniteData()

    /**
     * 0x2 denotes a binary frame
     */
    object Binary : TungsteniteData()

    /**
     * 0x3-7 are reserved for further non-control frames
     */
    data class Reserved(
        val `bits`: kotlin.UByte,
    ) : TungsteniteData() {
        companion object
    }

    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTungsteniteData : FfiConverterRustBuffer<TungsteniteData> {
    override fun read(buf: ByteBuffer): TungsteniteData =
        when (buf.getInt()) {
            1 -> TungsteniteData.Continue
            2 -> TungsteniteData.Text
            3 -> TungsteniteData.Binary
            4 ->
                TungsteniteData.Reserved(
                    FfiConverterUByte.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }

    override fun allocationSize(value: TungsteniteData) =
        when (value) {
            is TungsteniteData.Continue -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is TungsteniteData.Text -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is TungsteniteData.Binary -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL
                )
            }
            is TungsteniteData.Reserved -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterUByte.allocationSize(value.`bits`)
                )
            }
        }

    override fun write(
        value: TungsteniteData,
        buf: ByteBuffer,
    ) {
        when (value) {
            is TungsteniteData.Continue -> {
                buf.putInt(1)
                Unit
            }
            is TungsteniteData.Text -> {
                buf.putInt(2)
                Unit
            }
            is TungsteniteData.Binary -> {
                buf.putInt(3)
                Unit
            }
            is TungsteniteData.Reserved -> {
                buf.putInt(4)
                FfiConverterUByte.write(value.`bits`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * [tokio_tungstenite::tungstenite::protocol::frame::coding::OpCode], but with `uniffi` support
 * WebSocket message opcode as in RFC 6455.
 */
sealed class TungsteniteOpCode {
    /**
     * Data (text or binary).
     */
    data class Data(
        val `data`: TungsteniteData,
    ) : TungsteniteOpCode() {
        companion object
    }

    /**
     * Control message (close, ping, pong).
     */
    data class Control(
        val `control`: TungsteniteControl,
    ) : TungsteniteOpCode() {
        companion object
    }

    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeTungsteniteOpCode : FfiConverterRustBuffer<TungsteniteOpCode> {
    override fun read(buf: ByteBuffer): TungsteniteOpCode =
        when (buf.getInt()) {
            1 ->
                TungsteniteOpCode.Data(
                    FfiConverterTypeTungsteniteData.read(buf),
                )
            2 ->
                TungsteniteOpCode.Control(
                    FfiConverterTypeTungsteniteControl.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }

    override fun allocationSize(value: TungsteniteOpCode) =
        when (value) {
            is TungsteniteOpCode.Data -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterTypeTungsteniteData.allocationSize(value.`data`)
                )
            }
            is TungsteniteOpCode.Control -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterTypeTungsteniteControl.allocationSize(value.`control`)
                )
            }
        }

    override fun write(
        value: TungsteniteOpCode,
        buf: ByteBuffer,
    ) {
        when (value) {
            is TungsteniteOpCode.Data -> {
                buf.putInt(1)
                FfiConverterTypeTungsteniteData.write(value.`data`, buf)
                Unit
            }
            is TungsteniteOpCode.Control -> {
                buf.putInt(2)
                FfiConverterTypeTungsteniteControl.write(value.`control`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * A uniffi supported wrapper around [uniffi::Error].
 */
sealed class UrlParseException : kotlin.Exception() {
    /**
     * Empty host
     */
    class EmptyHost : UrlParseException() {
        override val message
            get() = ""
    }

    /**
     * Invalid international domain
     */
    class IdnaException : UrlParseException() {
        override val message
            get() = ""
    }

    /**
     * Invalid port number
     */
    class InvalidPort : UrlParseException() {
        override val message
            get() = ""
    }

    /**
     * Invalid ipv4 address.
     */
    class InvalidIpv4Address : UrlParseException() {
        override val message
            get() = ""
    }

    /**
     * Invalid ipv6 address.
     */
    class InvalidIpv6Address : UrlParseException() {
        override val message
            get() = ""
    }

    /**
     * Invalid domain character
     */
    class InvalidDomainCharacter : UrlParseException() {
        override val message
            get() = ""
    }

    /**
     * Relative URL without a base
     */
    class RelativeUrlWithoutBase : UrlParseException() {
        override val message
            get() = ""
    }

    /**
     * Relative URL with a cannot-be-a-base base"
     */
    class RelativeUrlWithCannotBeABaseBase : UrlParseException() {
        override val message
            get() = ""
    }

    /**
     * A cannot-be-a-base URL doesn’t have a host to set
     */
    class SetHostOnCannotBeABaseUrl : UrlParseException() {
        override val message
            get() = ""
    }

    /**
     * URLs more than 4 GB are not supported
     */
    class Overflow : UrlParseException() {
        override val message
            get() = ""
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<UrlParseException> {
        override fun lift(error_buf: RustBuffer.ByValue): UrlParseException = FfiConverterTypeURLParseError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeURLParseError : FfiConverterRustBuffer<UrlParseException> {
    override fun read(buf: ByteBuffer): UrlParseException =
        when (buf.getInt()) {
            1 -> UrlParseException.EmptyHost()
            2 -> UrlParseException.IdnaException()
            3 -> UrlParseException.InvalidPort()
            4 -> UrlParseException.InvalidIpv4Address()
            5 -> UrlParseException.InvalidIpv6Address()
            6 -> UrlParseException.InvalidDomainCharacter()
            7 -> UrlParseException.RelativeUrlWithoutBase()
            8 -> UrlParseException.RelativeUrlWithCannotBeABaseBase()
            9 -> UrlParseException.SetHostOnCannotBeABaseUrl()
            10 -> UrlParseException.Overflow()
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: UrlParseException): ULong =
        when (value) {
            is UrlParseException.EmptyHost -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is UrlParseException.IdnaException -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is UrlParseException.InvalidPort -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is UrlParseException.InvalidIpv4Address -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is UrlParseException.InvalidIpv6Address -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is UrlParseException.InvalidDomainCharacter -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is UrlParseException.RelativeUrlWithoutBase -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is UrlParseException.RelativeUrlWithCannotBeABaseBase -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is UrlParseException.SetHostOnCannotBeABaseUrl -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is UrlParseException.Overflow -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
        }

    override fun write(
        value: UrlParseException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is UrlParseException.EmptyHost -> {
                buf.putInt(1)
                Unit
            }
            is UrlParseException.IdnaException -> {
                buf.putInt(2)
                Unit
            }
            is UrlParseException.InvalidPort -> {
                buf.putInt(3)
                Unit
            }
            is UrlParseException.InvalidIpv4Address -> {
                buf.putInt(4)
                Unit
            }
            is UrlParseException.InvalidIpv6Address -> {
                buf.putInt(5)
                Unit
            }
            is UrlParseException.InvalidDomainCharacter -> {
                buf.putInt(6)
                Unit
            }
            is UrlParseException.RelativeUrlWithoutBase -> {
                buf.putInt(7)
                Unit
            }
            is UrlParseException.RelativeUrlWithCannotBeABaseBase -> {
                buf.putInt(8)
                Unit
            }
            is UrlParseException.SetHostOnCannotBeABaseUrl -> {
                buf.putInt(9)
                Unit
            }
            is UrlParseException.Overflow -> {
                buf.putInt(10)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * [tokio_tungstenite::tungstenite::error::Error], but with `uniffi` support
 */
sealed class WebSocketException : kotlin.Exception() {
    /**
     * WebSocket connection closed normally. This informs you of the close.
     * It's not an error as such and nothing wrong happened.
     *
     * This is returned as soon as the close handshake is finished (we have both sent and
     * received a close frame) on the server end and as soon as the server has closed the
     * underlying connection if this endpoint is a client.
     *
     * Thus when you receive this, it is safe to drop the underlying connection.
     *
     * Receiving this error means that the WebSocket object is not usable anymore and the
     * only meaningful action with it is dropping it.
     */
    class ConnectionClosed : WebSocketException() {
        override val message
            get() = ""
    }

    /**
     * Trying to work with already closed connection.
     *
     * Trying to read or write after receiving `ConnectionClosed` causes this.
     *
     * As opposed to `ConnectionClosed`, this indicates your code tries to operate on the
     * connection when it really shouldn't anymore, so this really indicates a programmer
     * error on your part.
     */
    class AlreadyClosed : WebSocketException() {
        override val message
            get() = ""
    }

    /**
     * Input-output error. Apart from WouldBlock, these are generally errors with the
     * underlying connection and you should probably consider them fatal.
     */
    class Io(
        /**
         * Input-output error. Apart from WouldBlock, these are generally errors with the
         * underlying connection and you should probably consider them fatal.
         */
        val `ioError`: IoException,
    ) : WebSocketException() {
        override val message
            get() = "ioError=${ `ioError` }"
    }

    /**
     * TLS error.
     */
    class Tls(
        /**
         * TLS error
         */
        val `tlsError`: kotlin.String,
    ) : WebSocketException() {
        override val message
            get() = "tlsError=${ `tlsError` }"
    }

    /**
     * - When reading: buffer capacity exhausted.
     * - When writing: your message is bigger than the configured max message size
     * (64MB by default).
     */
    class Capacity(
        /**
         * When there are too many headers or the message is too long
         */
        val `capacityError`: CapacityException,
    ) : WebSocketException() {
        override val message
            get() = "capacityError=${ `capacityError` }"
    }

    /**
     * Protocol violation.
     */
    class Protocol(
        /**
         * Protocol violation
         */
        val `protocolError`: ProtocolException,
    ) : WebSocketException() {
        override val message
            get() = "protocolError=${ `protocolError` }"
    }

    /**
     * Message write buffer is full.
     */
    class WriteBufferFull(
        /**
         * The [WebSocketMessage] that could not fit in the write buffer.  It should be resent
         * later or the error needs to propagate up.
         */
        val `msg`: WebSocketMessage,
    ) : WebSocketException() {
        override val message
            get() = "msg=${ `msg` }"
    }

    /**
     * UTF coding error.
     */
    class Utf8 : WebSocketException() {
        override val message
            get() = ""
    }

    /**
     * [CVE-2023-43669](https://nvd.nist.gov/vuln/detail/CVE-2023-43669) attack attempt
     */
    class AttackAttempt : WebSocketException() {
        override val message
            get() = ""
    }

    /**
     * Invalid URL.
     */
    class Url(
        /**
         * The URL error as a string
         */
        val `urlError`: kotlin.String,
    ) : WebSocketException() {
        override val message
            get() = "urlError=${ `urlError` }"
    }

    /**
     * HTTP error.
     */
    class Http(
        /**
         * Error response from the server.
         */
        val `response`: Response,
    ) : WebSocketException() {
        override val message
            get() = "response=${ `response` }"
    }

    /**
     * HTTP format error.
     */
    class HttpFormat(
        /**
         * HTTP format error.
         */
        val `error`: HttpException,
    ) : WebSocketException() {
        override val message
            get() = "error=${ `error` }"
    }

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<WebSocketException> {
        override fun lift(error_buf: RustBuffer.ByValue): WebSocketException = FfiConverterTypeWebSocketError.lift(error_buf)
    }
}

/**
 * @suppress
 */
public object FfiConverterTypeWebSocketError : FfiConverterRustBuffer<WebSocketException> {
    override fun read(buf: ByteBuffer): WebSocketException =
        when (buf.getInt()) {
            1 -> WebSocketException.ConnectionClosed()
            2 -> WebSocketException.AlreadyClosed()
            3 ->
                WebSocketException.Io(
                    FfiConverterTypeIoError.read(buf),
                )
            4 ->
                WebSocketException.Tls(
                    FfiConverterString.read(buf),
                )
            5 ->
                WebSocketException.Capacity(
                    FfiConverterTypeCapacityError.read(buf),
                )
            6 ->
                WebSocketException.Protocol(
                    FfiConverterTypeProtocolError.read(buf),
                )
            7 ->
                WebSocketException.WriteBufferFull(
                    FfiConverterTypeWebSocketMessage.read(buf),
                )
            8 -> WebSocketException.Utf8()
            9 -> WebSocketException.AttackAttempt()
            10 ->
                WebSocketException.Url(
                    FfiConverterString.read(buf),
                )
            11 ->
                WebSocketException.Http(
                    FfiConverterTypeResponse.read(buf),
                )
            12 ->
                WebSocketException.HttpFormat(
                    FfiConverterTypeHttpError.read(buf),
                )
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }

    override fun allocationSize(value: WebSocketException): ULong =
        when (value) {
            is WebSocketException.ConnectionClosed -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is WebSocketException.AlreadyClosed -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is WebSocketException.Io -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeIoError.allocationSize(value.`ioError`)
            )
            is WebSocketException.Tls -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterString.allocationSize(value.`tlsError`)
            )
            is WebSocketException.Capacity -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeCapacityError.allocationSize(value.`capacityError`)
            )
            is WebSocketException.Protocol -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeProtocolError.allocationSize(value.`protocolError`)
            )
            is WebSocketException.WriteBufferFull -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeWebSocketMessage.allocationSize(value.`msg`)
            )
            is WebSocketException.Utf8 -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is WebSocketException.AttackAttempt -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL
            )
            is WebSocketException.Url -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterString.allocationSize(value.`urlError`)
            )
            is WebSocketException.Http -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeResponse.allocationSize(value.`response`)
            )
            is WebSocketException.HttpFormat -> (
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                4UL +
                    FfiConverterTypeHttpError.allocationSize(value.`error`)
            )
        }

    override fun write(
        value: WebSocketException,
        buf: ByteBuffer,
    ) {
        when (value) {
            is WebSocketException.ConnectionClosed -> {
                buf.putInt(1)
                Unit
            }
            is WebSocketException.AlreadyClosed -> {
                buf.putInt(2)
                Unit
            }
            is WebSocketException.Io -> {
                buf.putInt(3)
                FfiConverterTypeIoError.write(value.`ioError`, buf)
                Unit
            }
            is WebSocketException.Tls -> {
                buf.putInt(4)
                FfiConverterString.write(value.`tlsError`, buf)
                Unit
            }
            is WebSocketException.Capacity -> {
                buf.putInt(5)
                FfiConverterTypeCapacityError.write(value.`capacityError`, buf)
                Unit
            }
            is WebSocketException.Protocol -> {
                buf.putInt(6)
                FfiConverterTypeProtocolError.write(value.`protocolError`, buf)
                Unit
            }
            is WebSocketException.WriteBufferFull -> {
                buf.putInt(7)
                FfiConverterTypeWebSocketMessage.write(value.`msg`, buf)
                Unit
            }
            is WebSocketException.Utf8 -> {
                buf.putInt(8)
                Unit
            }
            is WebSocketException.AttackAttempt -> {
                buf.putInt(9)
                Unit
            }
            is WebSocketException.Url -> {
                buf.putInt(10)
                FfiConverterString.write(value.`urlError`, buf)
                Unit
            }
            is WebSocketException.Http -> {
                buf.putInt(11)
                FfiConverterTypeResponse.write(value.`response`, buf)
                Unit
            }
            is WebSocketException.HttpFormat -> {
                buf.putInt(12)
                FfiConverterTypeHttpError.write(value.`error`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * [tokio_tungstenite::tungstenite::protocol::Message], but with `uniffi` support.
 * An enum representing the various forms of a WebSocket message.
 */
sealed class WebSocketMessage {
    /**
     * A text WebSocket message
     */
    data class Text(
        /**
         * The text of the message.
         */
        val `text`: kotlin.String,
    ) : WebSocketMessage() {
        companion object
    }

    /**
     * A binary WebSocket message
     */
    data class Binary(
        /**
         * The binary bytes of the message.
         */
        val `bytes`: kotlin.ByteArray,
    ) : WebSocketMessage() {
        companion object
    }

    /**
     * A ping message with the specified payload
     *
     * The payload here must have a length less than 125 bytes
     */
    data class Ping(
        /**
         * The bytes that should be sent back in a [WebSocketMessage::Pong] message.
         */
        val `bytes`: kotlin.ByteArray,
    ) : WebSocketMessage() {
        companion object
    }

    /**
     * A pong message with the specified payload
     *
     * The payload here must have a length less than 125 bytes
     */
    data class Pong(
        /**
         * The bytes sent back in reply to a [WebSocketMessage::Ping].  The `bytes` should match
         * the last `WebSocketMessage::Pong` to count as an acknowledgement.
         */
        val `bytes`: kotlin.ByteArray,
    ) : WebSocketMessage() {
        companion object
    }

    /**
     * A close message with the optional close frame.
     */
    data class Close(
        /**
         * The optional frame sent when the server closes the web socket.  Includes the code and
         * reason.
         */
        val `closeFrame`: CloseFrame?,
    ) : WebSocketMessage() {
        companion object
    }

    /**
     * Raw frame. Note, that you're not going to get this value while reading the message.
     */
    data class WebSocketFrame(
        /**
         * A raw frame that hasn't been categorized into the other variants.
         */
        val `frame`: Frame,
    ) : WebSocketMessage() {
        companion object
    }

    companion object
}

/**
 * @suppress
 */
public object FfiConverterTypeWebSocketMessage : FfiConverterRustBuffer<WebSocketMessage> {
    override fun read(buf: ByteBuffer): WebSocketMessage =
        when (buf.getInt()) {
            1 ->
                WebSocketMessage.Text(
                    FfiConverterString.read(buf),
                )
            2 ->
                WebSocketMessage.Binary(
                    FfiConverterByteArray.read(buf),
                )
            3 ->
                WebSocketMessage.Ping(
                    FfiConverterByteArray.read(buf),
                )
            4 ->
                WebSocketMessage.Pong(
                    FfiConverterByteArray.read(buf),
                )
            5 ->
                WebSocketMessage.Close(
                    FfiConverterOptionalTypeCloseFrame.read(buf),
                )
            6 ->
                WebSocketMessage.WebSocketFrame(
                    FfiConverterTypeFrame.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }

    override fun allocationSize(value: WebSocketMessage) =
        when (value) {
            is WebSocketMessage.Text -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterString.allocationSize(value.`text`)
                )
            }
            is WebSocketMessage.Binary -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterByteArray.allocationSize(value.`bytes`)
                )
            }
            is WebSocketMessage.Ping -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterByteArray.allocationSize(value.`bytes`)
                )
            }
            is WebSocketMessage.Pong -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterByteArray.allocationSize(value.`bytes`)
                )
            }
            is WebSocketMessage.Close -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterOptionalTypeCloseFrame.allocationSize(value.`closeFrame`)
                )
            }
            is WebSocketMessage.WebSocketFrame -> {
                // Add the size for the Int that specifies the variant plus the size needed for all fields
                (
                    4UL +
                        FfiConverterTypeFrame.allocationSize(value.`frame`)
                )
            }
        }

    override fun write(
        value: WebSocketMessage,
        buf: ByteBuffer,
    ) {
        when (value) {
            is WebSocketMessage.Text -> {
                buf.putInt(1)
                FfiConverterString.write(value.`text`, buf)
                Unit
            }
            is WebSocketMessage.Binary -> {
                buf.putInt(2)
                FfiConverterByteArray.write(value.`bytes`, buf)
                Unit
            }
            is WebSocketMessage.Ping -> {
                buf.putInt(3)
                FfiConverterByteArray.write(value.`bytes`, buf)
                Unit
            }
            is WebSocketMessage.Pong -> {
                buf.putInt(4)
                FfiConverterByteArray.write(value.`bytes`, buf)
                Unit
            }
            is WebSocketMessage.Close -> {
                buf.putInt(5)
                FfiConverterOptionalTypeCloseFrame.write(value.`closeFrame`, buf)
                Unit
            }
            is WebSocketMessage.WebSocketFrame -> {
                buf.putInt(6)
                FfiConverterTypeFrame.write(value.`frame`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}

/**
 * @suppress
 */
public object FfiConverterOptionalByteArray : FfiConverterRustBuffer<kotlin.ByteArray?> {
    override fun read(buf: ByteBuffer): kotlin.ByteArray? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterByteArray.read(buf)
    }

    override fun allocationSize(value: kotlin.ByteArray?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterByteArray.allocationSize(value)
        }
    }

    override fun write(
        value: kotlin.ByteArray?,
        buf: ByteBuffer,
    ) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterByteArray.write(value, buf)
        }
    }
}

/**
 * @suppress
 */
public object FfiConverterOptionalTypeCloseFrame : FfiConverterRustBuffer<CloseFrame?> {
    override fun read(buf: ByteBuffer): CloseFrame? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeCloseFrame.read(buf)
    }

    override fun allocationSize(value: CloseFrame?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypeCloseFrame.allocationSize(value)
        }
    }

    override fun write(
        value: CloseFrame?,
        buf: ByteBuffer,
    ) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeCloseFrame.write(value, buf)
        }
    }
}

/**
 * @suppress
 */
public object FfiConverterOptionalTypePresence : FfiConverterRustBuffer<Presence?> {
    override fun read(buf: ByteBuffer): Presence? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypePresence.read(buf)
    }

    override fun allocationSize(value: Presence?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypePresence.allocationSize(value)
        }
    }

    override fun write(
        value: Presence?,
        buf: ByteBuffer,
    ) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypePresence.write(value, buf)
        }
    }
}

/**
 * @suppress
 */
public object FfiConverterOptionalTypePayload : FfiConverterRustBuffer<Payload?> {
    override fun read(buf: ByteBuffer): Payload? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypePayload.read(buf)
    }

    override fun allocationSize(value: Payload?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterTypePayload.allocationSize(value)
        }
    }

    override fun write(
        value: Payload?,
        buf: ByteBuffer,
    ) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypePayload.write(value, buf)
        }
    }
}

/**
 * @suppress
 */
public object FfiConverterOptionalSequenceString : FfiConverterRustBuffer<List<kotlin.String>?> {
    override fun read(buf: ByteBuffer): List<kotlin.String>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceString.read(buf)
    }

    override fun allocationSize(value: List<kotlin.String>?): ULong {
        if (value == null) {
            return 1UL
        } else {
            return 1UL + FfiConverterSequenceString.allocationSize(value)
        }
    }

    override fun write(
        value: List<kotlin.String>?,
        buf: ByteBuffer,
    ) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceString.write(value, buf)
        }
    }
}

/**
 * @suppress
 */
public object FfiConverterSequenceString : FfiConverterRustBuffer<List<kotlin.String>> {
    override fun read(buf: ByteBuffer): List<kotlin.String> {
        val len = buf.getInt()
        return List<kotlin.String>(len) {
            FfiConverterString.read(buf)
        }
    }

    override fun allocationSize(value: List<kotlin.String>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterString.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(
        value: List<kotlin.String>,
        buf: ByteBuffer,
    ) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterString.write(it, buf)
        }
    }
}

/**
 * @suppress
 */
public object FfiConverterSequenceTypeMeta : FfiConverterRustBuffer<List<Meta>> {
    override fun read(buf: ByteBuffer): List<Meta> {
        val len = buf.getInt()
        return List<Meta>(len) {
            FfiConverterTypeMeta.read(buf)
        }
    }

    override fun allocationSize(value: List<Meta>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeMeta.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(
        value: List<Meta>,
        buf: ByteBuffer,
    ) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeMeta.write(it, buf)
        }
    }
}

/**
 * @suppress
 */
public object FfiConverterSequenceTypePresence : FfiConverterRustBuffer<List<Presence>> {
    override fun read(buf: ByteBuffer): List<Presence> {
        val len = buf.getInt()
        return List<Presence>(len) {
            FfiConverterTypePresence.read(buf)
        }
    }

    override fun allocationSize(value: List<Presence>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypePresence.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(
        value: List<Presence>,
        buf: ByteBuffer,
    ) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypePresence.write(it, buf)
        }
    }
}

/**
 * @suppress
 */
public object FfiConverterSequenceTypeJSON : FfiConverterRustBuffer<List<Json>> {
    override fun read(buf: ByteBuffer): List<Json> {
        val len = buf.getInt()
        return List<Json>(len) {
            FfiConverterTypeJSON.read(buf)
        }
    }

    override fun allocationSize(value: List<Json>): ULong {
        val sizeForLength = 4UL
        val sizeForItems = value.map { FfiConverterTypeJSON.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(
        value: List<Json>,
        buf: ByteBuffer,
    ) {
        buf.putInt(value.size)
        value.iterator().forEach {
            FfiConverterTypeJSON.write(it, buf)
        }
    }
}

/**
 * @suppress
 */
public object FfiConverterMapStringTypeJSON : FfiConverterRustBuffer<Map<kotlin.String, Json>> {
    override fun read(buf: ByteBuffer): Map<kotlin.String, Json> {
        val len = buf.getInt()
        return buildMap<kotlin.String, Json>(len) {
            repeat(len) {
                val k = FfiConverterString.read(buf)
                val v = FfiConverterTypeJSON.read(buf)
                this[k] = v
            }
        }
    }

    override fun allocationSize(value: Map<kotlin.String, Json>): ULong {
        val spaceForMapSize = 4UL
        val spaceForChildren =
            value
                .map { (k, v) ->
                    FfiConverterString.allocationSize(k) +
                        FfiConverterTypeJSON.allocationSize(v)
                }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(
        value: Map<kotlin.String, Json>,
        buf: ByteBuffer,
    ) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterTypeJSON.write(v, buf)
        }
    }
}

/**
 * @suppress
 */
public object FfiConverterMapStringSequenceString : FfiConverterRustBuffer<Map<kotlin.String, List<kotlin.String>>> {
    override fun read(buf: ByteBuffer): Map<kotlin.String, List<kotlin.String>> {
        val len = buf.getInt()
        return buildMap<kotlin.String, List<kotlin.String>>(len) {
            repeat(len) {
                val k = FfiConverterString.read(buf)
                val v = FfiConverterSequenceString.read(buf)
                this[k] = v
            }
        }
    }

    override fun allocationSize(value: Map<kotlin.String, List<kotlin.String>>): ULong {
        val spaceForMapSize = 4UL
        val spaceForChildren =
            value
                .map { (k, v) ->
                    FfiConverterString.allocationSize(k) +
                        FfiConverterSequenceString.allocationSize(v)
                }.sum()
        return spaceForMapSize + spaceForChildren
    }

    override fun write(
        value: Map<kotlin.String, List<kotlin.String>>,
        buf: ByteBuffer,
    ) {
        buf.putInt(value.size)
        // The parens on `(k, v)` here ensure we're calling the right method,
        // which is important for compatibility with older android devices.
        // Ref https://blog.danlew.net/2017/03/16/kotlin-puzzler-whose-line-is-it-anyways/
        value.forEach { (k, v) ->
            FfiConverterString.write(k, buf)
            FfiConverterSequenceString.write(v, buf)
        }
    }
}

/**
 * Typealias from the type name used in the UDL file to the custom type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
public typealias Url = URL

/**
 * @suppress
 */
public object FfiConverterTypeUrl : FfiConverter<Url, RustBuffer.ByValue> {
    override fun lift(value: RustBuffer.ByValue): Url {
        val builtinValue = FfiConverterString.lift(value)
        return URI(builtinValue).toURL()
    }

    override fun lower(value: Url): RustBuffer.ByValue {
        val builtinValue = value.toString()
        return FfiConverterString.lower(builtinValue)
    }

    override fun read(buf: ByteBuffer): Url {
        val builtinValue = FfiConverterString.read(buf)
        return URI(builtinValue).toURL()
    }

    override fun allocationSize(value: Url): ULong {
        val builtinValue = value.toString()
        return FfiConverterString.allocationSize(builtinValue)
    }

    override fun write(
        value: Url,
        buf: ByteBuffer,
    ) {
        val builtinValue = value.toString()
        FfiConverterString.write(builtinValue, buf)
    }
}
